<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API DOCUMENTATION</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css" />
    <link rel="icon" type="image/png" href="https://petstore.swagger.io/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="https://petstore.swagger.io/favicon-16x16.png" sizes="16x16" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #0f766e 0%, #115e59 100%);
            --secondary-gradient: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow-primary: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-elevated: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --success-color: #059669;
            --primary-color: #0f766e;
            --primary-accent: rgba(15, 118, 110, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --card-bg: #ffffff;
            --card-bg-hover: rgba(240, 249, 255, 0.8);
            --border-secondary: rgba(226, 232, 240, 0.8);
            --border-primary: rgba(15, 118, 110, 0.2);
            --border-light: rgba(226, 232, 240, 0.5);
            --bg-secondary: #f8fafc;
            --hover-bg: rgba(240, 249, 255, 0.6);
            --scrollbar-track: #f1f5f9;
            --scrollbar-thumb: linear-gradient(135deg, #64748b, #475569);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #1e293b;
        }

        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #64748b, #475569);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #475569, #334155);
        }

        /* Enhanced scrollbar for autocomplete */
        #autocomplete-list::-webkit-scrollbar {
            width: 4px;
        }

        #autocomplete-list::-webkit-scrollbar-track {
            background: rgba(241, 245, 249, 0.5);
            border-radius: 2px;
        }

        #autocomplete-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(14, 165, 233, 0.3);
        }

        #autocomplete-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #0284c7, #0369a1);
        }

        /* Enhanced animations */
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Remove text-shadow for crisper text */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }


        /* Draggable notch and floating filter panel for domain filters (landing page) */
        #filterNotch {
            position: fixed;
            right: 28px;
            top: 120px;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: var(--primary-gradient);
            color: #fff;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 20px rgba(15, 118, 110, 0.18);
            cursor: grab;
            z-index: 1200;
            transition: transform 0.12s ease, opacity 0.12s ease;
        }

        #filterNotch:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .filter-panel {
            position: fixed;
            min-width: 280px;
            max-width: 420px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            box-shadow: 0 14px 40px rgba(2, 6, 23, 0.16);
            z-index: 1199;
            padding: 12px;
            display: none;
            /* toggled open/closed */
            flex-direction: column;
            gap: 8px;
            border: 1px solid rgba(2, 6, 23, 0.06);
            /* Prepare for merge-from / merge-into animations */
            transform-origin: center center;
            /* will be dynamically set from JS */
            transform: scale(0.96);
            opacity: 0;
            clip-path: circle(0px at 50% 50%);
            transition: clip-path 360ms cubic-bezier(0.22, 1, 0.36, 1),
                transform 300ms cubic-bezier(0.22, 1, 0.36, 1),
                opacity 220ms ease;
            will-change: clip-path, transform, opacity;
        }

        .filter-panel .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .filter-panel .panel-title {
            font-weight: 700;
            color: #0f766e;
            font-size: 0.95rem;
        }

        .filter-panel .panel-close {
            background: transparent;
            border: none;
            font-size: 1.1rem;
            cursor: pointer;
            color: #64748b;
        }

        /* Utility classes for open/close states */
        .filter-panel.open {
            opacity: 1;
            transform: scale(1);
            /* large circle ensures full reveal; JS will set the center point */
            clip-path: circle(1200px at var(--clip-x, 50%) var(--clip-y, 50%));
            display: flex;
            /* ensure visible when open class is applied */
        }

        .filter-panel.closing {
            /* while closing we'll animate back to a small circle */
            opacity: 0;
            transform: scale(0.96);
            /* clip-path will be set by JS to circle(0px at x y) */
        }

        #panelDomainFilters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }



        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        @keyframes dropdownGlow {
            0% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            }

            50% {
                box-shadow: 0 6px 16px rgba(14, 165, 233, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }

            100% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            }
        }

        @keyframes listSlideIn {
            0% {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes dropdownPulse {
            0% {
                transform: translateY(-3px) scale(1.02);
            }

            50% {
                transform: translateY(-4px) scale(1.03);
                box-shadow: 0 0 0 6px rgba(14, 165, 233, 0.2),
                    0 15px 35px rgba(14, 165, 233, 0.25),
                    0 10px 25px rgba(0, 0, 0, 0.2);
            }

            100% {
                transform: translateY(-3px) scale(1.02);
            }
        }

        @keyframes dropdownExpand {
            0% {
                height: 52px;
                border-radius: 26px;
            }

            100% {
                height: auto;
                border-radius: 20px 20px 8px 8px;
            }
        }

        @keyframes arrowSpin {
            0% {
                transform: translateY(-50%) rotate(0deg) scale(1.1);
            }

            50% {
                transform: translateY(-50%) rotate(90deg) scale(1.2);
            }

            100% {
                transform: translateY(-50%) rotate(180deg) scale(1.1);
            }
        }

        @keyframes optionSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Dropdown opening state */
        .dropdown-opening {
            animation: dropdownPulse 0.6s ease-out !important;
        }

        .dropdown-opening .dropdown-arrow {
            animation: arrowSpin 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
        }

        /* Dropdown container glow effect */
        .dropdown-container::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #0ea5e9, #10b981, #f59e0b, #ef4444, #8b5cf6, #0ea5e9);
            background-size: 400% 400%;
            border-radius: 28px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: gradientShift 3s ease infinite;
        }

        .dropdown-container:has(select:focus)::after {
            opacity: 0.6;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* Input focus ring */
        .focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1), 0 0 0 1px rgb(14, 165, 233);
        }

        /* Hover lift effect */
        .hover-lift {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hover-lift:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-elevated);
        }

        /* Header styles */
        header {
            background: var(--primary-gradient);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(15, 118, 110, 0.2);
            animation: slideInDown 0.8s ease-out;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
        }

        /* Scroll progress indicator */
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 3px;
            width: var(--scroll-progress, 0%);
            background: linear-gradient(90deg, #14b8a6, #06b6d4, #0ea5e9);
            transition: width 0.1s ease-out;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
        }

        header.scrolled::before {
            opacity: 1;
        }

        /* Scrolled state - compact and elevated */
        header.scrolled {
            background: linear-gradient(135deg, rgba(15, 118, 110, 0.98) 0%, rgba(17, 94, 89, 0.98) 100%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            box-shadow: 0 12px 40px rgba(15, 118, 110, 0.35);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 32px;
            gap: 32px;
            transition: padding 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Compact header when scrolled */
        header.scrolled .header-content {
            padding: 12px 32px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 16px;
            transition: gap 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        header.scrolled .brand {
            gap: 12px;
        }

        .brand img {
            height: 48px;
            width: 48px;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Smaller logo when scrolled */
        header.scrolled .brand img {
            height: 38px;
            width: 38px;
            border-radius: 10px;
        }

        .brand img:hover {
            transform: scale(1.05) rotate(5deg);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .brand-text {
            color: white;
            font-weight: 700;
            font-size: 1.5rem;
            letter-spacing: -0.025em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Smaller text when scrolled */
        header.scrolled .brand-text {
            font-size: 1.3rem;
        }

        /* Controls section */
        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Subtle lift effect when scrolled */
        header.scrolled .controls {
            transform: translateY(-1px);
        }

        /* Search input container */
        .search-container {
            position: relative;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 9999;
        }

        .search-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 18px;
            z-index: 10;
            transition: color 0.3s ease;
        }

        .clear-search-icon {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            z-index: 10;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .clear-search-icon:hover {
            color: #ef4444;
            opacity: 1;
            transform: translateY(-50%) scale(1.1);
        }

        input#apiSearch {
            width: 320px;
            height: 52px;
            padding: 0 20px 0 50px;
            border-radius: 26px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.95);
            color: #1e293b;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced glow when header is scrolled */
        header.scrolled input#apiSearch {
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: 0 4px 16px rgba(14, 165, 233, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        input#apiSearch:focus {
            outline: none;
            background: white;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1), 0 8px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        input#apiSearch:focus+.search-icon {
            color: #0ea5e9;
        }

        input#apiSearch::placeholder {
            color: #64748b;
            font-weight: 400;
        }

        /* Dropdown container */
        .dropdown-container {
            position: relative;
            z-index: 9999;
        }

        .dropdown-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            z-index: 10;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .dropdown-container:hover .dropdown-icon {
            color: #0ea5e9;
            transform: translateY(-50%) scale(1.1);
        }

        select#apiDropdown:focus+.dropdown-arrow+* .dropdown-icon,
        .dropdown-container:has(select:focus) .dropdown-icon {
            color: #0ea5e9;
            transform: translateY(-50%) scale(1.1);
        }

        /* Custom dropdown button styling */
        .dropdown-button {
            width: 320px;
            height: 52px;
            padding: 0 50px 0 45px;
            border-radius: 26px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            color: #1e293b;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: space-between;
            text-align: left;
        }

        /* Enhanced glow when header is scrolled */
        header.scrolled .dropdown-button {
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: 0 4px 16px rgba(14, 165, 233, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .dropdown-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(14, 165, 233, 0.3);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transform: translateY(-1px);
        }

        .dropdown-button:focus,
        .dropdown-button.active {
            outline: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(240, 249, 255, 0.98) 100%);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.15),
                0 12px 30px rgba(14, 165, 233, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            transform: translateY(-3px) scale(1.02);
        }

        /* Dropdown list styling */
        .dropdown-list {
            position: absolute;
            top: 60px;
            left: 0;
            width: auto;
            min-width: 100%;
            max-width: 500px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10000;
            display: none;
            animation: listSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .dropdown-list.show {
            display: block;
        }

        .dropdown-item {
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #334155;
            font-weight: 500;
            border-bottom: 1px solid rgba(241, 245, 249, 0.7);
            font-size: 14px;
            position: relative;
            overflow: hidden;
            min-height: 54px;
            display: flex;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
            border-radius: 0 0 16px 16px;
        }

        .dropdown-item:first-child {
            border-radius: 16px 16px 0 0;
        }

        .dropdown-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 0;
            height: 100%;
            background: var(--primary-gradient);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 2px 0 8px rgba(15, 118, 110, 0.3);
        }

        .dropdown-item:hover {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            padding-left: 28px;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.1);
        }

        .dropdown-item:hover::before {
            width: 4px;
        }

        .dropdown-item:active {
            transform: translateX(2px) scale(0.98);
            background: linear-gradient(135deg, rgba(224, 242, 254, 0.9) 0%, rgba(186, 230, 253, 0.7) 100%);
        }

        .dropdown-item.selected {
            background: var(--primary-gradient);
            color: white;
            font-weight: 600;
        }

        .dropdown-item.selected .domain-tag {
            background: rgba(255, 255, 255, 0.2) !important;
            color: white !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }

        .dropdown-item.focused {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            outline: 2px solid rgba(14, 165, 233, 0.3);
            outline-offset: -2px;
        }

        /* Hide original select */
        select#apiDropdown {
            display: none;
        }

        /* Dropdown opening animation overlay */
        select#apiDropdown::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(14, 165, 233, 0.1), transparent);
            transition: left 0.6s ease;
            pointer-events: none;
        }

        select#apiDropdown:focus::before {
            left: 100%;
        }

        select#apiDropdown:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(14, 165, 233, 0.3);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transform: translateY(-1px);
        }

        select#apiDropdown:focus {
            outline: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(240, 249, 255, 0.98) 100%);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.15),
                0 12px 30px rgba(14, 165, 233, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            transform: translateY(-3px) scale(1.02);
            animation: dropdownPulse 0.6s ease-out;
        }



        .dropdown-arrow {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #64748b, #475569);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .dropdown-container:hover .dropdown-arrow {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            transform: translateY(-50%) scale(1.1);
        }

        select#apiDropdown:focus+.dropdown-arrow {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: arrowSpin 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: translateY(-50%) rotate(180deg) scale(1.1);
            filter: drop-shadow(0 3px 6px rgba(14, 165, 233, 0.4));
        }

        /* Autocomplete dropdown */
        #autocomplete-list {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            max-height: 300px;
            overflow-y: auto;
            z-index: 10000;
            animation: listSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .autocomplete-item {
            position: relative;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #334155;
            font-weight: 500;
            border-bottom: 1px solid rgba(241, 245, 249, 0.7);
            overflow: hidden;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
            border-radius: 0 0 20px 20px;
        }

        .autocomplete-item:first-child {
            border-radius: 20px 20px 0 0;
        }

        .autocomplete-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 0;
            height: 100%;
            background: var(--primary-gradient);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 2px 0 8px rgba(15, 118, 110, 0.3);
        }

        .autocomplete-item::after {
            content: '';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
        }

        .autocomplete-item:hover {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            padding-left: 28px;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.1);
        }

        .autocomplete-item:hover::before {
            width: 4px;
        }

        .autocomplete-item:hover::after {
            transform: translateY(-50%) scale(1);
            opacity: 0.8;
        }

        .autocomplete-item:active {
            transform: translateX(2px) scale(0.98);
            background: linear-gradient(135deg, rgba(224, 242, 254, 0.9) 0%, rgba(186, 230, 253, 0.7) 100%);
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Swagger UI container enhancements */
        #swagger-ui {
            animation: slideInUp 0.6s ease-out;
            border-radius: 24px;
            background: white;
            box-shadow: var(--shadow-primary);
            margin: 32px;
            overflow: hidden;
            padding: 0;
        }

        /* Mobile responsiveness */
        @media (max-width: 1024px) {
            .header-content {
                padding: 16px 24px;
                gap: 24px;
            }

            .controls {
                gap: 16px;
            }

            input#apiSearch {
                width: 280px;
            }

            .dropdown-button {
                width: 280px;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 20px;
                padding: 20px 16px;
            }

            .controls {
                flex-direction: column;
                gap: 16px;
                width: 100%;
            }

            .search-container,
            .dropdown-container {
                width: 100%;
            }

            input#apiSearch,
            .dropdown-button {
                width: 100%;
                min-width: 280px;
            }

            .dropdown-list {
                left: 0;
                right: 0;
                max-width: none;
                width: 100%;
            }

            #autocomplete-list {
                width: 100%;
            }

            #swagger-ui {
                margin: 16px;
                border-radius: 16px;
            }

            .brand-text {
                font-size: 1.25rem;
            }

            /* Filter bar responsive */
            .filter-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 12px 16px;
                gap: 12px;
            }

            .method-filter-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 12px 16px;
                gap: 12px;
            }

            .filter-label {
                align-self: flex-start;
                margin-bottom: 4px;
            }

            #domainFilters,
            #methodFilters {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .domain-chip,
            .method-chip {
                font-size: 0.8rem;
                padding: 8px 14px;
            }

            .clear-filters-btn {
                align-self: center;
                margin-top: 8px;
                margin-left: 0;

            }


            /* Endpoint filter bar responsive */
            .endpoint-filter-content {
                flex-direction: column;
                position: relative;
                align-items: stretch;
                gap: 16px;
            }

            .filter-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            #endpointSearch {
                width: 100%;
                min-width: 250px;
            }

            .endpoint-method-filters {
                width: 100%;
                justify-content: flex-start;
            }

            .clear-endpoint-filters-btn {
                align-self: flex-start;
                margin-left: 0;
                margin-top: 8px;
            }
        }

        @media (max-width: 480px) {

            input#apiSearch,
            .dropdown-button {
                min-width: 100%;
                height: 48px;
                font-size: 14px;
            }
        }

        /* Hexagonal API Display Styles */
        .hexagon-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: calc(100vh - 120px);
        }

        .hexagon-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 100vw;
            margin: 0 auto;
            position: relative;
            padding: 0 40px;
        }

        .hexagon-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
            flex-wrap: wrap;
        }

        .hexagon-row:nth-child(even) {
            margin-left: 110px;
        }

        .hexagon-item {
            position: relative;
            width: 200px;
            height: 173.2px;
            margin: 20px 0;
            cursor: pointer;
            transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                filter 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.3s ease;
            animation: fadeInScale 0.6s ease-out;
            animation-fill-mode: both;
            will-change: opacity, transform, filter;
        }

        /* Search filtering animations */
        .hexagon-item.filtered-out {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(1);
            pointer-events: none;
        }

        .hexagon-item.filtered-in {
            opacity: 1;
            transform: scale(1);
            filter: none;
        }

        /* Domain filtering - instant and clean like card view with no position memory */
        .hexagon-item.domain-filtered-out {
            opacity: 0 !important;
            transform: scale(1) translateY(0) !important;
            filter: none !important;
            pointer-events: none;
            display: none !important;
            visibility: hidden !important;
            /* No transitions to prevent position memory and flickering */
            transition: none !important;
        }

        .hexagon-item.domain-filtered-in {
            opacity: 1 !important;
            transform: scale(1) translateY(0) !important;
            filter: none !important;
            display: block !important;
            visibility: visible !important;
            /* Clean instant appearance without animation delays */
            transition: none !important;
        }

        .hexagon-item:nth-child(1) {
            animation-delay: 0.1s;
        }

        .hexagon-item:nth-child(2) {
            animation-delay: 0.2s;
        }

        .hexagon-item:nth-child(3) {
            animation-delay: 0.3s;
        }

        .hexagon-item:nth-child(4) {
            animation-delay: 0.4s;
        }

        .hexagon-item:nth-child(5) {
            animation-delay: 0.5s;
        }

        .hexagon-item:nth-child(6) {
            animation-delay: 0.6s;
        }

        .hexagon-item:nth-child(7) {
            animation-delay: 0.7s;
        }

        .hexagon-item:nth-child(8) {
            animation-delay: 0.8s;
        }

        .hexagon-item:nth-child(9) {
            animation-delay: 0.9s;
        }

        .hexagon-item:nth-child(10) {
            animation-delay: 1.0s;
        }

        .hexagon-shape {
            position: relative;
            width: 200px;
            height: 173.2px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            transform: rotate(30deg);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
        }

        .hexagon-shape::before,
        .hexagon-shape::after {
            content: '';
            position: absolute;
            width: 200px;
            height: 173.2px;
            background: inherit;
            border-radius: inherit;
            box-shadow: inherit;
        }

        .hexagon-shape::before {
            transform: rotate(60deg);
        }

        .hexagon-shape::after {
            transform: rotate(-60deg);
        }

        .hexagon-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-30deg);
            text-align: center;
            z-index: 10;
            width: 160px;
            height: 160px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .hexagon-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            transition: all 0.3s ease;
        }

        .hexagon-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 4px;
            line-height: 1.2;
            max-height: 2.4em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .domain-badge {
            position: absolute;
            top: 11px;
            right: -8px;
            padding: 6px 12px 6px 10px;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            border: none;
            transition: all 0.3s ease;
            z-index: 15;
            /* reduced shadow for crisper appearance */
            box-shadow: 0 8px 20px rgba(2, 6, 23, 0.09);
            clip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%, 0 calc(100% - 8px));
            transform: rotate(30deg);
            transform-origin: center;
            /* reduce the blur effect for crisper text */
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            min-width: 60px;
            text-align: center;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
        }

        .domain-badge::before {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-top: 6px solid currentColor;
            opacity: 0.7;
            filter: brightness(0.7);
        }

        .domain-badge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 50%, transparent 100%);
            pointer-events: none;
            clip-path: inherit;
        }

        .hexagon-item:hover .domain-badge {
            box-shadow:
                0 12px 35px rgba(0, 0, 0, 0.25),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transform: rotate(30deg) scale(1.08);
            filter: brightness(1.1) saturate(1.1);
        }

        .hexagon-item.active .domain-badge {
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.3),
                0 10px 25px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            filter: brightness(1.2) saturate(1.2);
        }

        .hexagon-item.active .domain-badge::before {
            opacity: 0.8;
        }

        /* Filter Bar Styles */
        .filter-bar {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            justify-content: center;
            margin: 15px auto;
            padding: 0;
            width: 95%;
            max-width: 100%;
            background: transparent;
            border: none;
            animation: slideInDown 0.6s ease-out;
        }

        /* Endpoint Filter Bar: fixed under the header so it remains visible while content scrolls beneath it. */
        /* The inner wrapper (.endpoint-filter-wrapper) constrains width while the bar stretches full-width. */
        .endpoint-filter-bar {
            position: fixed;
            top: var(--navbar-height, 0px);
            left: 0;
            right: 0;
            z-index: 999;
            /* header is 1000, so bar sits below header but above content */
            display: flex;
            justify-content: center;
            pointer-events: auto;
            padding: 8px 0;
            background: rgba(255, 255, 255, 0.6);
            /* semi-transparent so content can be seen beneath */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 6px 18px rgba(15, 118, 110, 0.08);
            transition: top 0s, transform 0.18s ease, height 0.18s ease, padding 0.18s ease;
        }

        .endpoint-filter-bar .endpoint-filter-wrapper {
            width: 90%;
            max-width: 980px;
            margin: 0 auto;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* center content horizontally */
        }

        .endpoint-filter-content {
            padding: 12px 18px;
            display: flex;
            flex-direction: column;
            /* stack search above filters */
            gap: 12px;
            align-items: center;
            justify-content: center;
            background: transparent;
            width: 100%;
        }

        /* Rows inside the fixed wrapper */
        .search-row {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .method-row {
            width: 100%;
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Collapse behavior */
        .endpoint-filter-bar.collapsed {
            height: 44px;
            padding-top: 6px;
            padding-bottom: 6px;
        }

        .endpoint-filter-bar.collapsed .endpoint-filter-content {
            display: none;
        }

        /* Toggle button shown on the right side of the fixed bar */
        .collapse-toggle {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-gradient);
            border: 1px solid rgba(16, 185, 129, 0.28);
            color: #ffffff;
            width: 34px;
            height: 34px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 22px rgba(16, 185, 129, 0.18), 0 2px 6px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            z-index: 1001;
            /* above the bar content */
            transition: transform 0.14s ease, box-shadow 0.14s ease, opacity 0.14s ease;
            opacity: 0.95;
        }

        .collapse-toggle i {
            color: #ffffff;
            /* ensure icon/text is white */
            font-size: 14px;
            line-height: 1;
            transition: transform 0.12s ease;
        }

        .collapse-toggle:hover {
            transform: translateY(-50%) scale(1.04);
            box-shadow: 0 14px 36px rgba(16, 185, 129, 0.26), 0 6px 14px rgba(0, 0, 0, 0.12);
            opacity: 1;
        }

        .collapse-toggle:active {
            transform: translateY(-50%) scale(0.98);
        }

        .collapse-toggle:focus {
            outline: none;
            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.12);
        }

        .collapse-toggle:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.08);
        }

        .filter-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #64748b;
            white-space: nowrap;
        }

        .filter-label i {
            font-size: 0.9rem;
        }

        /* Endpoint Search */
        .search-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .endpoint-search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .endpoint-search-container .fas.fa-search {
            position: absolute;
            left: 12px;
            color: #64748b;
            font-size: 14px;
            z-index: 10;
        }

        .endpoint-search-container .clear-endpoint-search {
            position: absolute;
            right: 12px;
            color: #64748b;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
            z-index: 10;
        }

        .endpoint-search-container .clear-endpoint-search:hover {
            color: #ef4444;
            opacity: 1;
            transform: scale(1.1);
        }

        #endpointSearch {
            width: 280px;
            height: 40px;
            padding: 0 40px 0 40px;
            border-radius: 25px;
            border: 2px solid rgba(226, 232, 240, 0.6);
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            color: #1e293b;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        #endpointSearch:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.95);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.15), 0 8px 30px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        #endpointSearch::placeholder {
            color: #64748b;
            font-weight: 400;
        }

        /* Endpoint Method Filters */
        .endpoint-method-filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }



        #domainFilters {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            flex: 1;
            justify-content: center;
        }

        .domain-chip {
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(15, 118, 110, 0.3);
            border: 1.5px solid rgba(15, 118, 110, 0.4);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.75rem;
            color: #0f766e;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: capitalize;
            box-shadow: 0 2px 6px rgba(15, 118, 110, 0.15);
            white-space: nowrap;
            backdrop-filter: blur(4px);
            will-change: transform, background, box-shadow;
        }

        .domain-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .domain-chip:hover::before {
            left: 100%;
        }

        .domain-chip:hover {
            background: rgba(15, 118, 110, 0.4);
            border-color: rgba(15, 118, 110, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.25);
            color: #0d5d56;
        }

        .domain-chip.active {
            background: var(--primary-gradient);
            color: white;
            border-color: #0f766e;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 16px rgba(15, 118, 110, 0.4);
        }

        .domain-chip.active:hover {
            background: linear-gradient(135deg, #0d5d56, #0f766e);
            box-shadow: 0 8px 20px rgba(15, 118, 110, 0.5);
        }

        .domain-chip .chip-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background: rgba(255, 255, 255, 0.95);
            color: #0f766e;
            border-radius: 999px;
            font-size: 0.65rem;
            font-weight: 800;
            box-shadow: 0 2px 6px rgba(2, 6, 23, 0.06);
            border: 1px solid rgba(15, 118, 110, 0.08);
        }

        .domain-chip.active .chip-count {
            background: rgba(255, 255, 255, 0.14);
            color: white;
            border-color: rgba(255, 255, 255, 0.06);
        }

        /* HTTP Method Chips - Floating Style */
        .method-chip,
        .endpoint-method-chip {
            padding: 8px 16px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.75rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            backdrop-filter: blur(12px);
            will-change: transform, background, box-shadow;
            border: 1.5px solid transparent;
            pointer-events: all;
            user-select: none;
        }

        .method-chip:hover,
        .endpoint-method-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        /* HTTP Method specific colors */
        .method-chip[data-method="get"],
        .endpoint-method-chip[data-method="get"] {
            background: rgba(34, 197, 94, 0.2);
            color: #059669;
            border-color: rgba(34, 197, 94, 0.3);
        }

        .method-chip[data-method="post"],
        .endpoint-method-chip[data-method="post"] {
            background: rgba(59, 130, 246, 0.2);
            color: #2563eb;
            border-color: rgba(59, 130, 246, 0.3);
        }

        .method-chip[data-method="put"],
        .endpoint-method-chip[data-method="put"] {
            background: rgba(245, 158, 11, 0.2);
            color: #d97706;
            border-color: rgba(245, 158, 11, 0.3);
        }

        .method-chip[data-method="patch"],
        .endpoint-method-chip[data-method="patch"] {
            background: rgba(168, 85, 247, 0.2);
            color: #7c3aed;
            border-color: rgba(168, 85, 247, 0.3);
        }

        .method-chip[data-method="delete"],
        .endpoint-method-chip[data-method="delete"] {
            background: rgba(239, 68, 68, 0.2);
            color: #dc2626;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .method-chip::before,
        .endpoint-method-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
            pointer-events: none;
            /* Ensure pseudo-element doesn't interfere with clicks */
        }

        .method-chip:hover::before,
        .endpoint-method-chip:hover::before {
            left: 100%;
        }

        .method-chip:hover,
        .endpoint-method-chip:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .method-chip[data-method="get"]:hover,
        .endpoint-method-chip[data-method="get"]:hover {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .method-chip[data-method="post"]:hover,
        .endpoint-method-chip[data-method="post"]:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .method-chip[data-method="put"]:hover,
        .endpoint-method-chip[data-method="put"]:hover {
            background: rgba(245, 158, 11, 0.3);
            border-color: rgba(245, 158, 11, 0.5);
        }

        .method-chip[data-method="patch"]:hover,
        .endpoint-method-chip[data-method="patch"]:hover {
            background: rgba(168, 85, 247, 0.3);
            border-color: rgba(168, 85, 247, 0.5);
        }

        .method-chip[data-method="delete"]:hover,
        .endpoint-method-chip[data-method="delete"]:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .method-chip.active[data-method="get"],
        .endpoint-method-chip.active[data-method="get"] {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border-color: #16a34a;
            box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
        }

        .method-chip.active[data-method="post"],
        .endpoint-method-chip.active[data-method="post"] {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border-color: #2563eb;
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .method-chip.active[data-method="put"],
        .endpoint-method-chip.active[data-method="put"] {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border-color: #d97706;
            box-shadow: 0 6px 16px rgba(245, 158, 11, 0.4);
        }

        .method-chip.active[data-method="patch"],
        .endpoint-method-chip.active[data-method="patch"] {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
            border-color: #7c3aed;
            box-shadow: 0 6px 16px rgba(168, 85, 247, 0.4);
        }

        .method-chip.active[data-method="delete"],
        .endpoint-method-chip.active[data-method="delete"] {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border-color: #dc2626;
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .method-chip .chip-count,
        .endpoint-method-chip .chip-count {
            display: inline-block;
            margin-left: 5px;
            padding: 1px 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 700;
            pointer-events: none;
        }

        .method-chip.active .chip-count,
        .endpoint-method-chip.active .chip-count {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Smooth transitions for filtered hexagons */
        .hexagon-item {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.3s ease,
                transform 0.3s ease,
                filter 0.3s ease;
        }

        .hexagon-item.domain-filtered-out {
            opacity: 0;
            transform: scale(0.8);
            filter: grayscale(0.8) blur(2px);
            pointer-events: none;
            position: absolute;
            visibility: hidden;
        }



        .hexagon-item:hover {
            transform: translateY(-10px) scale(1.05);
        }

        .hexagon-item:hover .hexagon-shape {
            background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
            box-shadow: 0 20px 40px rgba(15, 118, 110, 0.2);
            transform: rotate(30deg) scale(1.02);
        }

        .hexagon-item:hover .hexagon-icon {
            transform: scale(1.1);
            filter: drop-shadow(0 4px 8px rgba(15, 118, 110, 0.3));
        }

        .hexagon-item:hover .hexagon-title {
            color: #0f766e;
        }

        /* Active state for selected hexagon */
        .hexagon-item.active .hexagon-shape {
            background: var(--primary-gradient);
            box-shadow: 0 15px 35px rgba(15, 118, 110, 0.4);
        }

        .hexagon-item.active .hexagon-content {
            color: white;
        }

        .hexagon-item.active .hexagon-title {
            color: white;
        }

        .hexagon-item.active .hexagon-icon {
            -webkit-text-fill-color: white;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        /* Landing page title */
        .landing-title {
            text-align: center;
            margin-bottom: 40px;
            animation: slideInDown 0.8s ease-out;
        }

        .landing-title h1 {
            font-size: 3rem;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .landing-title p {
            font-size: 1.2rem;
            color: #64748b;
            font-weight: 500;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* Hexagonal Home Button */
        .hexagonal-home-btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: var(--shadow-primary);
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            margin-right: 15px;
        }

        .hexagonal-home-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-elevated);
            background: linear-gradient(135deg, #115e59 0%, #0f766e 100%);
        }

        .hexagonal-home-btn i {
            font-size: 1rem;
        }

        /* View Switcher Styles */
        .view-switcher {
            display: flex;
            gap: 4px;
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 4px;
            margin-right: 16px;
            box-shadow: var(--shadow-primary);
            transition: all 0.3s ease;
        }

        .view-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            position: relative;
            overflow: hidden;
        }

        .view-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 8px;
        }

        .view-btn:hover {
            color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: var(--shadow-hover);
        }

        .view-btn:hover::before {
            opacity: 0.1;
        }

        .view-btn.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-elevated);
            transform: translateY(-1px);
        }

        .view-btn.active::before {
            opacity: 0;
        }

        .view-btn i {
            position: relative;
            z-index: 1;
        }

        /* Hide Swagger UI initially */
        #swagger-ui {
            display: none;
        }

        #swagger-ui.show {
            display: block;
        }



        /* Responsive hexagon layout */
        @media (max-width: 1600px) and (min-width: 1201px) {
            .hexagon-row:nth-child(even) {
                margin-left: 90px;
            }
        }

        @media (max-width: 1200px) {
            .hexagon-row:nth-child(even) {
                margin-left: 80px;
            }

            .hexagon-item {
                width: 180px;
                height: 155.9px;
            }

            .hexagon-shape {
                width: 180px;
                height: 155.9px;
            }

            .hexagon-shape::before,
            .hexagon-shape::after {
                width: 180px;
                height: 155.9px;
            }

            .hexagon-content {
                width: 140px;
                height: 140px;
            }

            .hexagon-grid {
                padding: 0 20px;
            }
        }

        @media (max-width: 768px) {
            .hexagon-grid {
                padding: 0 10px;
            }

            .hexagon-row {
                justify-content: center;
                gap: 15px;
            }

            .hexagon-row:nth-child(even) {
                margin-left: 50px;
            }

            .hexagon-item {
                width: 160px;
                height: 138.6px;
                margin: 10px 0;
            }

            .hexagon-shape {
                width: 160px;
                height: 138.6px;
            }

            .hexagon-shape::before,
            .hexagon-shape::after {
                width: 160px;
                height: 138.6px;
            }

            .hexagon-content {
                width: 120px;
                height: 120px;
                padding: 15px;
            }

            .hexagon-icon {
                font-size: 2rem;
                margin-bottom: 8px;
            }

            .hexagon-title {
                font-size: 0.8rem;
            }

            .domain-badge {
                font-size: 0.6rem;
                padding: 2px 6px;
            }



            .landing-title h1 {
                font-size: 2.5rem;
            }

            .landing-title p {
                font-size: 1.1rem;
                padding: 0 20px;
            }
        }

        @media (max-width: 480px) {
            .hexagon-grid {
                padding: 0 5px;
            }

            .hexagon-row {
                gap: 10px;
            }

            .hexagon-row:nth-child(even) {
                margin-left: 30px;
            }

            .hexagon-item {
                width: 140px;
                height: 121.2px;
            }

            .hexagon-shape {
                width: 140px;
                height: 121.2px;
            }

            .hexagon-shape::before,
            .hexagon-shape::after {
                width: 140px;
                height: 121.2px;
            }

            .hexagon-content {
                width: 100px;
                height: 100px;
                padding: 10px;
            }

            .hexagon-icon {
                font-size: 1.8rem;
            }

            .hexagon-title {
                font-size: 0.75rem;
            }

            .domain-badge {
                font-size: 0.55rem;
                padding: 2px 5px;
            }

            .landing-title h1 {
                font-size: 2rem;
            }
        }

        /* ========== VIEW LAYOUT STYLES ========== */

        /* Card View Styles */
        .card-view {
            display: none;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: calc(100vh - 120px);
            width: 100%;
            max-width: 100vw;
            margin: 0 auto;
            position: relative;
        }

        .card-view.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 24px;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            padding: 0 32px;
        }

        .api-card {
            background: linear-gradient(145deg, #ffffff 0%, #fafbfc 50%, #f8fafc 100%);
            border: 1px solid rgba(226, 232, 240, 0.5);
            border-radius: 24px;
            padding: 24px 18px;
            box-shadow:
                0 4px 6px -1px rgba(0, 0, 0, 0.1),
                0 2px 4px -1px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.7) inset;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            /* allow badges to sit on the card edge (overflow visible) */
            overflow: visible;
            width: 200px;
            height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(12px);
            margin: 0px 1px;
            /* Remove animation for instant appearance when filtering */
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        .api-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 20px 20px 0 0;
        }

        .api-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(145deg, rgba(15, 118, 110, 0.02) 0%, rgba(6, 182, 212, 0.04) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 20px;
            pointer-events: none;
        }

        .api-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow:
                0 20px 25px -5px rgba(0, 0, 0, 0.12),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 0 1px rgba(15, 118, 110, 0.1) inset,
                0 4px 16px rgba(15, 118, 110, 0.2);
            border-color: rgba(15, 118, 110, 0.2);
            background: linear-gradient(145deg, #ffffff 0%, #f0fdfa 50%, #ecfdf5 100%);
        }

        .api-card:hover::before {
            /* grow the bottom border on hover */
            transform-origin: center;
            transform: scaleX(0.88);
            transition-timing-function: cubic-bezier(0.2, 0.9, 0.2, 1);
        }

        .api-card:hover::after {
            opacity: 0.1;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            position: relative;
            z-index: 1;
            text-align: center;
            width: 100%;
            height: 100%;
            padding: 4px;
        }

        .card-icon {
            width: 72px;
            height: 72px;
            font-size: 2.2rem;
            background: var(--primary-gradient);
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 16px rgba(15, 118, 110, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            position: relative;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .card-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 20px;
        }

        .api-card:hover .card-icon {
            transform: scale(1.08) rotate(-3deg);
            box-shadow:
                0 16px 32px rgba(15, 118, 110, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .card-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
            flex: 1;
            justify-content: center;
        }

        .card-title {
            font-size: 1.05rem;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.2;
            max-height: 2.4em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            text-align: center;
            width: 100%;
            letter-spacing: -0.025em;
            transition: color 0.3s ease;
        }

        .card-domain {
            position: absolute;
            /* sit on the card edge for a ribbon-like appearance */
            top: 0px;
            right: 0px;
            padding: 5px 10px;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            border: 1px solid rgba(15, 118, 110, 0.12);
            transition: all 0.22s cubic-bezier(0.2, 0.9, 0.2, 1);
            /* make the right top corner rounded */
            border-radius: 0 20px 0 12px;
            z-index: 15;
            /* reduced shadow and removed heavy inset for crisper look */
            box-shadow: 0 6px 12px rgba(2, 6, 23, 0.08);
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10px 100%, 0 calc(100% - 10px));
            /* remove heavy blur/backdrop for crisper text */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            min-width: 60px;
            text-align: center;
            max-width: 96px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-shadow: none;
            background-clip: padding-box;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
        }

        .card-domain::before {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-top: 6px solid currentColor;
            opacity: 0.7;
            filter: brightness(0.7);
        }

        .card-domain::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 50%, transparent 100%);
            pointer-events: none;
            clip-path: inherit;
        }

        .api-card:hover .card-domain {
            /* make the right top corner of card domain stays inside the card when hovered */
            border-color: rgba(15, 118, 110, 0.2);
            box-shadow: 0 8px 16px rgba(2, 6, 23, 0.12);
            filter: brightness(1.03) saturate(1.03);
            backdrop-filter: blur(4px);
            transform: translateY(-1px);
        }

        .card-row {
            display: flex;
            justify-content: center;
            gap: 24px;
            width: 100%;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .api-card:hover .card-title {
            color: #0f766e;
            transform: translateY(-1px);
        }

        /* HTTP Method indicators */
        .method-indicators {
            position: absolute;
            bottom: 16px;
            left: 16px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: calc(100% - 32px);
        }

        .method-badge {
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            border: 1px solid;
            backdrop-filter: blur(4px);
            transition: transform 0.2s ease;
        }

        .method-badge:hover {
            transform: scale(1.1);
        }

        .method-badge.get {
            background: rgba(34, 197, 94, 0.9);
            color: white;
            border-color: #16a34a;
        }

        .method-badge.post {
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border-color: #2563eb;
        }

        .method-badge.put {
            background: rgba(245, 158, 11, 0.9);
            color: white;
            border-color: #d97706;
        }

        .method-badge.patch {
            background: rgba(168, 85, 247, 0.9);
            color: white;
            border-color: #7c3aed;
        }

        .method-badge.delete {
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-color: #dc2626;
        }

        /* Method indicators for hexagons */
        .hexagon-method-indicators {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%) rotate(-30deg);
            display: flex;
            gap: 2px;
            z-index: 20;
        }

        .hexagon-method-badge {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .hexagon-method-badge.get {
            background: #22c55e;
        }

        .hexagon-method-badge.post {
            background: #3b82f6;
        }

        .hexagon-method-badge.put {
            background: #f59e0b;
        }

        .hexagon-method-badge.patch {
            background: #a855f7;
        }

        .hexagon-method-badge.delete {
            background: #ef4444;
        }







        /* View container management */
        .hexagon-container.view-hexagon .hexagon-grid {
            display: flex;
        }

        .hexagon-container.view-card .hexagon-grid {
            display: none;
        }

        /* Responsive design for views - 6 cards per row on wide screens */
        @media (max-width: 1600px) {
            .api-card {
                width: 175px;
                height: 175px;
                padding: 20px 16px;
            }

            .card-icon {
                width: 64px;
                height: 64px;
                font-size: 2rem;
            }

            .card-title {
                font-size: 1rem;
            }

            .card-domain {
                font-size: 0.6rem;
                padding: 5px 10px 5px 8px;
            }

            .card-grid {
                padding: 0 20px;
                gap: 16px;
            }
        }

        @media (max-width: 1400px) {
            .api-card {
                width: 165px;
                height: 165px;
                padding: 18px 14px;
            }

            .card-icon {
                width: 60px;
                height: 60px;
                font-size: 1.9rem;
            }

            .card-title {
                font-size: 0.95rem;
            }

            .card-grid {
                gap: 14px;
                padding: 0 16px;
            }
        }

        @media (max-width: 1200px) {

            /* Still 6 cards per row but smaller on medium screens */
            .api-card {
                width: 155px;
                height: 155px;
                padding: 16px 12px;
            }

            .card-icon {
                width: 58px;
                height: 58px;
                font-size: 1.8rem;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-grid {
                gap: 12px;
                padding: 0 16px;
            }
        }

        @media (max-width: 1000px) {

            /* Show 4 cards per row on medium screens */
            .api-card {
                width: calc(25% - 14px);
                min-width: 160px;
                height: 160px;
            }
        }

        @media (max-width: 800px) {

            /* Show 3 cards per row on smaller screens */
            .api-card {
                width: calc(33.33% - 16px);
                min-width: 150px;
                height: 150px;
            }

            .card-icon {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }

            .card-grid {
                padding: 0 16px;
                gap: 14px;
            }
        }

        @media (max-width: 600px) {

            /* Show 2 cards per row on mobile */
            .api-card {
                width: calc(50% - 12px);
                min-width: 140px;
                height: 140px;
                padding: 16px 12px;
            }

            .card-icon {
                width: 56px;
                height: 56px;
                font-size: 1.6rem;
            }

            .card-title {
                font-size: 0.85rem;
            }

            .card-domain {
                font-size: 0.55rem;
                padding: 4px 8px 4px 6px;
            }

            .card-grid {
                gap: 12px;
            }

            .card-view {
                padding: 20px 12px;
            }
        }

        @media (max-width: 450px) {

            /* Single column on very small screens */
            .api-card {
                width: calc(100% - 16px);
                max-width: 320px;
                height: 140px;
                margin: 10px 0;
                padding: 18px;
            }

            .card-icon {
                width: 56px;
                height: 56px;
                font-size: 1.5rem;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-domain {
                font-size: 0.6rem;
                padding: 4px 8px 4px 6px;
                top: 14px;
                right: 14px;
            }

            .card-view {
                padding: 16px 8px;
            }

            .card-grid {
                padding: 0 8px;
                gap: 12px;
            }

            .endpointFilterBar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-slate-50 to-slate-200 min-h-screen">
    <header>
        <div class="header-content">
            <div class="brand"><img src="./logo.png" alt="saham Logo" class="hover-lift" />
                <div class="brand-text">API's DOCUMENTATION</div>
            </div>
            <div class="controls">
                <!-- Hexagonal Home Button (shown only in documentation view) -->
                <button id="hexagonalHomeButton" class="hexagonal-home-btn" style="display: none;"
                    title="Back to API Grid">
                    <i class="fas fa-th"></i>
                    <span>Home</span>
                </button>



                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" id="apiSearch" placeholder="Search APIs..." class="focus-ring hover-lift" />
                    <i class="fas fa-times clear-search-icon" id="clearSearch" style="display: none;"></i>
                    <div id="autocomplete-list" style="display: none;"></div>
                </div>
                <div class="dropdown-container">
                    <i class="fas fa-server dropdown-icon"></i>
                    <div id="customDropdown" class="dropdown-button focus-ring hover-lift" tabindex="0">
                        <span id="dropdownText">Select an API...</span>
                    </div>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                    <div id="dropdownList" class="dropdown-list">
                        <!-- Options will be populated here -->
                    </div>
                    <select id="apiDropdown" style="display: none;">
                        <option value="">Select an API...</option>
                    </select>
                </div>
                <!-- View Switcher -->
                <div class="view-switcher" id="viewSwitcher">
                    <button class="view-btn active" data-view="hexagon" title="Hexagon Grid View">
                        <svg fill="#ffffff" height="200px" width="200px" version="1.1" id="Capa_1"
                            xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                            viewBox="-5.2 -5.2 50.43 50.43" xml:space="preserve" stroke="#ffffff"
                            stroke-width="0.40029000000000003">
                            <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                            <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"
                                stroke="#6c6c6c" stroke-width="1.20087">
                                <g>
                                    <g id="b123_geometrical_shape">
                                        <path
                                            d="M34.408,10.246L23.48,10.367l-5.359,9.527l5.572,9.402l10.928-0.123l5.359-9.525L34.408,10.246z M33.661,27.551 l-9.043,0.104l-4.61-7.781l4.434-7.883l9.043-0.102l4.609,7.779L33.661,27.551z">
                                        </path>
                                        <path
                                            d="M16.549,18.932l5.357-9.527L16.334,0L5.406,0.125L0.049,9.65l5.57,9.402L16.549,18.932z M6.365,1.746l9.047-0.102 l4.607,7.781l-4.432,7.883l-9.044,0.104L1.936,9.629L6.365,1.746z">
                                        </path>
                                        <path
                                            d="M5.644,21.098l-5.358,9.525l5.57,9.406l10.93-0.123l5.357-9.527l-5.571-9.406L5.644,21.098z M15.823,38.283l-9.044,0.104 L2.17,30.602l4.433-7.881l9.046-0.105l4.607,7.783L15.823,38.283z">
                                        </path>
                                    </g>
                                    <g id="Capa_1_81_"> </g>
                                </g>
                            </g>
                            <g id="SVGRepo_iconCarrier">
                                <g>
                                    <g id="b123_geometrical_shape">
                                        <path
                                            d="M34.408,10.246L23.48,10.367l-5.359,9.527l5.572,9.402l10.928-0.123l5.359-9.525L34.408,10.246z M33.661,27.551 l-9.043,0.104l-4.61-7.781l4.434-7.883l9.043-0.102l4.609,7.779L33.661,27.551z">
                                        </path>
                                        <path
                                            d="M16.549,18.932l5.357-9.527L16.334,0L5.406,0.125L0.049,9.65l5.57,9.402L16.549,18.932z M6.365,1.746l9.047-0.102 l4.607,7.781l-4.432,7.883l-9.044,0.104L1.936,9.629L6.365,1.746z">
                                        </path>
                                        <path
                                            d="M5.644,21.098l-5.358,9.525l5.57,9.406l10.93-0.123l5.357-9.527l-5.571-9.406L5.644,21.098z M15.823,38.283l-9.044,0.104 L2.17,30.602l4.433-7.881l9.046-0.105l4.607,7.783L15.823,38.283z">
                                        </path>
                                    </g>
                                    <g id="Capa_1_81_"> </g>
                                </g>
                            </g>
                        </svg>
                    </button>
                    <button class="view-btn" data-view="card" title="Card View">
                        <svg fill="#ffffff" width="171px" height="171px" viewBox="0 0 256.00 256.00" id="Flat"
                            xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="5.632">
                            <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                            <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"
                                stroke="#020202" stroke-width="12.288">
                                <path
                                    d="M112,44H48a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,112,44Zm-4,64H52V52h56ZM208,44H144a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,208,44Zm-4,64H148V52h56Zm-92,32H48a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,112,140Zm-4,64H52V148h56Zm100-64H144a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,208,140Zm-4,64H148V148h56Z">
                                </path>
                            </g>
                            <g id="SVGRepo_iconCarrier">
                                <path
                                    d="M112,44H48a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,112,44Zm-4,64H52V52h56ZM208,44H144a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,208,44Zm-4,64H148V52h56Zm-92,32H48a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,112,140Zm-4,64H52V148h56Zm100-64H144a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,208,140Zm-4,64H148V148h56Z">
                                </path>
                            </g>
                        </svg> </button>
                </div>
            </div>
        </div>
    </header>



    <!-- Hexagonal Landing Page -->
    <div id="hexagonContainer" class="hexagon-container">
        <div class="landing-title">
            <h1>API Documentation Portal</h1>
            <p>Explore API-CORE Documentation, learn fast, integrate easily!</p>


            <!-- api-counter removed: counter is now shown only inside the floating filter panel -->

            <!-- Domain Filter Bar -->
            <div id="filterBar" class="filter-bar" style="display: none;">
                <div id="domainFilters">
                </div>
            </div>
        </div>
        <div id="hexagonGrid" class="hexagon-grid">
            <!-- Hexagons will be dynamically generated here -->
        </div>

        <!-- Card View Container -->
        <div id="cardView" class="card-view">
            <div id="cardGrid" class="card-grid">
                <!-- Cards will be dynamically generated here -->
            </div>
        </div>


    </div>

    <!-- Draggable filter notch and floating panel (landing page domain filters) -->
    <div id="filterNotch" aria-label="Open domain filters" title="Open domain filters">
        <i class="fas fa-filter"></i>
    </div>

    <div id="filterPanel" class="filter-panel" role="dialog" aria-hidden="true">
        <div class="panel-header">
            <div class="panel-title">Domains</div>
            <button id="panelClose" class="panel-close" aria-label="Close filters">&times;</button>
        </div>
        <div id="panelDomainFilters" class="panel-filters"></div>
        <div class="panel-footer" style="display:flex; justify-content:center;">
            <button id="panelClearFilters" class="clear-filters-btn" style="
                    padding: 8px 16px;
                    background: rgba(187, 10, 10, 0.404);
                    border-radius: 12px;
                    color: rgb(0, 0, 0);
                    font-size: 0.9rem;
                    font-weight: 600;
                    text-align: center;
                    margin: 8px 12px;
                    border: 1px solid rgba(153, 153, 153, 0.12);
                    transition: background 0.2s, box-shadow 0.2s, opacity 0.9s, color 0.2s;
                "
                onmouseover="this.style.background='#dc2626';this.style.boxShadow='0 8px 20px rgba(239,68,68,0.4)';this.style.opacity='1';this.style.color='white';"
                onmouseout="this.style.background='rgba(187, 10, 10, 0.06)';this.style.boxShadow='none';this.style.opacity='1';this.style.color='rgb(0, 0, 0)';">
                Clear
            </button>
        </div>
    </div>



    <!-- Swagger UI Container -->
    <div id="swagger-ui">
    </div>

    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js" charset="UTF-8"></script>
    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-standalone-preset.js" charset="UTF-8"></script>
    <script>    let allApis = [];
        let ui;
        let isLandingPage = true;
        let activeDomains = new Set(); // Track active domain filters
        let apisByDomain = {}; // Cache APIs grouped by domain

        // Endpoint filtering (for Swagger UI view)
        let activeEndpointMethods = new Set(); // Track active HTTP method filters in endpoint view
        let currentApiEndpoints = []; // Store current API endpoints for filtering
        let endpointFilteringEnabled = false; // Track if endpoint filtering is active

        // View management
        let currentView = 'hexagon'; // Track current view: 'hexagon', 'card'

        // View switching functions
        function switchView(viewType) {
            if (currentView === viewType) return;

            console.log(`🔄 Switching from ${currentView} to ${viewType} view`);

            // Check if all required elements exist
            const requiredElements = ['hexagonGrid', 'cardView'];
            const missingElements = requiredElements.filter(id => !document.getElementById(id));

            if (missingElements.length > 0) {
                console.error(`❌ Missing view elements: ${missingElements.join(', ')}`);
                return;
            }

            // Update view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-view') === viewType) {
                    btn.classList.add('active');
                }
            });

            // Update container classes
            const container = document.getElementById('hexagonContainer');
            container.className = `hexagon-container view-${viewType}`;

            // Remove active class from all views
            document.getElementById('hexagonGrid').style.display = 'none';
            document.getElementById('cardView').classList.remove('active');

            // Show selected view
            currentView = viewType;

            switch (viewType) {
                case 'hexagon':
                    document.getElementById('hexagonGrid').style.display = 'flex';
                    renderHexagonView(); // This will consider both search and domain filters
                    console.log("✅ Hexagon view activated");
                    break;
                case 'card':
                    document.getElementById('cardView').classList.add('active');
                    renderCardView(); // This will consider both search and domain filters
                    console.log("✅ Card view activated");
                    break;
                default:
                    console.error(`❌ Unknown view type: ${viewType}`);
                    return;
            }

            // Save view preference
            localStorage.setItem('preferred-view', viewType);
            console.log(`💾 Saved view preference: ${viewType}`);
        }

        function getVisibleApis() {
            console.log("🔍 Getting visible APIs...");
            console.log(`🔍 Total APIs: ${allApis.length}`);

            const filtered = allApis.filter(api => {
                const hexElement = document.querySelector(`[data-api-name="${api.name}"]`);
                if (!hexElement) {
                    console.log(`⚠️ No hex element found for API: ${api.name}`);
                    return true; // Include if no hex element found (fallback)
                }

                const isVisible = !hexElement.classList.contains('filtered-out') && !hexElement.classList.contains('domain-filtered-out');
                return isVisible;
            });

            console.log(`🔍 Visible APIs: ${filtered.length}`);
            return filtered;
        }

        function renderCardView() {
            console.log("🗃️ Rendering card view...");

            // Get current search query
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Get filtered APIs based on domain and search filters
            const visibleApis = allApis.filter(api => {
                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // Check domain filter
                const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                // Check search filter
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                return matchesDomain && matchesSearch;
            });

            console.log(`🗃️ Card view: Found ${visibleApis.length} visible APIs (search: "${searchQuery}", domains: ${Array.from(activeDomains).join(', ')})`);

            renderCardViewWithTransitions(visibleApis);

            // Update counter for card view
            updateViewCounter(visibleApis.length, searchQuery);
        }

        function renderCardViewWithTransitions(apis) {
            const cardGrid = document.getElementById('cardGrid');

            // Clear existing cards immediately (no fade out)
            cardGrid.innerHTML = '';

            // Render new cards immediately
            renderNewCards(apis);
        }

        function renderNewCards(apis) {
            const cardGrid = document.getElementById('cardGrid');

            // Clear existing content
            cardGrid.innerHTML = '';

            // Get current search query for highlighting
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Create all cards at once using document fragment
            const fragment = document.createDocumentFragment();

            // Show 6 items per row with optimized card size for better layout
            const itemsPerRow = 6;
            const rows = Math.ceil(apis.length / itemsPerRow);

            for (let rowIndex = 0; rowIndex < rows; rowIndex++) {
                const row = document.createElement('div');
                row.className = 'card-row';

                const startIndex = rowIndex * itemsPerRow;
                const endIndex = Math.min(startIndex + itemsPerRow, apis.length);

                for (let i = startIndex; i < endIndex; i++) {
                    const api = apis[i];
                    const serviceName = extractServiceName(api.name);
                    const domain = extractDomain(api.name);
                    const icon = getApiIcon(api.name);
                    const domainColors = getDomainColor(domain);

                    // Apply highlighting if there's a search query
                    const displayName = searchQuery ? highlightMatch(serviceName, searchQuery) : serviceName;

                    const card = document.createElement('div');
                    card.className = 'api-card';

                    // Start with hidden state for animation
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.8) translateY(20px)';
                    card.style.transition = 'opacity 0.4s ease, transform 0.4s ease';

                    card.innerHTML = `
                <div class="card-content">
                    <div class="card-icon">
                        <i class="${icon}"></i>
                    </div>
                    <div class="card-info">
                        <h3 class="card-title">${displayName}</h3>
                    </div>
                </div>
                <div class="card-domain" style="background: ${domainColors.bg}; color: ${domainColors.text};">${domain}</div>
            `;
                    card.addEventListener('click', () => navigateToApi(api.url));
                    row.appendChild(card);
                }

                fragment.appendChild(row);
            }

            // Add all cards at once
            cardGrid.appendChild(fragment);

            // Trigger fade-in animation with staggered timing
            requestAnimationFrame(() => {
                const newCards = cardGrid.querySelectorAll('.api-card');
                newCards.forEach((card, index) => {
                    card.style.transitionDelay = `${index * 0.1}s`;
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1) translateY(0)';
                    }, 100); // Small delay to ensure DOM is ready
                });
            });

            console.log("✅ Card view rendered successfully with transitions");
        }



        // Cache functions for domain filters
        function saveDomainFilters() {
            const filtersArray = Array.from(activeDomains);
            localStorage.setItem('activedomainFilters', JSON.stringify(filtersArray));
            console.log("💾 Saved domain filters:", filtersArray);
        }

        function loadDomainFilters() {
            try {
                const savedFilters = localStorage.getItem('activedomainFilters');
                if (savedFilters) {
                    const filtersArray = JSON.parse(savedFilters);
                    activeDomains = new Set(filtersArray);
                    console.log("📂 Loaded domain filters:", filtersArray);
                    return filtersArray.length > 0;
                }
            } catch (error) {
                console.warn("⚠️ Failed to load domain filters:", error);
            }
            return false;
        }

        function clearDomainFiltersCache() {
            localStorage.removeItem('activedomainFilters');
            console.log("🗑️ Cleared domain filters cache");
        }

        // Global function to reset all filters (can be called from console)
        function resetAllFilters() {
            clearAllDomainFilters();
            clearAllMethodFilters();

            // Clear search input
            const searchInput = document.getElementById('apiSearch');
            if (searchInput) {
                searchInput.value = '';
            }

            // Update view with no filters
            switch (currentView) {
                case 'hexagon':
                    renderHexagonView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                default:
                    applyFiltersDirectly();
                    break;
            }

            console.log("🔄 All filters have been reset");
        }

        // Shared highlighting function
        function highlightMatch(text, query) {
            if (!query || !text) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<span style="background: #fef3c7; color: #92400e; padding: 1px 2px; border-radius: 3px;">$1</span>');
        }

        // Unified function to update API counter with the requested phrasing
        function updateViewCounter(visibleCount, searchQuery = '') {
            const hasSearch = Boolean(searchQuery && searchQuery.trim());
            const hasDomainFilter = activeDomains.size > 0;
            const total = Array.isArray(allApis) ? allApis.length : 0;

            // If there are no filters/search, show the total with arrow
            if (!hasSearch && !hasDomainFilter) {
                updateApiCounter(total, `APIs Available`, total);
                return;
            }

            // Build domain list text when domains are active
            let domainText = '';
            if (hasDomainFilter) {
                const domains = Array.from(activeDomains);
                if (domains.length === 1) domainText = ` in ${domains[0]}`;
                else domainText = ` in ${domains.join(', ')}`;
            }

            // When filters are active, show "<visible> of <total> APIs Available" and append domains if any
            const message = `of ${total} APIs Available${domainText}`;
            updateApiCounter(visibleCount, message, visibleCount);
        }

        // Dedicated function to update API counter reliably
        // countDisplayed: number to show in the big count; message: the explanatory string
        function updateApiCounter(countDisplayed, message = null, countForScreenReader = null) {
            // Only update the floating panel counter. The header counter has been removed.
            try {
                if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                    const notchMode = window.filterNotchInstance.mode || 'domain';
                    let panelFooter = window.filterNotchInstance.panel.querySelector('.panel-footer');
                    if (!panelFooter) panelFooter = window.filterNotchInstance.panel;

                    const existingPanelCounter = panelFooter.querySelector('#api-filter-counter');

                    if (notchMode === 'domain') {
                        let panelCounter = existingPanelCounter;
                        if (!panelCounter) {
                            panelCounter = document.createElement('div');
                            panelCounter.id = 'api-filter-counter';
                            panelCounter.style.cssText = 'padding: 8px 16px; background: rgba(15, 118, 110, 0.06); border-radius: 12px; color: rgb(15, 118, 110); font-size: 0.9rem; font-weight: 600; text-align: center; margin: 8px 12px; border: 1px solid rgba(15, 118, 110, 0.12);';
                            panelFooter.appendChild(panelCounter);
                        }

                        const compactMsg = (message || 'APIs Available');
                        panelCounter.innerHTML = `<span class="count">${countDisplayed}</span> ${compactMsg}`;
                    } else {
                        if (existingPanelCounter) existingPanelCounter.remove();
                    }
                }
            } catch (e) {
                // ignore if panel not available yet
            }
        }

        // Endpoint filtering functions (for Swagger UI view)
        function initializeEndpointFiltering(spec) {
            console.log("🔄 Initializing endpoint filtering for current API...");

            if (!spec || !spec.paths) {
                console.warn("No paths found in API spec");
                return;
            }

            // Extract all endpoints with their methods
            currentApiEndpoints = [];
            const methodCounts = {};

            Object.keys(spec.paths).forEach(path => {
                const pathObject = spec.paths[path];
                Object.keys(pathObject).forEach(method => {
                    const httpMethod = method.toLowerCase();
                    if (['get', 'post', 'put', 'patch', 'delete', 'options', 'head'].includes(httpMethod)) {
                        const endpoint = {
                            path: path,
                            method: httpMethod,
                            summary: pathObject[method].summary || '',
                            description: pathObject[method].description || '',
                            operationId: pathObject[method].operationId || '',
                            tags: pathObject[method].tags || []
                        };

                        currentApiEndpoints.push(endpoint);
                        methodCounts[httpMethod] = (methodCounts[httpMethod] || 0) + 1;
                    }
                });
            });

            console.log(`Found ${currentApiEndpoints.length} endpoints`, methodCounts);

            // Generate method filter chips for current API
            generateEndpointMethodFilters(methodCounts);

            // If the reusable FilterNotch exists, configure it for endpoint mode so the same UI can be reused.
            // IMPORTANT: only switch the floating panel into endpoint mode when the Swagger UI (API docs)
            // view is actually visible. Switching the panel to endpoint mode while on the landing page
            // would wipe out the domain chips and make the panel show only methods (the "get" tag).
            try {
                const swaggerElEarly = document.getElementById('swagger-ui');
                const swaggerVisibleEarly = swaggerElEarly && swaggerElEarly.classList.contains('show');
                if (window.filterNotchInstance && swaggerVisibleEarly) {
                    window.filterNotchInstance.setMode('endpoint', {
                        getItems: () => Object.keys(methodCounts).sort().map(m => ({ key: m, count: methodCounts[m] })),
                        onToggle: (methodKey) => {
                            const normalized = methodKey.toLowerCase();
                            toggleEndpointMethodFilter(normalized);
                        },
                        onSearch: (query) => {
                            const searchInput = document.getElementById('endpointSearch');
                            if (searchInput) searchInput.value = query;
                            const panelInput = window.filterNotchInstance && window.filterNotchInstance.panel
                                ? window.filterNotchInstance.panel.querySelector('.panel-search-row input')
                                : null;
                            if (panelInput) panelInput.value = query;
                            applyEndpointFilters();
                        },
                        clearCallback: () => {
                            activeEndpointMethods.clear();
                            updateEndpointMethodFilterUI();
                            const si = document.getElementById('endpointSearch');
                            if (si) si.value = '';
                            const panelInput = window.filterNotchInstance && window.filterNotchInstance.panel
                                ? window.filterNotchInstance.panel.querySelector('.panel-search-row input')
                                : null;
                            if (panelInput) panelInput.value = '';
                            applyEndpointFilters();
                        }
                    });
                }
            } catch (e) {
                console.warn('Could not configure FilterNotch for endpoint mode', e);
            }

            // Show the endpoint filter bar, but only when the Swagger UI (API documentation) view is visible.
            // This prevents the filter bar from appearing on the landing / APIs grid.
            // Enable endpoint filtering when the Swagger UI is visible; rely on the floating panel for UI
            const swaggerEl = document.getElementById('swagger-ui');
            const swaggerVisible = swaggerEl && swaggerEl.classList.contains('show');
            if (swaggerVisible) {
                endpointFilteringEnabled = true;
                console.log("✅ Endpoint filtering enabled (API doc view)");
                setSwaggerUiPaddingForFilterBar(true);
            } else {
                endpointFilteringEnabled = false;
                console.log("ℹ️ Endpoint filtering prepared but hidden (not in API doc view)");
                setSwaggerUiPaddingForFilterBar(false);
            }

            // Set up endpoint search and filtering
            setupEndpointSearch();

            // Ensure endpoint filters are applied immediately so the endpoint counter is created/visible
            try {
                // apply filters now and again shortly after to catch timing when Swagger UI renders opblocks
                if (endpointFilteringEnabled) applyEndpointFilters();
                setTimeout(() => { try { if (endpointFilteringEnabled) applyEndpointFilters(); } catch (e) { } }, 300);
            } catch (e) { /* ignore */ }
        }

        function generateEndpointMethodFilters(methodCounts) {

            const filterContainer = document.getElementById('endpointMethodFilters');
            // If the legacy endpointMethodFilters element is missing (we now use the floating panel), skip DOM updates here.
            if (!filterContainer) return;

            // Clear any existing content and event listeners
            filterContainer.innerHTML = '';

            Object.keys(methodCounts).sort().forEach(method => {
                const count = methodCounts[method];
                const chip = document.createElement('div');
                chip.className = 'endpoint-method-chip';
                chip.dataset.method = method;
                chip.innerHTML = `${method.toUpperCase()} <span class="chip-count">${count}</span>`;

                // Use a more robust click handler
                chip.onclick = function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    const clickedMethod = this.dataset.method;
                    toggleEndpointMethodFilter(clickedMethod);
                };

                chip.title = `Show only ${method.toUpperCase()} endpoints (${count} found)`;
                filterContainer.appendChild(chip);
            });


        }

        function setupEndpointSearch() {
            // Support either the legacy top bar input (#endpointSearch) or the floating panel's search input
            let searchInput = document.getElementById('endpointSearch');
            let clearSearchButton = document.getElementById('clearEndpointSearch');

            // If top-level elements are missing, try to find panel input inserted by FilterNotch
            if (!searchInput && window.filterNotchInstance && window.filterNotchInstance.panel) {
                const panelInput = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
                if (panelInput) {
                    searchInput = panelInput;
                    // Do NOT create a clear (x) button for the panel search input — keep UI minimal.
                    // Leaving clearSearchButton null prevents the code below from showing an 'x'.
                }
            }

            if (!searchInput) return; // nothing to wire up

            searchInput.addEventListener('input', function () {
                const query = this.value.trim();
                applyEndpointFilters();

                // Show/hide clear button
                if (clearSearchButton) clearSearchButton.style.display = query ? 'block' : 'none';
            });

            if (clearSearchButton) {
                clearSearchButton.addEventListener('click', function () {
                    searchInput.value = '';
                    clearSearchButton.style.display = 'none';
                    applyEndpointFilters();
                    searchInput.focus();
                });
            }
        }

        /*
         * Ensure Swagger UI content is padded when the endpoint filter bar is visible
         * so the sticky filter does not overlap the API operation list.
         */
        function setSwaggerUiPaddingForFilterBar(show) {
            const swagger = document.getElementById('swagger-ui');
            if (!swagger) return;

            // Prefer legacy filter bar if present, otherwise fall back to floating panel height
            const filterBar = document.getElementById('endpointFilterBar');
            let pad = 0;

            if (filterBar) {
                if (show && filterBar.style.display !== 'none') {
                    pad = filterBar.offsetHeight + 12;
                }
            } else if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                const panel = window.filterNotchInstance.panel;
                // If panel is currently open/visible and we want to show padding, use its height.
                if (show && panel.style.display !== 'none') {
                    pad = panel.offsetHeight + 12;
                }
            }

            if (pad) swagger.style.paddingTop = pad + 'px';
            else swagger.style.paddingTop = '';
        }

        // Enhanced API icons mapping based on actual API categories
        const apiIcons = {
            // Cloud services
            'cloud': 'fas fa-cloud',
            'audit': 'fas fa-clipboard-check',

            // Contract and banking
            'contract': 'fas fa-file-contract',
            'bancassurance': 'fas fa-shield-alt',

            // Data services
            'data': 'fas fa-database',
            'customer-data': 'fas fa-users-cog',

            // Distribution services
            'distribution': 'fas fa-network-wired',
            'appointment': 'fas fa-calendar-check',
            'card-holder': 'fas fa-id-card',
            'ldg': 'fas fa-sitemap',
            'operationaltask': 'fas fa-tasks',

            // Guarantee services
            'garantie': 'fas fa-shield-alt',
            'caution': 'fas fa-handshake',

            // Product services
            'product': 'fas fa-cube',
            'loan': 'fas fa-hand-holding-usd',
            'offer': 'fas fa-gift',
            'term-deposit': 'fas fa-piggy-bank',
            'titre': 'fas fa-certificate',

            // Risk and compliance
            'riskandcompliance': 'fas fa-exclamation-triangle',
            'compliance': 'fas fa-balance-scale',

            // Sales services
            'sales': 'fas fa-chart-line',
            'advice': 'fas fa-lightbulb',
            'after-sale': 'fas fa-tools',
            'feasibility': 'fas fa-search-dollar',
            'opportunity': 'fas fa-bullseye',
            'sale': 'fas fa-shopping-cart',

            // SOGE services
            'soge': 'fas fa-building',

            // Support services
            'support': 'fas fa-headset',
            'av-scanner': 'fas fa-virus-slash',
            'biochecker': 'fas fa-fingerprint',
            'chatbot': 'fas fa-robot',
            'document': 'fas fa-file-alt',
            'exchangerate': 'fas fa-exchange-alt',
            'featuretoggles': 'fas fa-toggle-on',
            'geoloc': 'fas fa-map-marker-alt',
            'ladrad': 'fas fa-cogs',
            'notification': 'fas fa-bell',
            'otp': 'fas fa-key',
            'parcours': 'fas fa-route',
            'pilotage': 'fas fa-tachometer-alt',
            'reclamation': 'fas fa-exclamation-circle',
            'rh': 'fas fa-user-tie',
            'task-management': 'fas fa-clipboard-list',

            // Template services
            'template': 'fas fa-file-code',
            'template-contract': 'fas fa-file-signature',

            // Third party services
            'tiers': 'fas fa-external-link-alt',
            'account': 'fas fa-user-circle',
            'customer': 'fas fa-users',
            'favorite': 'fas fa-heart',
            'prospect': 'fas fa-user-plus',

            // Transaction services
            'transaction': 'fas fa-credit-card',
            'cagnotte': 'fas fa-coins',
            'card': 'fas fa-credit-card',
            'cheque-book': 'fas fa-book',
            'instant-transfer': 'fas fa-bolt',
            'lcn': 'fas fa-file-invoice-dollar',
            'operation-core': 'fas fa-calculator',
            'payment': 'fas fa-money-check-alt',
            'provision': 'fas fa-wallet',
            'token-core': 'fas fa-shield-alt',
            'trade': 'fas fa-chart-area',
            'transfer': 'fas fa-paper-plane',
            'wallet-core': 'fas fa-wallet',

        };

        function getApiIcon(apiName) {
            const name = apiName.toLowerCase();

            // Check for exact matches first
            for (const [key, icon] of Object.entries(apiIcons)) {
                if (name.includes(key)) {
                    return icon;
                }
            }

            // Category-based fallbacks
            if (name.includes('transaction') || name.includes('payment') || name.includes('money')) {
                return 'fas fa-credit-card';
            }
            if (name.includes('support') || name.includes('help')) {
                return 'fas fa-headset';
            }
            if (name.includes('data') || name.includes('customer')) {
                return 'fas fa-database';
            }
            if (name.includes('product') || name.includes('offer')) {
                return 'fas fa-cube';
            }
            if (name.includes('sales') || name.includes('opportunity')) {
                return 'fas fa-chart-line';
            }
            if (name.includes('distribution') || name.includes('network')) {
                return 'fas fa-network-wired';
            }

            return 'fas fa-cog'; // default icon
        }

        // Extract domain from API name (e.g., "cloud/audit/v1" -> "cloud")
        function extractDomain(apiName) {
            const parts = apiName.split('/');
            return parts[0] || 'other';
        }

        // Extract API service name (e.g., "cloud/audit/v1" -> "audit" or "contract/bancassurance-service/v1/api-docs" -> "bancassurance-service")
        function extractServiceName(apiName) {
            const parts = apiName.split('/');
            // Remove "api-docs" if it's the last part
            const filteredApiDocs = parts.filter(part => part !== 'api-docs');
            // Remove version (v1, v2, etc.) from the end
            const filtered = filteredApiDocs.filter(part => !part.match(/^v\d+$/));
            // Return the last non-version, non-api-docs part (the service name)
            return filtered[filtered.length - 1] || apiName;
        }

        // Get domain color scheme
        function getDomainColor(domain) {
            const colors = {
                'cloud': { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.4)', text: 'rgb(59, 130, 246)' },
                'contract': { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.4)', text: 'rgb(168, 85, 247)' },
                'data': { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.4)', text: 'rgb(34, 197, 94)' },
                'distribution': { bg: 'rgba(249, 115, 22, 0.3)', border: 'rgba(249, 115, 22, 0.4)', text: 'rgb(249, 115, 22)' },
                'garantie': { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.4)', text: 'rgb(236, 72, 153)' },
                'product': { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.4)', text: 'rgb(14, 165, 233)' },
                'riskandcompliance': { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.4)', text: 'rgb(239, 68, 68)' },
                'sales': { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.4)', text: 'rgb(245, 158, 11)' },
                'soge': { bg: 'rgba(99, 102, 241, 0.3)', border: 'rgba(99, 102, 241, 0.4)', text: 'rgb(99, 102, 241)' },
                'support': { bg: 'rgba(20, 184, 166, 0.3)', border: 'rgba(20, 184, 166, 0.4)', text: 'rgb(20, 184, 166)' },
                'template': { bg: 'rgba(139, 92, 246, 0.3)', border: 'rgba(139, 92, 246, 0.4)', text: 'rgb(139, 92, 246)' },
                'tiers': { bg: 'rgba(244, 63, 94, 0.3)', border: 'rgba(244, 63, 94, 0.4)', text: 'rgb(244, 63, 94)' },
                'transaction': { bg: 'rgba(16, 185, 129, 0.3)', border: 'rgba(16, 185, 129, 0.4)', text: 'rgb(16, 185, 129)' },
            };
            return colors[domain.toLowerCase()] || { bg: 'rgba(100, 116, 139, 0.3)', border: 'rgba(100, 116, 139, 0.4)', text: 'rgb(100, 116, 139)' };
        }

        // Group APIs by domain
        function groupApisByDomain(apis) {
            const grouped = {};
            apis.forEach(api => {
                const domain = extractDomain(api.name);
                if (!grouped[domain]) {
                    grouped[domain] = [];
                }
                grouped[domain].push(api);
            });
            return grouped;
        }

        // Generate domain filter chips
        function generateDomainFilters(apis) {
            apisByDomain = groupApisByDomain(apis);
            const domains = Object.keys(apisByDomain).sort();
            // Populate panel-based domain filters (draggable notch opens this panel)
            const filterBar = document.getElementById('filterBar');
            const panelContainer = document.getElementById('panelDomainFilters');
            const notch = document.getElementById('filterNotch');

            // Keep the top/legacy filter bar hidden — we only use the floating panel
            if (filterBar) filterBar.style.display = 'none';

            if (!panelContainer) return;

            if (domains.length <= 1) {
                // No need to show a notch if there's only one domain
                panelContainer.innerHTML = '';
                if (notch) notch.style.display = 'none';
                return;
            }

            // Ensure notch is visible
            if (notch) notch.style.display = 'inline-flex';

            panelContainer.innerHTML = '';

            domains.forEach(domain => {
                const count = apisByDomain[domain].length;
                const chip = document.createElement('div');
                chip.className = 'domain-chip';
                chip.dataset.domain = domain;
                // Build inner content with real elements (avoid raw HTML for better styling/behavior)
                const labelSpan = document.createElement('span');
                labelSpan.style.display = 'inline-block';
                labelSpan.style.verticalAlign = 'middle';
                labelSpan.textContent = domain;

                const countSpan = document.createElement('span');
                countSpan.className = 'chip-count';
                countSpan.style.minWidth = '20px';
                countSpan.style.height = '20px';
                countSpan.style.padding = '0 7px';
                countSpan.style.lineHeight = '20px';
                countSpan.style.display = 'inline-flex';
                countSpan.style.alignItems = 'center';
                countSpan.style.justifyContent = 'center';
                countSpan.style.borderRadius = '50%';
                countSpan.style.background = '#fff';
                countSpan.style.color = '#0f766e';
                countSpan.style.fontSize = '0.75rem';
                countSpan.style.fontWeight = '800';
                countSpan.style.boxShadow = '0 2px 6px rgba(2,6,23,0.12)';
                countSpan.style.marginLeft = '8px';
                countSpan.style.border = '2px solid #0f766e';
                countSpan.textContent = count;

                chip.appendChild(labelSpan);
                chip.appendChild(countSpan);

                // Accessibility and keyboard support
                chip.setAttribute('role', 'button');
                chip.tabIndex = 0;
                chip.addEventListener('keydown', function (e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } });

                chip.addEventListener('click', function () {
                    toggleDomainFilter(domain);
                });

                // Double-click to clear all filters (power user feature)
                chip.addEventListener('dblclick', function (e) {
                    e.stopPropagation();
                    console.log("🚀 Double-click detected: Clearing all filters");
                    clearAllDomainFilters();
                });

                chip.title = `Click to filter by ${domain}. Double-click to clear all filters.`;

                // Reflect active state visually if this domain is currently selected
                try {
                    if (activeDomains && activeDomains.has && activeDomains.has(domain)) {
                        chip.classList.add('active');
                    }
                } catch (e) { /* ignore if activeDomains not ready */ }

                panelContainer.appendChild(chip);
            });
        }

        /*
         * FilterNotch component: encapsulates notch drag, open/close animations,
         * and a configurable panel that can act in different modes (domain or endpoint).
         */
        class FilterNotch {
            constructor({ notchSelector = '#filterNotch', panelSelector = '#filterPanel' } = {}) {
                this.notch = document.querySelector(notchSelector);
                this.panel = document.querySelector(panelSelector);
                if (!this.notch || !this.panel) return;

                this.mode = 'domain';
                this.config = {};
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                // restore saved position if any
                try {
                    const saved = localStorage.getItem('filterNotchPos');
                    if (saved) {
                        const pos = JSON.parse(saved);
                        this.notch.style.left = pos.left || '';
                        this.notch.style.top = pos.top || '';
                        this.notch.style.right = 'auto';
                    }
                } catch (e) { }

                // bind events
                this._bindDrag();
                this.notch.addEventListener('click', (e) => {
                    if (this.isDragging) return;
                    if (this.panel.style.display === 'flex' || this.panel.style.display === 'block') this.close(); else this.open();
                });

                // close button inside panel
                const panelClose = this.panel.querySelector('#panelClose');
                if (panelClose) panelClose.addEventListener('click', () => this.close());

                // clear button
                const panelClear = this.panel.querySelector('#panelClearFilters');
                if (panelClear) panelClear.addEventListener('click', () => {
                    if (this.config.clearCallback) this.config.clearCallback();
                });
            }

            _bindDrag() {
                const notch = this.notch;
                document.addEventListener('mousedown', (e) => {
                    if (e.target === notch || notch.contains(e.target)) {
                        this.isDragging = true;
                        this.dragOffsetX = e.clientX - notch.getBoundingClientRect().left;
                        this.dragOffsetY = e.clientY - notch.getBoundingClientRect().top;
                        notch.classList.add('dragging');
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    const left = Math.max(8, Math.min(window.innerWidth - notch.offsetWidth - 8, e.clientX - this.dragOffsetX));
                    const top = Math.max(48, Math.min(window.innerHeight - notch.offsetHeight - 8, e.clientY - this.dragOffsetY));
                    notch.style.left = left + 'px';
                    notch.style.top = top + 'px';
                    notch.style.right = 'auto';
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.notch.classList.remove('dragging');
                        try {
                            const rect = this.notch.getBoundingClientRect();
                            localStorage.setItem('filterNotchPos', JSON.stringify({ left: rect.left + 'px', top: rect.top + 'px' }));
                        } catch (e) { }
                    }
                });

                // touch support
                this.notch.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.isDragging = true;
                    this.dragOffsetX = touch.clientX - this.notch.getBoundingClientRect().left;
                    this.dragOffsetY = touch.clientY - this.notch.getBoundingClientRect().top;
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging) return;
                    const touch = e.touches[0];
                    const left = Math.max(8, Math.min(window.innerWidth - this.notch.offsetWidth - 8, touch.clientX - this.dragOffsetX));
                    const top = Math.max(48, Math.min(window.innerHeight - this.notch.offsetHeight - 8, touch.clientY - this.dragOffsetY));
                    this.notch.style.left = left + 'px';
                    this.notch.style.top = top + 'px';
                    this.notch.style.right = 'auto';
                }, { passive: false });

                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        try {
                            const rect = this.notch.getBoundingClientRect();
                            localStorage.setItem('filterNotchPos', JSON.stringify({ left: rect.left + 'px', top: rect.top + 'px' }));
                        } catch (e) { }
                    }
                });
            }

            setMode(mode, config = {}) {
                this.mode = mode;
                this.config = config;
                this._renderPanelContent();

                // Ensure only the relevant counter is present in the panel footer
                try {
                    let panelFooter = this.panel.querySelector('.panel-footer');
                    if (!panelFooter) panelFooter = this.panel;

                    if (this.mode === 'endpoint') {
                        // remove any lingering API counter
                        const apiCounter = panelFooter.querySelector('#api-filter-counter');
                        if (apiCounter) apiCounter.remove();
                    } else if (this.mode === 'domain') {
                        // remove any lingering endpoint counter
                        const epCounter = panelFooter.querySelector('#endpoint-counter');
                        if (epCounter) epCounter.remove();
                    }
                } catch (e) { /* ignore */ }

                // After rendering panel content, ensure the visual active state of chips matches activeDomains
                try {
                    if (typeof updateDomainFilterUI === 'function') updateDomainFilterUI();
                } catch (e) { /* ignore */ }
            }

            _renderPanelContent() {
                const container = this.panel.querySelector('#panelDomainFilters');
                if (!container) return;
                // Update panel title based on mode
                const titleEl = this.panel.querySelector('.panel-title');
                if (titleEl) titleEl.textContent = (this.mode === 'endpoint') ? 'Endpoints' : 'Domains';

                container.innerHTML = '';

                // If endpoint mode, show a search input at top
                if (this.mode === 'endpoint') {
                    // create search field inside panel
                    let searchRow = this.panel.querySelector('.panel-search-row');
                    if (!searchRow) {
                        searchRow = document.createElement('div');
                        searchRow.className = 'panel-search-row';
                        searchRow.style.display = 'flex';
                        searchRow.style.width = '100%';
                        searchRow.style.marginBottom = '8px';
                        const input = document.createElement('input');
                        input.type = 'search';
                        input.placeholder = 'Search endpoints...';
                        input.style.width = '100%';
                        input.style.padding = '8px 10px';
                        input.style.borderRadius = '8px';
                        input.style.border = '1px solid rgba(226,232,240,0.8)';
                        input.addEventListener('input', (e) => {
                            if (this.config.onSearch) this.config.onSearch(e.target.value);
                        });
                        searchRow.appendChild(input);
                        this.panel.insertBefore(searchRow, container);
                    }
                } else {
                    // remove any existing panel-search-row
                    const old = this.panel.querySelector('.panel-search-row');
                    if (old) old.remove();
                }

                // populate chips using getItems
                const items = (this.config.getItems && typeof this.config.getItems === 'function') ? this.config.getItems() : [];
                // items can be array of strings or objects { key, count }
                items.forEach(it => {
                    const key = typeof it === 'string' ? it : it.key;
                    const count = (typeof it === 'string') ? null : (Object.prototype.hasOwnProperty.call(it, 'count') ? it.count : null);

                    const chip = document.createElement('div');
                    chip.className = this.mode === 'endpoint' ? 'domain-chip endpoint-chip' : 'domain-chip';
                    // Keep a generic value attribute and a semantic one for domain mode
                    chip.dataset.value = key;
                    chip.setAttribute('role', 'button');
                    chip.tabIndex = 0;

                    if (this.mode === 'endpoint') {
                        // for endpoints: expose method in dataset.method (lowercase) and show uppercase label
                        chip.dataset.method = (typeof key === 'string') ? key.toLowerCase() : '';
                        const label = (typeof key === 'string') ? key.toUpperCase() : key;
                        const textNode = document.createTextNode(label);
                        chip.appendChild(textNode);
                        if (count !== null) {
                            const span = document.createElement('span');
                            span.className = 'chip-count';
                            span.textContent = count;
                            chip.appendChild(document.createTextNode(' '));
                            chip.appendChild(span);
                        }
                    } else {
                        // for domains: keep dataset.domain so other code can find it
                        chip.dataset.domain = key;
                        const textNode = document.createTextNode(key);
                        chip.appendChild(textNode);
                        if (count !== null) {
                            const span = document.createElement('span');
                            span.className = 'chip-count';
                            span.textContent = count;
                            // Ensure visible spacing
                            span.style.marginLeft = '8px';
                            chip.appendChild(span);
                        }
                    }

                    // Keyboard activation
                    chip.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            chip.click();
                        }
                    });

                    chip.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (this.config.onToggle) this.config.onToggle(key);
                    });

                    // Apply active state immediately if the domain/method is currently active
                    try {
                        if (this.mode === 'domain' && activeDomains && activeDomains.has && activeDomains.has(key)) {
                            chip.classList.add('active');
                        }
                        if (this.mode === 'endpoint' && activeEndpointMethods && activeEndpointMethods.has && activeEndpointMethods.has((key || '').toLowerCase())) {
                            chip.classList.add('active');
                        }
                    } catch (e) { /* ignore */ }

                    container.appendChild(chip);
                });
            }

            open() {
                const rect = this.notch.getBoundingClientRect();
                const panelW = Math.min(420, window.innerWidth - 40);
                const panelH = 260;
                let left = rect.left - panelW - 8;
                if (left < 8) left = rect.right + 8;
                if (left + panelW > window.innerWidth - 8) left = window.innerWidth - panelW - 8;
                let top = rect.top;
                if (top + panelH > window.innerHeight - 8) top = window.innerHeight - panelH - 8;

                this.panel.style.left = left + 'px';
                this.panel.style.top = top + 'px';

                const notchCenterX = rect.left + rect.width / 2;
                const notchCenterY = rect.top + rect.height / 2;
                const localX = Math.round(notchCenterX - left);
                const localY = Math.round(notchCenterY - top);

                this.panel.style.display = 'flex';
                this.panel.setAttribute('aria-hidden', 'false');
                this.panel.style.setProperty('--clip-x', localX + 'px');
                this.panel.style.setProperty('--clip-y', localY + 'px');
                this.panel.style.clipPath = `circle(0px at ${localX}px ${localY}px)`;
                this.panel.style.transform = 'scale(0.96)';
                this.panel.style.opacity = '0';
                // force reflow
                this.panel.offsetHeight;

                requestAnimationFrame(() => {
                    this.panel.classList.remove('closing');
                    this.panel.classList.add('open');
                    const diag = Math.hypot(panelW, panelH) * 1.25;
                    this.panel.style.clipPath = `circle(${diag}px at ${localX}px ${localY}px)`;
                    this.panel.style.transform = 'scale(1)';
                    this.panel.style.opacity = '1';
                });
            }

            close() {
                const rect = this.notch.getBoundingClientRect();
                const panelRect = this.panel.getBoundingClientRect();
                const localX = Math.round(rect.left + rect.width / 2 - panelRect.left);
                const localY = Math.round(rect.top + rect.height / 2 - panelRect.top);
                this.panel.style.setProperty('--clip-x', localX + 'px');
                this.panel.style.setProperty('--clip-y', localY + 'px');
                this.panel.classList.remove('open');
                this.panel.classList.add('closing');
                this.panel.style.clipPath = `circle(0px at ${localX}px ${localY}px)`;
                this.panel.style.transform = 'scale(0.96)';
                this.panel.style.opacity = '0';

                const onEndClose = (e) => {
                    if (e.propertyName === 'clip-path' || e.propertyName === 'opacity') {
                        this.panel.removeEventListener('transitionend', onEndClose);
                        this.panel.style.display = 'none';
                        this.panel.setAttribute('aria-hidden', 'true');
                        this.panel.classList.remove('closing');
                    }
                };
                this.panel.addEventListener('transitionend', onEndClose);
            }
        }

        // Instantiate the reusable notch component (if not already)
        function initFilterNotch() {
            if (window.filterNotchInstance) return;
            window.filterNotchInstance = new FilterNotch({ notchSelector: '#filterNotch', panelSelector: '#filterPanel' });

            // Default mode: domain filters
            if (window.filterNotchInstance) {
                window.filterNotchInstance.setMode('domain', {
                    // Return items with counts so the panel renders chip-count badges
                    getItems: () => Object.keys(apisByDomain || {}).sort().map(d => ({ key: d, count: (apisByDomain[d] || []).length })),
                    onToggle: (domain) => toggleDomainFilter(domain),
                    clearCallback: () => clearAllDomainFilters()
                });
            }
        }

        // Toggle domain filter
        function toggleDomainFilter(domain) {
            // Add micro-interaction feedback
            const chip = document.querySelector(`.domain-chip[data-domain="${domain}"], .domain-chip[data-value="${domain}"]`);
            if (chip) {
                chip.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    chip.style.transform = '';
                }, 100);
            }

            if (activeDomains.has(domain)) {
                activeDomains.delete(domain);
            } else {
                activeDomains.add(domain);
            }

            // Save filters to localStorage
            saveDomainFilters();

            updateDomainFilterUI();

            // Use RAF for smoother transitions
            requestAnimationFrame(() => {
                applyDomainFilter();
            });
        }

        // Clear all domain filters
        function clearAllDomainFilters() {
            activeDomains.clear();

            // Clear cache
            clearDomainFiltersCache();

            updateDomainFilterUI();

            // Use RAF for smoother transitions
            requestAnimationFrame(() => {
                applyAllFilters();
            });
        }

        // Endpoint method filtering functions
        function toggleEndpointMethodFilter(method) {
            // Add micro-interaction feedback
            const chip = document.querySelector(`.endpoint-method-chip[data-method="${method}"]`);
            if (chip) {
                chip.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    chip.style.transform = '';
                }, 100);
            }

            if (activeEndpointMethods.has(method)) {
                activeEndpointMethods.delete(method);
            } else {
                activeEndpointMethods.add(method);
            }

            updateEndpointMethodFilterUI();
            applyEndpointFilters();
        }



        function updateEndpointMethodFilterUI() {
            // Toggle active state for both legacy method chips and floating panel chips
            const chips = document.querySelectorAll('.endpoint-method-chip, .endpoint-chip');

            chips.forEach(chip => {
                const method = (chip.dataset.method || chip.dataset.value || '').toLowerCase();
                if (method && activeEndpointMethods.has(method)) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            });
        }

        // Apply all filters (domain + endpoint) - used by clear and other flows
        function applyAllFilters() {
            try {
                // Reapply domain filters (landing views)
                applyDomainFilter();

                // Reapply endpoint filters if API docs view is active
                if (endpointFilteringEnabled) {
                    applyEndpointFilters();
                }

                // Update counters explicitly
                try {
                    const visibleEndpointCount = document.querySelectorAll('.swagger-ui .opblock:not([style*="display: none"])').length;
                    updateEndpointCounter(visibleEndpointCount);
                } catch (e) { /* ignore if swagger not present */ }

                // Ensure API counter is up to date for landing views
                try {
                    if (allApis) updateApiCounter(Array.isArray(allApis) ? allApis.length : 0);
                } catch (e) { }
            } catch (err) {
                console.warn('applyAllFilters failed', err);
            }
        }

        function applyEndpointFilters() {
            if (!endpointFilteringEnabled) return;

            // Resolve search input (legacy or panel)
            let searchEl = document.getElementById('endpointSearch');
            if (!searchEl && window.filterNotchInstance && window.filterNotchInstance.panel) {
                searchEl = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
            }
            const searchQuery = (searchEl ? (searchEl.value || '') : '').toLowerCase().trim();

            // Get all Swagger UI operation elements
            const operations = document.querySelectorAll('.swagger-ui .opblock');

            operations.forEach(operation => {
                const methodElement = operation.querySelector('.opblock-summary-method');
                const pathElement = operation.querySelector('.opblock-summary-path');
                const summaryElement = operation.querySelector('.opblock-summary-description');

                if (!methodElement) return;

                const method = methodElement.textContent.toLowerCase().trim();
                const path = pathElement ? pathElement.textContent.toLowerCase() : '';
                const summary = summaryElement ? summaryElement.textContent.toLowerCase() : '';

                // Check method filter
                const matchesMethod = activeEndpointMethods.size === 0 || activeEndpointMethods.has(method);

                // Check search filter
                const matchesSearch = !searchQuery ||
                    path.includes(searchQuery) ||
                    summary.includes(searchQuery) ||
                    method.includes(searchQuery);

                // Show/hide operation
                const shouldShow = matchesMethod && matchesSearch;
                operation.style.display = shouldShow ? 'block' : 'none';

                // Add visual feedback for filtered state
                if (shouldShow) {
                    operation.style.opacity = '1';
                    operation.style.transform = 'scale(1)';
                } else {
                    operation.style.opacity = '0.3';
                    operation.style.transform = 'scale(0.95)';
                }
            });

            // Update results count
            const visibleCount = document.querySelectorAll('.swagger-ui .opblock[style*="display: block"], .swagger-ui .opblock:not([style*="display: none"])').length;
            updateEndpointCounter(visibleCount);
        }

        function updateEndpointCounter(visibleCount) {
            // Try to find or create a counter element in the Swagger UI
            let counter = document.getElementById('endpoint-counter');
            if (!counter) {
                counter = document.createElement('div');
                counter.id = 'endpoint-counter';
                counter.style.cssText = `
                    padding: 8px 16px;
                    background: rgba(15, 118, 110, 0.06);
                    border-radius: 12px;
                    color: #0f766e;
                    font-size: 0.9rem;
                    font-weight: 600;
                    text-align: center;
                    margin: 8px 12px;
                    border: 1px solid rgba(15, 118, 110, 0.12);
                `;
                // Insert inside the endpoint filter CONTENT so it collapses with the other elements
                // If legacy endpointFilterBar exists, insert there. Otherwise append to the floating panel footer.
                const filterBar = document.getElementById('endpointFilterBar');
                if (filterBar) {
                    const content = filterBar.querySelector('.endpoint-filter-content');
                    if (content) {
                        content.appendChild(counter);
                    } else {
                        const wrapper = filterBar.querySelector('.endpoint-filter-wrapper');
                        if (wrapper) wrapper.appendChild(counter);
                        else filterBar.appendChild(counter);
                    }
                } else if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                    // Insert into panel footer (so it appears with the panel)
                    const footer = window.filterNotchInstance.panel.querySelector('.panel-footer');
                    if (footer) footer.appendChild(counter);
                    else window.filterNotchInstance.panel.appendChild(counter);
                }
            }

            const totalCount = currentApiEndpoints.length;

            // If endpoint filtering isn't active or we're back on the landing page,
            // hide the endpoint counter to avoid showing endpoint messages on the home grid.
            if (!endpointFilteringEnabled || isLandingPage) {
                try { counter.style.display = 'none'; } catch (e) { }
                return;
            } else {
                try { counter.style.display = ''; } catch (e) { }
            }

            // Determine if any filters are active: method chips or search text (legacy or panel)
            let searchEl = document.getElementById('endpointSearch');
            if (!searchEl && window.filterNotchInstance && window.filterNotchInstance.panel) {
                searchEl = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
            }
            const hasSearch = Boolean(searchEl && searchEl.value && searchEl.value.trim());
            const hasMethodFilter = activeEndpointMethods.size > 0;
            const hasFilters = hasMethodFilter || hasSearch;

            // Build message per user request
            if (!hasFilters) {
                // No filters — show arrow + total
                counter.innerHTML = `<span style="margin-right:6px;"></span><span class="count">${totalCount}</span> Endpoints Available`;
                return;
            }

            // Filters active — show visible/total and method info if available (no arrow)
            if (hasMethodFilter) {
                const methods = Array.from(activeEndpointMethods).map(m => m.toUpperCase());
                if (methods.length === 1) {
                    counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints matches ${methods[0]}`;
                } else {
                    counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints match ${methods.join(', ')}`;
                }
            } else {
                counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints Available`;
            }
        }

        // Update domain filter UI
        function updateDomainFilterUI() {
            const chips = document.querySelectorAll('.domain-chip');

            chips.forEach(chip => {
                const domain = chip.dataset.domain || chip.dataset.value;
                if (domain && activeDomains.has(domain)) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            });
        }

        // Apply domain filter with search integration
        function applyDomainFilter() {
            const apiCounter = document.getElementById('apiCount');

            // Use RAF for smooth rendering with immediate, consistent behavior
            requestAnimationFrame(() => {
                // Always regenerate the current view with domain and search filters
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        // Fallback to direct hexagon filtering for compatibility
                        applyFiltersDirectly();
                        break;
                }
            });
        }

        // Direct filtering for domain and search (fallback)
        function applyFiltersDirectly() {
            const hexagons = document.querySelectorAll('.hexagon-item');
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';
            let visibleCount = 0;

            hexagons.forEach((hexagon, index) => {
                const api = allApis[index];
                if (!api) return;

                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // Check domain filter
                const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                // Check search filter
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                const shouldShow = matchesDomain && matchesSearch;

                if (shouldShow) {
                    // Show immediately with clean positioning - no memory of old positions
                    hexagon.style.display = 'block';
                    hexagon.style.visibility = 'visible';
                    hexagon.style.position = 'relative';
                    hexagon.style.transform = 'scale(1) translateY(0)'; // Reset any transforms
                    hexagon.style.opacity = '1';
                    hexagon.style.filter = 'none';

                    // Clean class management - no animation delays or position memory
                    hexagon.classList.remove('domain-filtered-out');
                    hexagon.classList.add('domain-filtered-in');

                    // No transition delays to prevent position memory
                    hexagon.style.transitionDelay = '0s';

                    visibleCount++;
                } else {
                    // Hide immediately and cleanly like card view
                    hexagon.classList.remove('domain-filtered-in');
                    hexagon.classList.add('domain-filtered-out');
                    hexagon.style.transitionDelay = '0s';

                    // Immediate hiding to prevent flickering
                    hexagon.style.display = 'none';
                    hexagon.style.visibility = 'hidden';
                    hexagon.style.opacity = '0';
                }
            });

            // Update counter
            updateViewCounter(visibleCount, searchQuery);
        }



        async function loadApis() {
            try {
                console.log("🔄 Fetching APIs...");

                // Show loading state in the floating panel (if available)
                try {
                    if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                        let panelFooter = window.filterNotchInstance.panel.querySelector('.panel-footer');
                        if (!panelFooter) panelFooter = window.filterNotchInstance.panel;
                        let panelCounter = panelFooter.querySelector('#api-filter-counter');
                        if (!panelCounter) {
                            panelCounter = document.createElement('div');
                            panelCounter.id = 'api-filter-counter';
                            panelCounter.style.cssText = 'padding: 8px 16px; background: rgba(15, 118, 110, 0.06); border-radius: 12px; color: rgb(15, 118, 110); font-size: 0.9rem; font-weight: 600; text-align: center; margin: 8px 12px; border: 1px solid rgba(15, 118, 110, 0.12);';
                            panelFooter.appendChild(panelCounter);
                        }
                        panelCounter.innerHTML = `<span class="count"><i class="fas fa-spinner fa-spin"></i></span> Loading APIs...`;
                    }
                } catch (e) { /* ignore */ }

                const res = await fetch("/api/swagger-config");

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }

                const data = await res.json();
                console.log("📡 Received data:", data);

                const urls = data.urls || [];
                console.log(`📊 Raw APIs count: ${urls.length}`);

                // Filter out null/invalid API entries
                const filteredUrls = urls.filter(api =>
                    api &&
                    api.name &&
                    api.url &&
                    !api.name.includes('null/null/null') &&
                    api.name !== 'null/null/null/api-docs'
                );

                console.log(`✅ Filtered APIs count: ${filteredUrls.length}`);
                allApis = filteredUrls;

                // Update API counter immediately
                updateApiCounter(filteredUrls.length);

                // Populate custom dropdown
                const dropdown = document.getElementById("apiDropdown");
                const customDropdown = document.getElementById("customDropdown");
                const dropdownList = document.getElementById("dropdownList");
                const dropdownText = document.getElementById("dropdownText");

                // Clear old content
                dropdown.innerHTML = '<option value="">Select an API...</option>';
                dropdownList.innerHTML = '';

                // Add APIs to both hidden select and custom dropdown
                filteredUrls.forEach((api, index) => {
                    // Hidden select option
                    const option = document.createElement("option");
                    option.value = api.url;
                    const serviceName = extractServiceName(api.name);
                    const domain = extractDomain(api.name);
                    option.text = `${serviceName} (${domain})`;
                    dropdown.appendChild(option);

                    // Custom dropdown item
                    const dropdownItem = document.createElement("div");
                    dropdownItem.className = "dropdown-item";
                    const domainColors = getDomainColor(domain);
                    dropdownItem.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; width: 100%; box-sizing: border-box;">
                    <span style="font-weight: 600; flex: 1; min-width: 0; word-break: break-word; line-height: 1.3;">${serviceName}</span>
                    <span class="domain-tag" style="font-size: 0.75rem; padding: 3px 10px; border-radius: 12px; background: ${domainColors.bg}; color: ${domainColors.text}; border: 1px solid ${domainColors.border}; font-weight: 600; flex-shrink: 0; white-space: nowrap;">
                        ${domain}
                    </span>
                </div>
            `;
                    dropdownItem.dataset.value = api.url;
                    dropdownItem.dataset.name = `${serviceName} (${domain})`;

                    // Click selects the API
                    dropdownItem.addEventListener('click', function () {
                        selectDropdownItem(this, api);
                    });

                    // Ripple feedback on mousedown
                    dropdownItem.addEventListener('mousedown', function (e) {
                        createRippleEffect(this, e);
                    });

                    dropdownList.appendChild(dropdownItem);
                });

                // Setup custom dropdown behavior
                setupCustomDropdown();

                // Original dropdown change handler (for compatibility)
                dropdown.addEventListener("change", e => {
                    if (e.target.value) {
                        navigateToApi(e.target.value);
                    }
                });

                // Add click animation for dropdown
                dropdown.addEventListener("mousedown", function (e) {
                    createRippleEffect(this, e);
                });

                dropdown.addEventListener("focus", function () {
                    // Add opening animation class
                    this.classList.add('dropdown-opening');
                    setTimeout(() => {
                        this.classList.remove('dropdown-opening');
                    }, 600);
                });

                // Generate hexagonal grid
                renderHexagonView();

                // Generate domain filters (populate panel) and init notch interactions
                generateDomainFilters(filteredUrls);
                try { initFilterNotch(); } catch (e) { /* ignore if not available */ }

                // Initialize other views with the loaded APIs
                if (currentView !== 'hexagon') {
                    switch (currentView) {
                        case 'card':
                            renderCardView();
                            break;
                    }
                }

                // Restore cached domain filters
                const hasRestoredFilters = loadDomainFilters();
                if (hasRestoredFilters) {
                    console.log("🔄 Restoring domain filter UI and applying filters...");
                    updateDomainFilterUI();
                    // Apply filters after a small delay to ensure DOM is ready
                    setTimeout(() => {
                        applyDomainFilter();
                    }, 100);
                } else {
                    // No filters restored, make sure counter shows all APIs
                    setTimeout(() => {
                        updateApiCounter(filteredUrls.length);
                    }, 200);
                }

                setupAutocomplete();
                setupNavigation();

                // Initialize view switcher with loaded APIs
                initializeViewSwitcher();

                // Restore previous state if exists (after page refresh)
                restoreSessionState();

            } catch (err) {
                console.error("❌ Failed to load API list:", err);

                // Show error state in UI
                updateApiCounter("Error", "Failed to load APIs");
                // Also try direct update with error styling
                setTimeout(() => {
                    const apiCountText = document.getElementById('apiCountText');
                    if (apiCountText) {
                        apiCountText.innerHTML = `<span class="count" style="color: #ef4444;">Error</span> Failed to load APIs`;
                    }
                }, 100);

                // Show error message to user
                const hexagonGrid = document.getElementById('hexagonGrid');
                if (hexagonGrid) {
                    hexagonGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #ef4444;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 16px;"></i>
                    <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 8px;">Failed to Load APIs</div>
                    <div style="font-size: 1rem; opacity: 0.8;">${err.message}</div>
                    <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        <i class="fas fa-redo" style="margin-right: 8px;"></i>Retry
                    </button>
                </div>
            `;
                }
            }
        }

        // Restore session state after page refresh
        function restoreSessionState() {
            const savedViewState = sessionStorage.getItem('viewState');
            const savedApiUrl = sessionStorage.getItem('currentApiUrl');

            if (savedViewState === 'api-documentation' && savedApiUrl) {
                // Find the API in the loaded list to get full details
                const savedApi = allApis.find(api => api.url === savedApiUrl);

                if (savedApi) {
                    // Set initial history state for API documentation
                    if (!history.state) {
                        history.replaceState(
                            { view: 'api-documentation', apiUrl: savedApiUrl, apiName: savedApi.name },
                            `${savedApi.name} - API Documentation`,
                            `#/api/${encodeURIComponent(savedApi.name)}`
                        );
                    }

                    // Restore the API documentation view
                    setTimeout(() => {
                        // Update dropdown selection
                        const dropdown = document.getElementById("apiDropdown");
                        const dropdownText = document.getElementById("dropdownText");
                        const dropdownItems = document.querySelectorAll('.dropdown-item');

                        dropdown.value = savedApiUrl;

                        // Update custom dropdown
                        dropdownItems.forEach(item => {
                            item.classList.remove('selected');
                            if (item.dataset.value === savedApiUrl) {
                                const serviceName = extractServiceName(savedApi.name);
                                const domain = extractDomain(savedApi.name);
                                dropdownText.textContent = `${serviceName} (${domain})`;
                                item.classList.add('selected');
                            }
                        });

                        // Load API documentation without updating history
                        loadApiDocumentation(savedApiUrl, false);
                    }, 100);
                } else {
                    // API not found, clear invalid state
                    sessionStorage.removeItem('currentApiUrl');
                    sessionStorage.removeItem('viewState');
                }
            } else {
                // Set initial history state for home page
                if (!history.state) {
                    history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                }
            }
        }

        function renderHexagonView() {
            console.log("🔷 Rendering hexagon view...");

            // Get current search query
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Get filtered APIs based on domain and search filters
            const visibleApis = allApis.filter(api => {
                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // Check domain filter
                const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                // Check search filter
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                return matchesDomain && matchesSearch;
            });

            console.log(`🔷 Hexagon view: Found ${visibleApis.length} visible APIs (search: "${searchQuery}", domains: ${Array.from(activeDomains).join(', ')})`);

            // Regenerate the grid with filtered APIs
            generateHexagonGrid(visibleApis);

            // Update counter
            updateViewCounter(visibleApis.length, searchQuery);
        }

        function generateHexagonGrid(apis) {
            const grid = document.getElementById('hexagonGrid');
            grid.innerHTML = '';

            // Calculate items per row based on screen width
            const screenWidth = window.innerWidth;
            let itemsPerRow;

            if (screenWidth >= 1600) {
                itemsPerRow = 6;
            } else if (screenWidth >= 1200) {
                itemsPerRow = 5;
            } else if (screenWidth >= 900) {
                itemsPerRow = 4;
            } else if (screenWidth >= 600) {
                itemsPerRow = 3;
            } else {
                itemsPerRow = 2;
            }

            const rows = Math.ceil(apis.length / itemsPerRow);

            for (let rowIndex = 0; rowIndex < rows; rowIndex++) {
                const row = document.createElement('div');
                row.className = 'hexagon-row';

                const startIndex = rowIndex * itemsPerRow;
                const endIndex = Math.min(startIndex + itemsPerRow, apis.length);

                for (let i = startIndex; i < endIndex; i++) {
                    const api = apis[i];
                    const hexagon = createHexagon(api, i);
                    row.appendChild(hexagon);
                }

                grid.appendChild(row);
            }
        }

        function createHexagon(api, index) {
            const hexagonItem = document.createElement('div');
            hexagonItem.className = 'hexagon-item';
            hexagonItem.style.animationDelay = `${(index + 1) * 0.1}s`;
            hexagonItem.setAttribute('data-api-name', api.name);

            const icon = getApiIcon(api.name);

            // Extract domain and service name
            const domain = extractDomain(api.name);
            const serviceName = extractServiceName(api.name);
            const domainColors = getDomainColor(domain);

            hexagonItem.innerHTML = `
        <div class="hexagon-shape">
            <div class="hexagon-content">
                <div class="hexagon-icon">
                    <i class="${icon}"></i>
                </div>
                <div class="hexagon-title">${serviceName}</div>
            </div>
        </div>
        <div class="domain-badge" style="background: ${domainColors.bg}; color: ${domainColors.text};">
            ${domain}
        </div>
    `;

            hexagonItem.addEventListener('click', () => {
                selectHexagon(hexagonItem, api);
            });

            return hexagonItem;
        }



        function selectHexagon(hexagonElement, api) {
            // Add active state to clicked hexagon
            document.querySelectorAll('.hexagon-item').forEach(item => {
                item.classList.remove('active');
            });
            hexagonElement.classList.add('active');

            // Add loading state
            const iconElement = hexagonElement.querySelector('.hexagon-icon i');
            const originalIcon = iconElement.className;
            iconElement.className = 'fas fa-spinner fa-spin';

            // Wait for animation, then navigate
            setTimeout(() => {
                navigateToApi(api.url);
                updateDropdownSelection(api.url);

                // Restore original icon
                setTimeout(() => {
                    iconElement.className = originalIcon;
                }, 500);
            }, 300);
        }

        function updateDropdownSelection(url) {
            const dropdown = document.getElementById("apiDropdown");
            const dropdownText = document.getElementById("dropdownText");
            const dropdownItems = document.querySelectorAll('.dropdown-item');

            dropdown.value = url;

            // Find and update custom dropdown
            dropdownItems.forEach(item => {
                item.classList.remove('selected');
                if (item.dataset.value === url) {
                    dropdownText.textContent = item.dataset.name;
                    item.classList.add('selected');
                }
            });
        }

        function showLandingPage() {
            isLandingPage = true;

            // Clear saved state when returning to landing page
            sessionStorage.removeItem('currentApiUrl');
            sessionStorage.removeItem('currentApiName');
            sessionStorage.removeItem('viewState');

            document.getElementById('hexagonContainer').style.display = 'flex';
            document.getElementById('swagger-ui').classList.remove('show');
            document.getElementById('hexagonalHomeButton').style.display = 'none';
            document.getElementById('apiDropdown').value = '';

            // Ensure endpoint filtering is disabled when returning to landing page
            endpointFilteringEnabled = false;
            setSwaggerUiPaddingForFilterBar(false);

            // Hide/remove endpoint counter when on landing page to avoid message overlap
            try {
                const epCounter = document.getElementById('endpoint-counter');
                if (epCounter) {
                    epCounter.remove();
                }
            } catch (e) { /* ignore */ }

            // If the FilterNotch is present, restore it to domain mode so the panel shows domain chips on the home page
            try {
                if (window.filterNotchInstance) {
                    window.filterNotchInstance.setMode('domain', {
                        getItems: () => Object.keys(apisByDomain || {}).sort().map(d => ({ key: d, count: (apisByDomain[d] || []).length })),
                        onToggle: (domain) => toggleDomainFilter(domain),
                        clearCallback: () => clearAllDomainFilters()
                    });
                    // Close the panel to avoid showing endpoint UI while on landing
                    try { window.filterNotchInstance.close(); } catch (e) { }
                }
            } catch (err) {
                console.warn('Could not reset FilterNotch to domain mode', err);
            }

            // Clear any active endpoint method filters when leaving API docs
            if (activeEndpointMethods && activeEndpointMethods.size > 0) {
                activeEndpointMethods.clear();
                updateEndpointMethodFilterUI();
            }

            // Show view switcher when returning to landing page
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'flex';
            }

            // Reset custom dropdown
            const dropdownText = document.getElementById("dropdownText");
            if (dropdownText) {
                dropdownText.textContent = "Select an API...";
            }
            document.querySelectorAll('.dropdown-item').forEach(item => {
                item.classList.remove('selected');
            });
            if (typeof closeCustomDropdown === 'function') {
                closeCustomDropdown();
            }

            // Clear search input and reset filtering
            const searchInput = document.getElementById('apiSearch');
            if (searchInput) {
                searchInput.value = '';
            }

            // Clear any active hexagons but maintain domain filtering state
            document.querySelectorAll('.hexagon-item').forEach(item => {
                item.classList.remove('active');
            });

            // Reapply domain filters if they were active
            if (activeDomains.size > 0 || searchInput.value.trim()) {
                // Apply both domain and search filters
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        applyDomainFilter();
                        break;
                }
            } else {
                // Reset filtering consistently for all views
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        // Direct reset for hexagon elements
                        document.querySelectorAll('.hexagon-item').forEach(item => {
                            item.classList.remove('domain-filtered-out');
                            item.classList.add('domain-filtered-in');
                            item.style.display = 'block';
                            item.style.visibility = 'visible';
                            item.style.opacity = '1';
                            item.style.transform = 'scale(1) translateY(0)';
                            item.style.filter = 'none';
                            item.style.position = 'relative';
                            item.style.transitionDelay = '0s';
                        });
                        break;
                }

                // Reset API counter only if no filters are active
                if (allApis) {
                    updateApiCounter(allApis.length);
                }
            }

            // Hide no results message
            hideNoResultsMessage();
        }

        function showSwaggerUI() {
            isLandingPage = false;
            document.getElementById('hexagonContainer').style.display = 'none';
            document.getElementById('swagger-ui').classList.add('show');
            document.getElementById('hexagonalHomeButton').style.display = 'flex';

            // Enable endpoint filtering UI via floating FilterNotch when viewing API docs
            endpointFilteringEnabled = true;
            setSwaggerUiPaddingForFilterBar(true);

            // Try to initialize endpoint filtering if not already done
            setTimeout(() => {
                if (!endpointFilteringEnabled && typeof ui !== 'undefined') {
                    console.log("🔄 Attempting to initialize endpoint filtering from showSwaggerUI...");
                    try {
                        const spec = ui.getState().getIn(['spec', 'json']);
                        if (spec && spec.toJS) {
                            const specJson = spec.toJS();
                            initializeEndpointFiltering(specJson);
                        }
                    } catch (error) {
                        console.log("⚠️ Could not initialize from showSwaggerUI:", error);
                    }
                }
            }, 1500);

            // Hide view switcher when viewing API documentation
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'none';
            }
        }

        function setupNavigation() {
            // Setup hexagonal home button
            const hexagonalHomeButton = document.getElementById('hexagonalHomeButton');
            if (hexagonalHomeButton) {
                hexagonalHomeButton.addEventListener('click', () => {
                    // Push to history to enable browser back functionality
                    history.pushState({ view: 'home' }, 'API Documentation Portal', '/');
                    showLandingPage();
                });
            }

            // Handle browser back/forward navigation
            window.addEventListener('popstate', (event) => {
                if (event.state) {
                    if (event.state.view === 'home') {
                        showLandingPage();
                    } else if (event.state.view === 'api-documentation' && event.state.apiUrl) {
                        loadApiDocumentation(event.state.apiUrl, false); // false to not push to history again
                    }
                } else {
                    // Default state - show landing page
                    showLandingPage();
                }
            });
        }

        function navigateToApi(url) {
            if (!url) return;

            // Save current state to sessionStorage for restoration after page refresh
            const currentApi = allApis.find(api => api.url === url);
            if (currentApi) {
                sessionStorage.setItem('currentApiUrl', url);
                sessionStorage.setItem('currentApiName', currentApi.name);
                sessionStorage.setItem('viewState', 'api-documentation');

                // Push to browser history to enable back/forward navigation
                history.pushState(
                    { view: 'api-documentation', apiUrl: url, apiName: currentApi.name },
                    `${currentApi.name} - API Documentation`,
                    `#/api/${encodeURIComponent(currentApi.name)}`
                );
            }

            // Load the API documentation
            loadApiDocumentation(url, true);
        }

        function loadApiDocumentation(url, updateHistory = true) {
            if (!url) return;

            // Show Swagger UI and hide landing page
            showSwaggerUI();

            // Update Swagger UI with the selected API
            if (typeof ui !== 'undefined') {
                ui.specActions.updateUrl(url);
                ui.specActions.download(url);

                // Initialize endpoint filtering for the new API spec
                // Try multiple times with increasing delays to catch when spec loads
                let attempts = 0;
                const maxAttempts = 10;

                const tryInitializeFiltering = () => {
                    attempts++;
                    try {
                        const spec = ui.getState().getIn(['spec', 'json']);
                        if (spec && spec.toJS) {
                            const specJson = spec.toJS();
                            console.log(`🎯 Spec loaded on attempt ${attempts}, initializing filtering...`);
                            initializeEndpointFiltering(specJson);
                            return true;
                        }
                    } catch (error) {
                        console.log(`Attempt ${attempts}: Could not access spec:`, error);
                    }

                    if (attempts < maxAttempts) {
                        setTimeout(tryInitializeFiltering, attempts * 500);
                    } else {
                        console.warn("⚠️ Could not initialize endpoint filtering after all attempts");
                    }
                    return false;
                };

                tryInitializeFiltering();
            }

            // Update history if needed (for direct navigation, not browser back/forward)
            if (updateHistory) {
                const currentApi = allApis.find(api => api.url === url);
                if (currentApi) {
                    history.replaceState(
                        { view: 'api-documentation', apiUrl: url, apiName: currentApi.name },
                        `${currentApi.name} - API Documentation`,
                        `#/api/${encodeURIComponent(currentApi.name)}`
                    );
                }
            }
        }

        function setupCustomDropdown() {
            const customDropdown = document.getElementById("customDropdown");
            const dropdownList = document.getElementById("dropdownList");
            const dropdownText = document.getElementById("dropdownText");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            // Toggle dropdown on click
            customDropdown.addEventListener("click", function (e) {
                e.stopPropagation();
                toggleCustomDropdown();
            });

            // Close dropdown when clicking outside
            document.addEventListener("click", function (e) {
                if (!customDropdown.contains(e.target) && !dropdownList.contains(e.target)) {
                    closeCustomDropdown();
                }
            });

            // Keyboard navigation
            customDropdown.addEventListener("keydown", function (e) {
                e.preventDefault();
                if (e.key === "Enter" || e.key === " ") {
                    toggleCustomDropdown();
                } else if (e.key === "ArrowDown") {
                    openCustomDropdown();
                    focusNextItem(-1);
                } else if (e.key === "ArrowUp") {
                    openCustomDropdown();
                    focusNextItem(1);
                } else if (e.key === "Escape") {
                    closeCustomDropdown();
                }
            });

            // Add keyboard navigation to dropdown items
            dropdownList.addEventListener("keydown", function (e) {
                const items = Array.from(dropdownList.querySelectorAll('.dropdown-item'));
                const currentIndex = items.findIndex(item => item.classList.contains('focused'));

                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    focusNextItem(currentIndex);
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    focusPrevItem(currentIndex);
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (currentIndex >= 0) {
                        items[currentIndex].click();
                    }
                } else if (e.key === "Escape") {
                    closeCustomDropdown();
                    customDropdown.focus();
                }
            });
        }

        function toggleCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");

            if (dropdownList.classList.contains("show")) {
                closeCustomDropdown();
            } else {
                openCustomDropdown();
            }
        }

        function openCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            dropdownList.classList.add("show");
            customDropdown.classList.add("active");
            dropdownArrow.style.transform = "translateY(-50%) rotate(180deg)";
        }

        function closeCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            dropdownList.classList.remove("show");
            customDropdown.classList.remove("active");
            dropdownArrow.style.transform = "translateY(-50%) rotate(0deg)";

            // Clear focus from items
            dropdownList.querySelectorAll('.dropdown-item').forEach(item => {
                item.classList.remove('focused');
            });
        }

        function focusNextItem(currentIndex) {
            const items = Array.from(document.getElementById("dropdownList").querySelectorAll('.dropdown-item'));
            const nextIndex = currentIndex + 1;

            items.forEach(item => item.classList.remove('focused'));

            if (nextIndex < items.length) {
                items[nextIndex].classList.add('focused');
                items[nextIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function focusPrevItem(currentIndex) {
            const items = Array.from(document.getElementById("dropdownList").querySelectorAll('.dropdown-item'));
            const prevIndex = currentIndex - 1;

            items.forEach(item => item.classList.remove('focused'));

            if (prevIndex >= 0) {
                items[prevIndex].classList.add('focused');
                items[prevIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectDropdownItem(item, api) {
            const dropdownText = document.getElementById("dropdownText");
            const dropdown = document.getElementById("apiDropdown");

            // Update display text
            dropdownText.textContent = item.dataset.name;

            // Update hidden select
            dropdown.value = api.url;

            // Clear previous selection and mark current as selected
            document.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');

            // Close dropdown
            closeCustomDropdown();

            // Add visual feedback
            const customDropdown = document.getElementById("customDropdown");
            customDropdown.style.borderColor = "#10b981";
            customDropdown.style.background = "linear-gradient(135deg, rgba(240, 253, 244, 1) 0%, rgba(220, 252, 231, 0.98) 100%)";

            setTimeout(() => {
                customDropdown.style.borderColor = "";
                customDropdown.style.background = "";
            }, 1000);

            // Navigate to API
            navigateToApi(api.url);
        }

        function setupAutocomplete() {
            const input = document.getElementById("apiSearch");
            const list = document.getElementById("autocomplete-list");
            const dropdown = document.getElementById("apiDropdown");
            let searchTimeout;
            let rafId;

            input.addEventListener("input", function () {
                clearTimeout(searchTimeout);
                if (rafId) cancelAnimationFrame(rafId);

                const query = this.value.toLowerCase().trim();

                // Instant visual feedback for filtering using RAF
                if (isLandingPage) {
                    rafId = requestAnimationFrame(() => {
                        performRealTimeFiltering(query);
                    });
                }

                // Autocomplete suggestions with minimal delay
                if (!query) {
                    hideAutocomplete();
                    return;
                }

                // Reduced delay for faster response
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 100);
            });

            // Clear search when input is cleared
            input.addEventListener("keyup", function (e) {
                if (e.key === "Escape" || this.value === "") {
                    clearSearch();
                }
                toggleClearButton();
            });

            // Handle clear search button
            const clearButton = document.getElementById('clearSearch');
            clearButton.addEventListener('click', function () {
                input.value = '';
                clearSearch();
                toggleClearButton();
                input.focus();
            });

            // Show/hide clear button based on input content
            function toggleClearButton() {
                const clearButton = document.getElementById('clearSearch');
                if (input.value.trim()) {
                    clearButton.style.display = 'block';
                } else {
                    clearButton.style.display = 'none';
                }
            }

            function performSearch(query) {
                // Clear existing items immediately
                list.innerHTML = "";

                // Use RAF for smoother rendering
                requestAnimationFrame(() => {
                    const matches = allApis.filter(api => {
                        const serviceName = extractServiceName(api.name);
                        const domain = extractDomain(api.name);
                        return serviceName.toLowerCase().includes(query) ||
                            api.name.toLowerCase().includes(query) ||
                            domain.toLowerCase().includes(query);
                    });

                    if (matches.length > 0) {
                        // Create a document fragment for better performance
                        const fragment = document.createDocumentFragment();

                        matches.slice(0, 8).forEach((api, index) => {
                            const item = document.createElement("div");
                            item.classList.add("autocomplete-item");
                            const serviceName = extractServiceName(api.name);
                            const domain = extractDomain(api.name);
                            const nameHighlighted = highlightMatch(serviceName, query);
                            const domainColors = getDomainColor(domain);
                            item.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 2px;">${nameHighlighted}</div>
                        <div style="font-size: 0.75rem; color: ${domainColors.text}; font-weight: 500;">
                            <i class="fas fa-tag" style="margin-right: 4px; font-size: 0.7rem;"></i>${domain}
                        </div>
                    `;
                            item.onclick = () => {
                                selectApi(api);
                            };
                            item.style.opacity = "0";
                            item.style.transform = "translateY(10px)";
                            item.style.transition = "opacity 0.2s ease, transform 0.2s ease";

                            fragment.appendChild(item);

                            // Stagger animations with RAF
                            requestAnimationFrame(() => {
                                setTimeout(() => {
                                    item.style.opacity = "1";
                                    item.style.transform = "translateY(0)";
                                }, index * 30);
                            });
                        });

                        list.appendChild(fragment);
                        showAutocomplete();
                    } else {
                        const noResults = document.createElement("div");
                        noResults.classList.add("autocomplete-item");
                        noResults.innerHTML = `      <div style="color: #64748b; text-align: center; font-style: italic;">        <i class="fas fa-search" style="margin-right: 8px;"></i>        No APIs found matching "${query}"      </div>    `;
                        noResults.style.cursor = "default";
                        list.appendChild(noResults);
                        showAutocomplete();
                    }
                });
            }

            function selectApi(api) {
                input.value = "";
                hideAutocomplete();
                dropdown.value = api.url;
                input.style.borderColor = "#10b981";
                setTimeout(() => {
                    input.style.borderColor = "";
                }, 1000);

                // Clear any search filtering
                clearSearch();

                // Highlight the corresponding hexagon if on landing page
                if (isLandingPage) {
                    const hexagons = document.querySelectorAll('.hexagon-item');
                    hexagons.forEach((hexagon, index) => {
                        hexagon.classList.remove('active');
                        if (allApis[index] && allApis[index].url === api.url) {
                            hexagon.classList.add('active');
                            setTimeout(() => {
                                navigateToApi(api.url);
                            }, 300);
                            return;
                        }
                    });
                } else {
                    navigateToApi(api.url);
                }
            }

            // Real-time filtering function that works across all views
            function performRealTimeFiltering(query) {
                const trimmedQuery = query.toLowerCase().trim();

                if (isLandingPage) {
                    // Apply filtering to current view
                    switch (currentView) {
                        case 'hexagon':
                            renderHexagonView(); // This will now consider all filters: search, domain, and method
                            break;
                        case 'card':
                            renderCardView(); // This will now consider all filters: search, domain, and method
                            break;
                        default:
                            // Fallback to direct hexagon filtering for compatibility
                            filterHexagonsDirectly(trimmedQuery);
                            break;
                    }

                    // Show/hide no results message
                    const visibleCount = getVisibleItemsCount();
                    showNoResultsMessage(visibleCount === 0 && (trimmedQuery || activeDomains.size > 0));
                }
            }

            // Helper function to count visible items in current view
            function getVisibleItemsCount() {
                switch (currentView) {
                    case 'hexagon':
                        return document.querySelectorAll('.hexagon-item:not(.domain-filtered-out)').length;
                    case 'card':
                        return document.querySelectorAll('.api-card').length;
                    default:
                        return allApis.length;
                }
            }

            // Real-time hexagon filtering function with consistent behavior
            function filterHexagonsDirectly(query) {
                const hexagons = document.querySelectorAll('.hexagon-item');
                let visibleCount = 0;

                // Use RAF for smooth rendering with immediate, consistent behavior
                requestAnimationFrame(() => {
                    hexagons.forEach((hexagon, index) => {
                        const api = allApis[index];
                        if (!api) return;

                        const serviceName = extractServiceName(api.name);
                        const domain = extractDomain(api.name);

                        // Check if matches search query
                        const matchesQuery = !query ||
                            serviceName.toLowerCase().includes(query) ||
                            api.name.toLowerCase().includes(query) ||
                            domain.toLowerCase().includes(query);

                        // Check if matches domain filter
                        const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                        // Show only if matches search and domain conditions
                        const shouldShow = matchesQuery && matchesDomain;

                        if (shouldShow) {
                            // Show immediately and cleanly - no position memory
                            hexagon.classList.remove('domain-filtered-out');
                            hexagon.classList.add('domain-filtered-in');
                            hexagon.style.display = 'block';
                            hexagon.style.visibility = 'visible';
                            hexagon.style.position = 'relative';
                            hexagon.style.opacity = '1';
                            hexagon.style.transform = 'scale(1) translateY(0)';
                            hexagon.style.filter = 'none';
                            visibleCount++;

                            // Highlight matching text in hexagon
                            if (query) {
                                highlightHexagonText(hexagon, query, serviceName);
                            } else {
                                clearHexagonHighlight(hexagon);
                            }
                        } else {
                            // Hide immediately and cleanly like card view
                            hexagon.classList.remove('domain-filtered-in');
                            hexagon.classList.add('domain-filtered-out');
                            hexagon.style.display = 'none';
                            hexagon.style.visibility = 'hidden';
                            hexagon.style.opacity = '0';

                            clearHexagonHighlight(hexagon);
                        }
                    });

                    // Update counter
                    updateViewCounter(visibleCount, query);

                    // Show "no results" message if needed
                    showNoResultsMessage(visibleCount === 0 && (query || activeDomains.size > 0));
                });
            }

            function highlightHexagonText(hexagon, query, displayName) {
                const titleElement = hexagon.querySelector('.hexagon-title');

                if (titleElement && !titleElement.dataset.originalText) {
                    titleElement.dataset.originalText = displayName || titleElement.textContent;
                }

                if (titleElement && titleElement.dataset.originalText) {
                    titleElement.innerHTML = highlightMatch(titleElement.dataset.originalText, query);
                }
            }

            function clearHexagonHighlight(hexagon) {
                const titleElement = hexagon.querySelector('.hexagon-title');

                if (titleElement && titleElement.dataset.originalText) {
                    titleElement.textContent = titleElement.dataset.originalText;
                }
            }

            function clearSearch() {
                if (isLandingPage) {
                    // Clear search for all views
                    switch (currentView) {
                        case 'hexagon':
                            renderHexagonView(); // This will render without search query
                            break;
                        case 'card':
                            renderCardView(); // This will render without search query  
                            break;
                        default:
                            // Fallback to direct filtering
                            clearSearchDirect();
                            break;
                    }

                    hideNoResultsMessage();
                }
            }

            function clearSearchDirect() {
                // Reapply domain filters without search query
                if (activeDomains.size > 0) {
                    applyDomainFilter();
                } else {
                    // Use RAF for smooth rendering with immediate, consistent behavior
                    requestAnimationFrame(() => {
                        const hexagons = document.querySelectorAll('.hexagon-item');

                        hexagons.forEach(hexagon => {
                            // Clean reset - no position memory or animation delays
                            hexagon.classList.remove('domain-filtered-out');
                            hexagon.classList.add('domain-filtered-in');
                            hexagon.style.display = 'block';
                            hexagon.style.visibility = 'visible';
                            hexagon.style.position = 'relative';
                            hexagon.style.opacity = '1';
                            hexagon.style.transform = 'scale(1) translateY(0)';
                            hexagon.style.filter = 'none';
                            hexagon.style.transitionDelay = '0s';
                            clearHexagonHighlight(hexagon);
                        });

                        // Reset counter immediately
                        if (allApis) {
                            updateApiCounter(allApis.length);
                        }
                    });
                }
            }

            function showNoResultsMessage(show) {
                let noResultsDiv = document.getElementById('no-results-message');

                if (show && !noResultsDiv) {
                    noResultsDiv = document.createElement('div');
                    noResultsDiv.id = 'no-results-message';
                    noResultsDiv.style.cssText = `
                text-align: center;
                padding: 40px 20px;
                color: #64748b;
                font-size: 1.1rem;
                font-weight: 500;
                animation: fadeInScale 0.3s ease;
            `;
                    noResultsDiv.innerHTML = `
                <i class="fas fa-search" style="font-size: 3rem; margin-bottom: 16px; opacity: 0.5;"></i>
                <div>No APIs match your search criteria</div>
                <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.7;">Try adjusting your search terms</div>
            `;
                    document.getElementById('hexagonGrid').appendChild(noResultsDiv);
                } else if (!show && noResultsDiv) {
                    noResultsDiv.remove();
                }
            }

            function hideNoResultsMessage() {
                const noResultsDiv = document.getElementById('no-results-message');
                if (noResultsDiv) {
                    noResultsDiv.remove();
                }
            }

            function showAutocomplete() {
                list.style.display = "block";
            }

            function hideAutocomplete() {
                list.style.display = "none";
            }

            input.addEventListener("keydown", function (e) {
                const items = list.querySelectorAll(".autocomplete-item");
                let selectedIndex = Array.from(items).findIndex(item => item.classList.contains("selected"));
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    if (selectedIndex < items.length - 1) {
                        if (selectedIndex >= 0) items[selectedIndex].classList.remove("selected");
                        items[selectedIndex + 1].classList.add("selected");
                    }
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    if (selectedIndex > 0) {
                        items[selectedIndex].classList.remove("selected");
                        items[selectedIndex - 1].classList.add("selected");
                    }
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex].onclick) {
                        items[selectedIndex].click();
                    }
                } else if (e.key === "Escape") {
                    hideAutocomplete();
                    input.blur();
                }
            });
            document.addEventListener("click", e => {
                if (!list.contains(e.target) && e.target !== input) {
                    hideAutocomplete();
                }
            });
        }

        // Global helper function for hiding no results message
        function hideNoResultsMessage() {
            const noResultsDiv = document.getElementById('no-results-message');
            if (noResultsDiv) {
                noResultsDiv.remove();
            }
        }

        // Ripple effect function
        function createRippleEffect(element, event) {
            const ripple = document.createElement('span');
            const rect = element.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event ? event.clientX - rect.left - size / 2 : rect.width / 2 - size / 2;
            const y = event ? event.clientY - rect.top - size / 2 : rect.height / 2 - size / 2;

            ripple.style.cssText = `
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple 0.6s linear;
        background-color: rgba(14, 165, 233, 0.3);
        left: ${x}px;
        top: ${y}px;
        width: ${size}px;
        height: ${size}px;
        pointer-events: none;
        z-index: 1;
    `;

            element.style.position = 'relative';
            element.style.overflow = 'hidden';
            element.appendChild(ripple);

            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        // Initialize view switcher functionality
        // Initialize view switcher functionality
        function initializeViewSwitcherEvents() {
            console.log("🎯 Setting up view switcher event listeners...");

            // Add click event listeners to view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const viewType = this.getAttribute('data-view');
                    switchView(viewType);
                });
            });

            console.log("✅ View switcher event listeners set up");
        }

        function initializeViewSwitcher() {
            console.log("🎯 Initializing view switcher with loaded APIs...");

            // Load saved view preference
            const savedView = localStorage.getItem('preferred-view') || 'hexagon';
            if (['hexagon', 'card'].includes(savedView)) {
                // Actually switch to the saved view
                currentView = 'hexagon'; // Reset to ensure switchView will work
                switchView(savedView);
            }

            console.log(`✅ View switcher initialized with ${currentView} view`);
        }

        window.onload = function () {
            console.log("🚀 Page loaded, initializing...");

            // Ensure essential DOM elements exist (header counters removed on purpose)
            const requiredElements = ['hexagonGrid', 'apiSearch'];
            const missingElements = requiredElements.filter(id => !document.getElementById(id));

            if (missingElements.length > 0) {
                console.error("❌ Missing required DOM elements:", missingElements);
                return;
            }

            console.log("✅ All required DOM elements found");

            // Initialize Swagger UI (hidden initially)
            ui = SwaggerUIBundle({
                dom_id: "#swagger-ui",
                url: "/api",
                deepLinking: true,
                presets: [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset],
                layout: "BaseLayout",
                docExpansion: "list",
                defaultModelsExpandDepth: 2,
                defaultModelExpandDepth: 2,
                showExtensions: true,
                showCommonExtensions: true,
                tryItOutEnabled: true,
                onComplete: function () {
                    // Swagger UI is ready
                    console.log("✅ Swagger UI initialized successfully");

                    // Try to initialize endpoint filtering
                    setTimeout(() => {
                        try {
                            const spec = ui.getState().getIn(['spec', 'json']);
                            if (spec && spec.toJS) {
                                const specJson = spec.toJS();
                                console.log("🔄 Spec found, initializing endpoint filtering...");
                                initializeEndpointFiltering(specJson);
                            } else {
                                console.log("⏳ Spec not yet loaded in onComplete");
                            }
                        } catch (error) {
                            console.log("⚠️ Could not access spec in onComplete:", error);
                        }
                    }, 500);
                }
            });

            // Initialize view switcher event listeners only
            initializeViewSwitcherEvents();

            // Load APIs and show landing page
            console.log("🔄 Starting API loading...");
            loadApis();

            // Show landing page only if no saved state exists
            const savedViewState = sessionStorage.getItem('viewState');
            if (savedViewState !== 'api-documentation') {
                showLandingPage();
            }
        };
        document.addEventListener('DOMContentLoaded', function () {
            console.log("📄 DOM Content Loaded");
            document.documentElement.style.scrollBehavior = 'smooth';

            // Ensure elements are ready - add a small delay if needed
            setTimeout(() => {
                const apiCountText = document.getElementById('apiCountText');
                if (apiCountText && !apiCountText.innerHTML.includes('Loading')) {
                    console.log("🔄 DOM ready, initializing API counter...");
                    updateApiCounter(0);
                }
            }, 100);

            // Add keyboard navigation
            document.addEventListener('keydown', function (e) {
                // ESC key to go back to landing page
                if (e.key === 'Escape' && !isLandingPage) {
                    showLandingPage();
                }

                // Enter key on hexagons
                if (e.key === 'Enter' && isLandingPage) {
                    const focusedElement = document.activeElement;
                    if (focusedElement.classList.contains('hexagon-item')) {
                        focusedElement.click();
                    }
                }
            });

            // Make hexagons focusable and add keyboard support
            setTimeout(() => {
                document.querySelectorAll('.hexagon-item').forEach((hexagon, index) => {
                    hexagon.setAttribute('tabindex', '0');
                    hexagon.setAttribute('role', 'button');
                    hexagon.setAttribute('aria-label', `Navigate to ${allApis[index]?.name || 'API'} documentation`);

                    hexagon.addEventListener('keydown', function (e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.click();
                        }
                    });
                });
            }, 1000);

            // Header morph on scroll
            let lastScrollTop = 0;
            let scrollThreshold = 80;
            let ticking = false;

            function handleHeaderScroll() {
                const header = document.querySelector('header');
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                // Calculate scroll progress
                const windowHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrollProgress = (scrollTop / windowHeight) * 100;

                // Update CSS variable for progress bar
                header.style.setProperty('--scroll-progress', `${scrollProgress}%`);

                if (scrollTop > scrollThreshold) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }

                lastScrollTop = scrollTop;
                ticking = false;
            }

            window.addEventListener('scroll', function () {
                if (!ticking) {
                    window.requestAnimationFrame(handleHeaderScroll);
                    ticking = true;
                }
            }, { passive: true });

            // Add resize handler to regenerate grid
            let resizeTimeout;
            window.addEventListener('resize', function () {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (isLandingPage && allApis.length > 0) {
                        renderHexagonView();
                        // Re-add keyboard support after regeneration
                        setTimeout(() => {
                            document.querySelectorAll('.hexagon-item').forEach((hexagon, index) => {
                                hexagon.setAttribute('tabindex', '0');
                                hexagon.setAttribute('role', 'button');
                                hexagon.setAttribute('aria-label', `Navigate to ${allApis[index]?.name || 'API'} documentation`);

                                hexagon.addEventListener('keydown', function (e) {
                                    if (e.key === 'Enter' || e.key === ' ') {
                                        e.preventDefault();
                                        this.click();
                                    }
                                });
                            });
                        }, 100);
                    }
                }, 300);
            });
        });</script>

    <script>
        // Keep the endpoint filter fixed under the header and provide a collapse/expand toggle.
        (function () {
            const root = document.documentElement;
            const header = document.querySelector('header');
            const bar = document.getElementById('endpointFilterBar');
            const toggle = document.getElementById('endpointCollapseToggle');

            function updateVars() {
                if (!header) return;
                // Use getBoundingClientRect().bottom to compute the exact position
                // of the header bottom in viewport coordinates. This keeps the
                // endpoint bar glued to the header even during animations.
                const rect = header.getBoundingClientRect();
                const headerBottom = Math.max(0, rect.bottom);
                root.style.setProperty('--navbar-height', headerBottom + 'px');

                // Set the fixed bar top directly to avoid any timing gaps
                if (bar) {
                    try {
                        bar.style.top = headerBottom + 'px';
                        root.style.setProperty('--endpoint-bar-height', bar.offsetHeight + 'px');
                    } catch (e) {
                        // ignore DOM exceptions
                    }
                }
            }

            // Observe header attribute changes (class toggles when morphing) so the bar stays glued to its bottom.
            try {
                if (header && window.MutationObserver) {
                    const headerObserver = new MutationObserver(() => {
                        // header class or style changed (morphed/unmorphed) -> update CSS vars
                        updateVars();
                    });
                    headerObserver.observe(header, { attributes: true, attributeFilter: ['class', 'style'] });
                }

                // ResizeObserver watches for changes to header size during animations
                if (header && window.ResizeObserver) {
                    const ro = new ResizeObserver(() => updateVars());
                    ro.observe(header);
                }
            } catch (e) {
                // ignore if observers unavailable
            }

            // Also update on scroll using rAF to catch transitions that change header height
            let varTicking = false;
            window.addEventListener('scroll', function () {
                if (!varTicking) {
                    window.requestAnimationFrame(() => {
                        updateVars();
                        varTicking = false;
                    });
                    varTicking = true;
                }
            }, { passive: true });

            function setCollapsed(collapsed) {
                if (!bar) return;
                if (collapsed) {
                    bar.classList.add('collapsed');
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.innerHTML = '<i class="fas fa-chevron-down" aria-hidden="true"></i>';
                    }
                } else {
                    bar.classList.remove('collapsed');
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'true');
                        toggle.innerHTML = '<i class="fas fa-chevron-up" aria-hidden="true"></i>';
                    }
                }
                try { localStorage.setItem('endpointFilterCollapsed', collapsed ? '1' : '0'); } catch (e) { }
                // update dimensions after state change and adjust swagger UI padding
                setTimeout(() => {
                    updateVars();
                    try { setSwaggerUiPaddingForFilterBar(true); } catch (e) { }
                }, 120);
            }

            if (toggle) {
                toggle.addEventListener('click', () => {
                    setCollapsed(!bar.classList.contains('collapsed'));
                });
            }

            window.addEventListener('resize', updateVars);
            // initialize after DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                updateVars();
                try {
                    const saved = localStorage.getItem('endpointFilterCollapsed');
                    if (saved === '1') setCollapsed(true);
                    else setCollapsed(false);
                } catch (e) {
                    // ignore
                }
                // run again after a short delay to account for header animations
                setTimeout(updateVars, 300);
            });
        })();
    </script>

    <!-- Scroll-to-top floating button -->
    <style>
        .scroll-top-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 44px;
            height: 44px;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0f766e, #115e59);
            color: white;
            border: none;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.18);
            cursor: pointer;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.22s ease, transform 0.22s ease;
            z-index: 2000;
            pointer-events: none;
        }

        .scroll-top-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .scroll-top-btn:focus {
            outline: none;
            box-shadow: 0 0 0 6px rgba(14, 165, 233, 0.12);
        }
    </style>

    <button id="scrollTopBtn" class="scroll-top-btn" aria-label="Back to top" title="Back to top">
        <i class="fas fa-chevron-up"></i>
    </button>

    <script>
        (function () {
            const btn = document.getElementById('scrollTopBtn');
            if (!btn) return;

            let ticking = false;

            function updateVisibility() {
                const showAfter = 240; // px scrolled before showing
                if (window.scrollY > showAfter) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
                ticking = false;
            }

            window.addEventListener('scroll', function () {
                if (!ticking) {
                    window.requestAnimationFrame(updateVisibility);
                    ticking = true;
                }
            }, { passive: true });

            // show immediately if already scrolled
            document.addEventListener('DOMContentLoaded', updateVisibility);

            btn.addEventListener('click', function (e) {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // hide button while scrolling to top
                btn.classList.remove('visible');
            });

            // keyboard accessibility
            btn.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    btn.click();
                }
            });
        })();
    </script>

</body>

</html>