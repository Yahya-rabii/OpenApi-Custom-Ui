<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API DOCUMENTATION</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css" />
    <link rel="icon" type="image/png" href="https://petstore.swagger.io/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="https://petstore.swagger.io/favicon-16x16.png" sizes="16x16" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #0f766e 0%, #115e59 100%);
            --secondary-gradient: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow-primary: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-elevated: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --success-color: #059669;
            --primary-color: #0f766e;
            --primary-accent: rgba(15, 118, 110, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --card-bg: #ffffff;
            --card-bg-hover: rgba(240, 249, 255, 0.8);
            --border-secondary: rgba(226, 232, 240, 0.8);
            --border-primary: rgba(15, 118, 110, 0.2);
            --border-light: rgba(226, 232, 240, 0.5);
            --bg-secondary: #f8fafc;
            --hover-bg: rgba(240, 249, 255, 0.6);
            --scrollbar-track: #f1f5f9;
            --scrollbar-thumb: linear-gradient(135deg, #64748b, #475569);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #1e293b;
        }

        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #64748b, #475569);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #475569, #334155);
        }

        /* Enhanced scrollbar for autocomplete */
        #autocomplete-list::-webkit-scrollbar {
            width: 4px;
        }

        #autocomplete-list::-webkit-scrollbar-track {
            background: rgba(241, 245, 249, 0.5);
            border-radius: 2px;
        }

        #autocomplete-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(14, 165, 233, 0.3);
        }

        #autocomplete-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #0284c7, #0369a1);
        }

        /* Enhanced animations */
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Remove text-shadow for crisper text */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }


        /* Draggable notch and floating filter panel for domain filters (landing page) */
        #filterNotch {
            position: fixed;
            right: 28px;
            top: 120px;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: var(--primary-gradient);
            color: #fff;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 20px rgba(15, 118, 110, 0.18);
            cursor: grab;
            z-index: 1200;
            transition: transform 0.12s ease, opacity 0.12s ease;
        }

        #filterNotch:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .filter-panel {
            position: fixed;
            min-width: 280px;
            max-width: 420px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            box-shadow: 0 14px 40px rgba(2, 6, 23, 0.16);
            z-index: 1199;
            padding: 12px;
            display: none;
            /* toggled open/closed */
            flex-direction: column;
            gap: 8px;
            border: 1px solid rgba(2, 6, 23, 0.06);
            /* Prepare for merge-from / merge-into animations */
            transform-origin: center center;
            /* will be dynamically set from JS */
            transform: scale(0.96);
            opacity: 0;
            clip-path: circle(0px at 50% 50%);
            transition: clip-path 360ms cubic-bezier(0.22, 1, 0.36, 1),
                transform 300ms cubic-bezier(0.22, 1, 0.36, 1),
                opacity 220ms ease;
            will-change: clip-path, transform, opacity;
            /* Allow the panel to grow and be scrollable when content is large */
            max-height: 75vh; /* keep it bounded to viewport */
            overflow: auto; /* enable scrolling for many tags */
            box-sizing: border-box;
        }

        .filter-panel .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .filter-panel .panel-title {
            font-weight: 700;
            color: #0f766e;
            font-size: 0.95rem;
        }

        .filter-panel .panel-close {
            background: transparent;
            border: none;
            font-size: 1.1rem;
            cursor: pointer;
            color: #64748b;
        }

        /* Utility classes for open/close states */
        .filter-panel.open {
            opacity: 1;
            transform: scale(1);
            /* large circle ensures full reveal; JS will set the center point */
            clip-path: circle(1200px at var(--clip-x, 50%) var(--clip-y, 50%));
            display: flex;
            /* ensure visible when open class is applied */
        }

        .filter-panel.closing {
            /* while closing we'll animate back to a small circle */
            opacity: 0;
            transform: scale(0.96);
            /* clip-path will be set by JS to circle(0px at x y) */
        }

        #panelDomainFilters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }



        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        @keyframes dropdownGlow {
            0% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            }

            50% {
                box-shadow: 0 6px 16px rgba(14, 165, 233, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }

            100% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            }
        }

        @keyframes listSlideIn {
            0% {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes dropdownPulse {
            0% {
                transform: translateY(-3px) scale(1.02);
            }

            50% {
                transform: translateY(-4px) scale(1.03);
                box-shadow: 0 0 0 6px rgba(14, 165, 233, 0.2),
                    0 15px 35px rgba(14, 165, 233, 0.25),
                    0 10px 25px rgba(0, 0, 0, 0.2);
            }

            100% {
                transform: translateY(-3px) scale(1.02);
            }
        }

        @keyframes dropdownExpand {
            0% {
                height: 52px;
                border-radius: 26px;
            }

            100% {
                height: auto;
                border-radius: 20px 20px 8px 8px;
            }
        }

        @keyframes arrowSpin {
            0% {
                transform: translateY(-50%) rotate(0deg) scale(1.1);
            }

            50% {
                transform: translateY(-50%) rotate(90deg) scale(1.2);
            }

            100% {
                transform: translateY(-50%) rotate(180deg) scale(1.1);
            }
        }

        @keyframes optionSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Dropdown opening state */
        .dropdown-opening {
            animation: dropdownPulse 0.6s ease-out !important;
        }

        .dropdown-opening .dropdown-arrow {
            animation: arrowSpin 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
        }

        /* Dropdown container glow effect */
        .dropdown-container::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #0ea5e9, #10b981, #f59e0b, #ef4444, #8b5cf6, #0ea5e9);
            background-size: 400% 400%;
            border-radius: 28px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: gradientShift 3s ease infinite;
        }

        .dropdown-container:has(select:focus)::after {
            opacity: 0.6;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* Input focus ring */
        .focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1), 0 0 0 1px rgb(14, 165, 233);
        }

        /* Hover lift effect */
        .hover-lift {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hover-lift:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-elevated);
        }

        /* Header styles - Enhanced Liquid Glass Effect */
        header {
            background: linear-gradient(135deg, rgba(15, 118, 110, 0.75) 0%, rgba(17, 94, 89, 0.75) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.18);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(15, 118, 110, 0.3), 
                        0 2px 8px rgba(255, 255, 255, 0.1) inset;
            animation: slideInDown 0.8s ease-out;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
        }

        /* Scroll progress indicator */
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 3px;
            width: var(--scroll-progress, 0%);
            background: linear-gradient(90deg, #14b8a6, #06b6d4, #0ea5e9);
            transition: width 0.1s ease-out;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
        }

        header.scrolled::before {
            opacity: 1;
        }

        /* Scrolled state - Enhanced liquid glass with more blur */
        header.scrolled {
            background: linear-gradient(135deg, rgba(15, 118, 110, 0.85) 0%, rgba(17, 94, 89, 0.85) 100%);
            backdrop-filter: blur(30px) saturate(200%);
            -webkit-backdrop-filter: blur(30px) saturate(200%);
            box-shadow: 0 12px 40px rgba(15, 118, 110, 0.4), 
                        0 2px 12px rgba(255, 255, 255, 0.15) inset,
                        0 -1px 0 rgba(255, 255, 255, 0.1) inset;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 32px;
            gap: 32px;
            transition: padding 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Compact header when scrolled */
        header.scrolled .header-content {
            padding: 12px 32px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 16px;
            transition: gap 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        header.scrolled .brand {
            gap: 12px;
        }

        .brand img {
            height: 48px;
            width: 48px;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Smaller logo when scrolled */
        header.scrolled .brand img {
            height: 38px;
            width: 38px;
            border-radius: 10px;
        }

        .brand img:hover {
            transform: scale(1.05) rotate(5deg);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .brand-text {
            color: white;
            font-weight: 700;
            font-size: 1.5rem;
            letter-spacing: -0.025em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: font-size 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Smaller text when scrolled */
        header.scrolled .brand-text {
            font-size: 1.3rem;
        }

        /* Controls section */
        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Subtle lift effect when scrolled */
        header.scrolled .controls {
            transform: translateY(-1px);
        }

        /* Search input container */
        .search-container {
            position: relative;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 9999;
        }

        .search-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 18px;
            z-index: 10;
            transition: color 0.3s ease;
        }

        .clear-search-icon {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            z-index: 10;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .clear-search-icon:hover {
            color: #ef4444;
            opacity: 1;
            transform: translateY(-50%) scale(1.1);
        }

        input#apiSearch {
            width: 320px;
            height: 52px;
            padding: 0 20px 0 50px;
            border-radius: 26px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.95);
            color: #1e293b;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced glow when header is scrolled */
        header.scrolled input#apiSearch {
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: 0 4px 16px rgba(14, 165, 233, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        input#apiSearch:focus {
            outline: none;
            background: white;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1), 0 8px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        input#apiSearch:focus+.search-icon {
            color: #0ea5e9;
        }

        input#apiSearch::placeholder {
            color: #64748b;
            font-weight: 400;
        }

        /* Dropdown container */
        .dropdown-container {
            position: relative;
            z-index: 9999;
        }

        .dropdown-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            z-index: 10;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .dropdown-container:hover .dropdown-icon {
            color: #0ea5e9;
            transform: translateY(-50%) scale(1.1);
        }

        select#apiDropdown:focus+.dropdown-arrow+* .dropdown-icon,
        .dropdown-container:has(select:focus) .dropdown-icon {
            color: #0ea5e9;
            transform: translateY(-50%) scale(1.1);
        }

        /* Custom dropdown button styling */
        .dropdown-button {
            width: 320px;
            height: 52px;
            padding: 0 50px 0 45px;
            border-radius: 26px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            color: #1e293b;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: space-between;
            text-align: left;
        }

        /* Enhanced glow when header is scrolled */
        header.scrolled .dropdown-button {
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: 0 4px 16px rgba(14, 165, 233, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.7);
        }

        .dropdown-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(14, 165, 233, 0.3);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transform: translateY(-1px);
        }

        .dropdown-button:focus,
        .dropdown-button.active {
            outline: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(240, 249, 255, 0.98) 100%);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.15),
                0 12px 30px rgba(14, 165, 233, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            transform: translateY(-3px) scale(1.02);
        }

        /* Dropdown list styling */
        .dropdown-list {
            position: absolute;
            top: 60px;
            left: 0;
            width: auto;
            min-width: 100%;
            max-width: 500px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 10000;
            display: none;
            animation: listSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .dropdown-list.show {
            display: block;
        }

        .dropdown-item {
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #334155;
            font-weight: 500;
            border-bottom: 1px solid rgba(241, 245, 249, 0.7);
            font-size: 14px;
            position: relative;
            overflow: hidden;
            min-height: 54px;
            display: flex;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
        }

        .dropdown-item:last-child {
            border-bottom: none;
            border-radius: 0 0 16px 16px;
        }

        .dropdown-item:first-child {
            border-radius: 16px 16px 0 0;
        }

        .dropdown-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 0;
            height: 100%;
            background: var(--primary-gradient);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 2px 0 8px rgba(15, 118, 110, 0.3);
        }

        .dropdown-item:hover {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            padding-left: 28px;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.1);
        }

        .dropdown-item:hover::before {
            width: 4px;
        }

        .dropdown-item:active {
            transform: translateX(2px) scale(0.98);
            background: linear-gradient(135deg, rgba(224, 242, 254, 0.9) 0%, rgba(186, 230, 253, 0.7) 100%);
        }

        .dropdown-item.selected {
            background: var(--primary-gradient);
            color: white;
            font-weight: 600;
        }

        .dropdown-item.selected .domain-tag {
            background: rgba(255, 255, 255, 0.2) !important;
            color: white !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }

        .dropdown-item.focused {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            outline: 2px solid rgba(14, 165, 233, 0.3);
            outline-offset: -2px;
        }

        /* Hide original select */
        select#apiDropdown {
            display: none;
        }

        /* Dropdown opening animation overlay */
        select#apiDropdown::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(14, 165, 233, 0.1), transparent);
            transition: left 0.6s ease;
            pointer-events: none;
        }

        select#apiDropdown:focus::before {
            left: 100%;
        }

        select#apiDropdown:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 0.98) 100%);
            border-color: rgba(14, 165, 233, 0.3);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transform: translateY(-1px);
        }

        select#apiDropdown:focus {
            outline: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(240, 249, 255, 0.98) 100%);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.15),
                0 12px 30px rgba(14, 165, 233, 0.2),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            transform: translateY(-3px) scale(1.02);
            animation: dropdownPulse 0.6s ease-out;
        }



        .dropdown-arrow {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #64748b, #475569);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .dropdown-container:hover .dropdown-arrow {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            transform: translateY(-50%) scale(1.1);
        }

        select#apiDropdown:focus+.dropdown-arrow {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: arrowSpin 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: translateY(-50%) rotate(180deg) scale(1.1);
            filter: drop-shadow(0 3px 6px rgba(14, 165, 233, 0.4));
        }

        /* Autocomplete dropdown */
        #autocomplete-list {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            max-height: 300px;
            overflow-y: auto;
            z-index: 10000;
            animation: listSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(226, 232, 240, 0.6);
        }

        .autocomplete-item {
            position: relative;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #334155;
            font-weight: 500;
            border-bottom: 1px solid rgba(241, 245, 249, 0.7);
            overflow: hidden;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
            border-radius: 0 0 20px 20px;
        }

        .autocomplete-item:first-child {
            border-radius: 20px 20px 0 0;
        }

        .autocomplete-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 0;
            height: 100%;
            background: var(--primary-gradient);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 2px 0 8px rgba(15, 118, 110, 0.3);
        }

        .autocomplete-item::after {
            content: '';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
        }

        .autocomplete-item:hover {
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.8) 0%, rgba(224, 242, 254, 0.6) 100%);
            color: #0f766e;
            padding-left: 28px;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.1);
        }

        .autocomplete-item:hover::before {
            width: 4px;
        }

        .autocomplete-item:hover::after {
            transform: translateY(-50%) scale(1);
            opacity: 0.8;
        }

        .autocomplete-item:active {
            transform: translateX(2px) scale(0.98);
            background: linear-gradient(135deg, rgba(224, 242, 254, 0.9) 0%, rgba(186, 230, 253, 0.7) 100%);
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Swagger UI container enhancements */
        #swagger-ui {
            animation: slideInUp 0.6s ease-out;
            border-radius: 24px;
            background: white;
            box-shadow: var(--shadow-primary);
            margin: 32px;
            overflow: hidden;
            padding: 0;
        }

        /* Mobile responsiveness */
        @media (max-width: 1024px) {
            .header-content {
                padding: 16px 24px;
                gap: 24px;
            }

            .controls {
                gap: 16px;
            }

            input#apiSearch {
                width: 280px;
            }

            .dropdown-button {
                width: 280px;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 20px;
                padding: 20px 16px;
            }

            .controls {
                flex-direction: column;
                gap: 16px;
                width: 100%;
            }

            .search-container,
            .dropdown-container {
                width: 100%;
            }

            input#apiSearch,
            .dropdown-button {
                width: 100%;
                min-width: 280px;
            }

            .dropdown-list {
                left: 0;
                right: 0;
                max-width: none;
                width: 100%;
            }

            #autocomplete-list {
                width: 100%;
            }

            #swagger-ui {
                margin: 16px;
                border-radius: 16px;
            }

            .brand-text {
                font-size: 1.25rem;
            }

            /* Filter bar responsive */
            .filter-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 12px 16px;
                gap: 12px;
            }

            .method-filter-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 12px 16px;
                gap: 12px;
            }

            .filter-label {
                align-self: flex-start;
                margin-bottom: 4px;
            }

            #domainFilters,
            #methodFilters {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .domain-chip,
            .method-chip {
                font-size: 0.8rem;
                padding: 8px 14px;
            }

            .clear-filters-btn {
                align-self: center;
                margin-top: 8px;
                margin-left: 0;

            }


            /* Endpoint filter bar responsive */
            .endpoint-filter-content {
                flex-direction: column;
                position: relative;
                align-items: stretch;
                gap: 16px;
            }

            .filter-section {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            #endpointSearch {
                width: 100%;
                min-width: 250px;
            }

            .endpoint-method-filters {
                width: 100%;
                justify-content: flex-start;
            }

            .clear-endpoint-filters-btn {
                align-self: flex-start;
                margin-left: 0;
                margin-top: 8px;
            }
        }

        @media (max-width: 480px) {

            input#apiSearch,
            .dropdown-button {
                min-width: 100%;
                height: 48px;
                font-size: 14px;
            }
        }

        /* Hexagonal API Display Styles */
        .hexagon-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 40px 40px 40px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: calc(100vh - 120px);
        }

        .hexagon-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 100vw;
            margin: 0 auto;
            padding: 40px;
            min-height: 500px;
        }

        .hexagon-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 14px; /* Horizontal gap between hexagons */
            margin-bottom: -45px; /* Vertical overlap for perfect honeycomb */
            position: relative; /* Allow margin-left to work with centering */
        }

        .hexagon-row:last-child {
            margin-bottom: 0; /* No overlap on last row */
        }

        .hexagon-item {
            position: relative;
            width: 220px;
            height: 253px; /* Proper height for larger hexagon */
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: fadeInScale 0.6s ease-out;
            animation-fill-mode: both;
            transform-origin: center center; /* Scale from center for equal growth */
        }

        /* Search filtering animations */
        .hexagon-item.filtered-out {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(1);
            pointer-events: none;
        }

        .hexagon-item.filtered-in {
            opacity: 1;
            transform: scale(1);
            filter: none;
        }

        /* Domain filtering - instant and clean like card view with no position memory */
        .hexagon-item.domain-filtered-out {
            opacity: 0 !important;
            transform: scale(1) translateY(0) !important;
            filter: none !important;
            pointer-events: none;
            display: none !important;
            visibility: hidden !important;
            /* No transitions to prevent position memory and flickering */
            transition: none !important;
        }

        .hexagon-item.domain-filtered-in {
            opacity: 1 !important;
            transform: scale(1) translateY(0) !important;
            filter: none !important;
            display: block !important;
            visibility: visible !important;
            /* Clean instant appearance without animation delays */
            transition: none !important;
        }

        .hexagon-item:nth-child(1) {
            animation-delay: 0.1s;
        }

            .domain-chip .chip-count {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                margin-left: 8px;
                /* Force a perfect circular badge */
                width: 20px;
                height: 20px;
                padding: 0;
                /* Requested color + opacity */
                background: #0f766d48;
                color: #0f766e;
                opacity: 0.9;
                border-radius: 50%;
                font-size: 0.65rem;
                font-weight: 800;
                box-shadow: 0 2px 6px rgba(2, 6, 23, 0.06);
                border: 1px solid rgba(15, 118, 110, 0.08);
                line-height: 1;
                text-align: center;
                box-sizing: border-box;
                overflow: hidden;
            }

            .domain-chip.active .chip-count {
                /* Keep same requested look when the chip is active */
                background: #0f766d48;
                color: #0f766e;
                opacity: 0.9;
                border-color: rgba(15, 118, 110, 0.06);
            }

        .hexagon-item:nth-child(7) {
            animation-delay: 0.7s;
        }

        .hexagon-item:nth-child(8) {
            animation-delay: 0.8s;
        }

        .hexagon-item:nth-child(9) {
            animation-delay: 0.9s;
        }

        .hexagon-item:nth-child(10) {
            animation-delay: 1.0s;
        }

        .hexagon-shape {
            position: relative;
            width: 220px;
            height: 253px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08),
                        0 2px 8px rgba(0, 0, 0, 0.04);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
            transform-origin: center center;
        }

        .hexagon-shape::before {
            content: '';
            position: absolute;
            inset: 3px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: 1;
        }

        .hexagon-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            width: 180px;
            height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px 20px;
        }

        .hexagon-icon {
            font-size: 2rem;
            color: #0f766e;
            opacity: 0.6;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }

        .hexagon-icon i {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hexagon-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1e293b;
            line-height: 1.3;
            white-space: nowrap;
            max-width: 100%;
            overflow: visible;
            transform-origin: center;
            text-align: center;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .domain-badge {
            position: absolute;
            top: 12.5%;
            left: 75%;
            transform: translate(-50%, -50%) rotate(30deg);
            padding: 5px 10px;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            border-radius: 4px 8px 8px 4px;
            transition: all 0.3s ease;
            z-index: 15;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), inset -1px 0 2px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            text-align: center;
            white-space: nowrap;
            width: 70px;
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0.85;
        }

        .hexagon-item:hover .hexagon-shape {
            transform: scale(1.05);
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.15),
                        0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .hexagon-item.active .hexagon-shape {
            background: linear-gradient(135deg, #d1fae5 0%, #dcfce7 100%);
            filter: drop-shadow(0 0 0 rgba(16, 185, 129, 0.8)) 
                    drop-shadow(0 0 8px rgba(16, 185, 129, 0.6))
                    drop-shadow(0 0 12px rgba(16, 185, 129, 0.4));
            box-shadow: none !important;
        }

        .hexagon-item.active .hexagon-shape::before {
            background: linear-gradient(135deg, #d1fae5 0%, #dcfce7 100%);
        }

        .domain-badge::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -6px;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 6px solid currentColor;
            opacity: 0.8;
            filter: brightness(0.8);
        }

        .domain-badge::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 50%, transparent 100%);
            pointer-events: none;
            clip-path: inherit;
        }

        .hexagon-item:hover .domain-badge {
            box-shadow:
                0 12px 35px rgba(0, 0, 0, 0.25),
                0 8px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%) rotate(30deg) scale(1.15);
            filter: brightness(1.1) saturate(1.1);
            opacity: 1;
        }

        .hexagon-item.active .domain-badge {
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.3),
                0 10px 25px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            filter: brightness(1.2) saturate(1.2);
        }

        .hexagon-item.active .domain-badge::before {
            opacity: 0.8;
        }

        /* Filter Bar Styles */
        .filter-bar {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            justify-content: center;
            margin: 15px auto;
            padding: 0;
            width: 95%;
            max-width: 100%;
            background: transparent;
            border: none;
            animation: slideInDown 0.6s ease-out;
        }

        /* Endpoint Filter Bar: fixed under the header so it remains visible while content scrolls beneath it. */
        /* The inner wrapper (.endpoint-filter-wrapper) constrains width while the bar stretches full-width. */
        .endpoint-filter-bar {
            position: fixed;
            top: var(--navbar-height, 0px);
            left: 0;
            right: 0;
            z-index: 999;
            /* header is 1000, so bar sits below header but above content */
            display: flex;
            justify-content: center;
            pointer-events: auto;
            padding: 8px 0;
            background: rgba(255, 255, 255, 0.6);
            /* semi-transparent so content can be seen beneath */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 6px 18px rgba(15, 118, 110, 0.08);
            transition: top 0s, transform 0.18s ease, height 0.18s ease, padding 0.18s ease;
        }

        .endpoint-filter-bar .endpoint-filter-wrapper {
            width: 90%;
            max-width: 980px;
            margin: 0 auto;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* center content horizontally */
        }

        .endpoint-filter-content {
            padding: 12px 18px;
            display: flex;
            flex-direction: column;
            /* stack search above filters */
            gap: 12px;
            align-items: center;
            justify-content: center;
            background: transparent;
            width: 100%;
        }

        /* Rows inside the fixed wrapper */
        .search-row {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .method-row {
            width: 100%;
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Collapse behavior */
        .endpoint-filter-bar.collapsed {
            height: 44px;
            padding-top: 6px;
            padding-bottom: 6px;
        }

        .endpoint-filter-bar.collapsed .endpoint-filter-content {
            display: none;
        }

        /* Toggle button shown on the right side of the fixed bar */
        .collapse-toggle {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-gradient);
            border: 1px solid rgba(16, 185, 129, 0.28);
            color: #ffffff;
            width: 34px;
            height: 34px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 22px rgba(16, 185, 129, 0.18), 0 2px 6px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            z-index: 1001;
            /* above the bar content */
            transition: transform 0.14s ease, box-shadow 0.14s ease, opacity 0.14s ease;
            opacity: 0.95;
        }

        .collapse-toggle i {
            color: #ffffff;
            /* ensure icon/text is white */
            font-size: 14px;
            line-height: 1;
            transition: transform 0.12s ease;
        }

        .collapse-toggle:hover {
            transform: translateY(-50%) scale(1.04);
            box-shadow: 0 14px 36px rgba(16, 185, 129, 0.26), 0 6px 14px rgba(0, 0, 0, 0.12);
            opacity: 1;
        }

        .collapse-toggle:active {
            transform: translateY(-50%) scale(0.98);
        }

        .collapse-toggle:focus {
            outline: none;
            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.12);
        }

        .collapse-toggle:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.08);
        }

        .filter-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #64748b;
            white-space: nowrap;
        }

        .filter-label i {
            font-size: 0.9rem;
        }

        /* Endpoint Search */
        .search-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .endpoint-search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .endpoint-search-container .fas.fa-search {
            position: absolute;
            left: 12px;
            color: #64748b;
            font-size: 14px;
            z-index: 10;
        }

        .endpoint-search-container .clear-endpoint-search {
            position: absolute;
            right: 12px;
            color: #64748b;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
            z-index: 10;
        }

        .endpoint-search-container .clear-endpoint-search:hover {
            color: #ef4444;
            opacity: 1;
            transform: scale(1.1);
        }

        #endpointSearch {
            width: 280px;
            height: 40px;
            padding: 0 40px 0 40px;
            border-radius: 25px;
            border: 2px solid rgba(226, 232, 240, 0.6);
            background: rgba(255, 255, 255, 0.8);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            color: #1e293b;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        #endpointSearch:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.95);
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.15), 0 8px 30px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        #endpointSearch::placeholder {
            color: #64748b;
            font-weight: 400;
        }

        /* Endpoint Method Filters */
        .endpoint-method-filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }



        #domainFilters {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            flex: 1;
            justify-content: center;
        }

        .domain-chip {
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(15, 118, 110, 0.3);
            border: 1.5px solid rgba(15, 118, 110, 0.4);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.75rem;
            color: #0f766e;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: capitalize;
            box-shadow: 0 2px 6px rgba(15, 118, 110, 0.15);
            white-space: nowrap;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            will-change: transform, background, box-shadow;
        }

        .domain-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
        }

        .domain-chip:hover::before {
            left: 100%;
        }

        .domain-chip:hover {
            background: rgba(15, 118, 110, 0.4);
            border-color: rgba(15, 118, 110, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.25);
            color: #0d5d56;
        }

        .domain-chip.active {
            background: var(--primary-gradient);
            color: white;
            border-color: #0f766e;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 16px rgba(15, 118, 110, 0.4);
        }

        .domain-chip.active:hover {
            background: linear-gradient(135deg, #0d5d56, #0f766e);
            box-shadow: 0 8px 20px rgba(15, 118, 110, 0.5);
        }

        .domain-chip .chip-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            /* Force a perfect circular badge */
            width: 20px;
            height: 20px;
            padding: 0;
            background:  #0f766d48;
            color: #0f766e;
            border-radius: 50%;
            font-size: 0.65rem;
            font-weight: 800;
            box-shadow: 0 2px 6px rgba(2, 6, 23, 0.06);
            border: 1px solid rgba(15, 118, 110, 0.08);
            line-height: 1;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
            transition: all 0.3s ease;
            opacity: 0.9;
        }

        .domain-chip.active .chip-count {
            /* Match the endpoint tag chip count color when active */
            background: #0f766d48;
            color: #0f766e;
            opacity: 0.9;
            border-color: rgba(15, 118, 110, 0.06);
        }

        /* Higher-specificity override: ensure domain and endpoint-tag chip counts
           always use the requested teal styling even if external/injected styles
           (e.g., Swagger UI or inline rules) try to override them. This is a
           minimal, targeted fallback and uses !important to guarantee application. */
        .filter-panel .panel-filters .domain-chip .chip-count,
        #panelDomainFilters .domain-chip .chip-count,
        .endpoint-tag-chip.domain-chip .chip-count,
        #endpointTagFilters .endpoint-tag-chip .chip-count,
        .domain-chip .chip-count {
            background: #0f766d48 !important;
            color: #0f766e !important;
            opacity: 0.9 !important;
            border-color: rgba(15, 118, 110, 0.06) !important;
        }

        /* When a chip is active/selected, make the number text white for contrast.
           Apply to domain chips, endpoint tag chips, and method chips. Use
           !important to guarantee the visual change overrides prior rules. */
        .filter-panel .panel-filters .domain-chip.active .chip-count,
        #panelDomainFilters .domain-chip.active .chip-count,
        .endpoint-tag-chip.domain-chip.active .chip-count,
        #endpointTagFilters .endpoint-tag-chip.active .chip-count,
        .domain-chip.active .chip-count,
        .method-chip.active .chip-count,
        .endpoint-method-chip.active .chip-count {
            color: #ffffff !important;
        }

        /* HTTP Method Chips - Floating Style */
        .method-chip,
        .endpoint-method-chip {
            padding: 8px 16px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.75rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            will-change: transform, background, box-shadow;
            border: 1.5px solid transparent;
            pointer-events: all;
            -webkit-user-select: none;
            user-select: none;
        }

        .method-chip:hover,
        .endpoint-method-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        /* HTTP Method specific colors */
        .method-chip[data-method="get"],
        .endpoint-method-chip[data-method="get"] {
            background: rgba(34, 197, 94, 0.2);
            color: #059669;
            border-color: rgba(34, 197, 94, 0.3);
        }

        .method-chip[data-method="post"],
        .endpoint-method-chip[data-method="post"] {
            background: rgba(59, 130, 246, 0.2);
            color: #2563eb;
            border-color: rgba(59, 130, 246, 0.3);
        }

        .method-chip[data-method="put"],
        .endpoint-method-chip[data-method="put"] {
            background: rgba(245, 158, 11, 0.2);
            color: #d97706;
            border-color: rgba(245, 158, 11, 0.3);
        }

        .method-chip[data-method="patch"],
        .endpoint-method-chip[data-method="patch"] {
            background: rgba(168, 85, 247, 0.2);
            color: #7c3aed;
            border-color: rgba(168, 85, 247, 0.3);
        }

        .method-chip[data-method="delete"],
        .endpoint-method-chip[data-method="delete"] {
            background: rgba(239, 68, 68, 0.2);
            color: #dc2626;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .method-chip::before,
        .endpoint-method-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
            pointer-events: none;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            /* Ensure pseudo-element doesn't interfere with clicks */
        }

        .method-chip:hover::before,
        .endpoint-method-chip:hover::before {
            left: 100%;
        }

        .method-chip:hover,
        .endpoint-method-chip:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .method-chip[data-method="get"]:hover,
        .endpoint-method-chip[data-method="get"]:hover {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .method-chip[data-method="post"]:hover,
        .endpoint-method-chip[data-method="post"]:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .method-chip[data-method="put"]:hover,
        .endpoint-method-chip[data-method="put"]:hover {
            background: rgba(245, 158, 11, 0.3);
            border-color: rgba(245, 158, 11, 0.5);
        }

        .method-chip[data-method="patch"]:hover,
        .endpoint-method-chip[data-method="patch"]:hover {
            background: rgba(168, 85, 247, 0.3);
            border-color: rgba(168, 85, 247, 0.5);
        }

        .method-chip[data-method="delete"]:hover,
        .endpoint-method-chip[data-method="delete"]:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .method-chip.active[data-method="get"],
        .endpoint-method-chip.active[data-method="get"] {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border-color: #16a34a;
            box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
        }

        .method-chip.active[data-method="post"],
        .endpoint-method-chip.active[data-method="post"] {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border-color: #2563eb;
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .method-chip.active[data-method="put"],
        .endpoint-method-chip.active[data-method="put"] {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border-color: #d97706;
            box-shadow: 0 6px 16px rgba(245, 158, 11, 0.4);
        }

        .method-chip.active[data-method="patch"],
        .endpoint-method-chip.active[data-method="patch"] {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
            border-color: #7c3aed;
            box-shadow: 0 6px 16px rgba(168, 85, 247, 0.4);
        }

        .method-chip.active[data-method="delete"],
        .endpoint-method-chip.active[data-method="delete"] {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border-color: #dc2626;
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        /* Base styling for method / HTTP count badges.
           We provide a dedicated selector `.http-chip-count` so these
           badges do not get affected by domain tag styles. */
        .method-chip .chip-count,
        .endpoint-method-chip .chip-count,
        .method-chip .http-chip-count,
        .endpoint-method-chip .http-chip-count,
        .http-chip-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 5px;
            /* Make method/count badges circular to match domain style */
            width: 18px;
            height: 18px;
            padding: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            font-size: 0.62rem;
            font-weight: 700;
            pointer-events: none;
            line-height: 1;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
        }

        .method-chip.active .chip-count,
        .endpoint-method-chip.active .chip-count,
        .method-chip.active .http-chip-count,
        .endpoint-method-chip.active .http-chip-count,
        .http-chip-count.active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Per-method colored variants for the http-chip-count (and legacy
           chip-count selectors for backward compatibility). */
        .method-chip[data-method="get"] .chip-count,
        .endpoint-method-chip[data-method="get"] .chip-count,
        .method-chip[data-method="get"] .http-chip-count,
        .endpoint-method-chip[data-method="get"] .http-chip-count,
        .http-chip-count[data-method="get"] {
            background: rgba(34, 197, 94, 0.35) !important;
            color: #ffffff !important;
            border-color: rgba(34, 197, 94, 0.35) !important;
        }

        .method-chip[data-method="post"] .chip-count,
        .endpoint-method-chip[data-method="post"] .chip-count,
        .method-chip[data-method="post"] .http-chip-count,
        .endpoint-method-chip[data-method="post"] .http-chip-count,
        .http-chip-count[data-method="post"] {
            background: rgba(59, 130, 246, 0.35) !important;
            color: #ffffff !important;
            border-color: rgba(59, 130, 246, 0.35) !important;
        }

        .method-chip[data-method="put"] .chip-count,
        .endpoint-method-chip[data-method="put"] .chip-count,
        .method-chip[data-method="put"] .http-chip-count,
        .endpoint-method-chip[data-method="put"] .http-chip-count,
        .http-chip-count[data-method="put"] {
            background: rgba(245, 158, 11, 0.35) !important;
            color: #ffffff !important;
            border-color: rgba(245, 158, 11, 0.35) !important;
        }

        .method-chip[data-method="patch"] .chip-count,
        .endpoint-method-chip[data-method="patch"] .chip-count,
        .method-chip[data-method="patch"] .http-chip-count,
        .endpoint-method-chip[data-method="patch"] .http-chip-count,
        .http-chip-count[data-method="patch"] {
            background: rgba(168, 85, 247, 0.35) !important;
            color: #ffffff !important;
            border-color: rgba(168, 85, 247, 0.35) !important;
        }

        .method-chip[data-method="delete"] .chip-count,
        .endpoint-method-chip[data-method="delete"] .chip-count,
        .method-chip[data-method="delete"] .http-chip-count,
        .endpoint-method-chip[data-method="delete"] .http-chip-count,
        .http-chip-count[data-method="delete"] {
            background: rgba(239, 68, 68, 0.35) !important;
            color: #ffffff !important;
            border-color: rgba(239, 68, 68, 0.35) !important;
        }

        /* Smooth transitions for filtered hexagons */
        .hexagon-item {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.3s ease,
                transform 0.3s ease,
                filter 0.3s ease;
        }

        .hexagon-item.domain-filtered-out {
            opacity: 0;
            transform: scale(0.8);
            filter: grayscale(0.8) blur(2px);
            pointer-events: none;
            position: absolute;
            visibility: hidden;
        }



        .hexagon-item:hover,
        .hexagon-item.hexagon-hovered {
            transform: translate(0, 0) scale(1.05) !important;
            transform-origin: center center !important;
            z-index: 100 !important;
            position: relative;
        }

        .hexagon-item:hover .hexagon-shape {
            background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
            box-shadow: 0 20px 40px rgba(15, 118, 110, 0.2);
        }

        .hexagon-item:hover .hexagon-icon {
            opacity: 1;
            transform: translateY(-3px) scale(1.1);
        }

        .hexagon-item:hover .hexagon-title {
            color: #0f766e;
        }

        /* Active state for selected hexagon */
        .hexagon-item.active .hexagon-shape {
            background: linear-gradient(135deg, #d1fae5 0%, #dcfce7 100%);
            filter: drop-shadow(0 0 0 rgba(16, 185, 129, 0.8)) 
                    drop-shadow(0 0 8px rgba(16, 185, 129, 0.6))
                    drop-shadow(0 0 12px rgba(16, 185, 129, 0.4));
        }

        .hexagon-item.active .hexagon-content {
            color: #1e293b;
        }

        .hexagon-item.active .hexagon-title {
            color: #1e293b;
        }

        .hexagon-item.active .hexagon-icon {
            opacity: 1;
            color: #0f766e;
        }

        /* Landing page title */
        .landing-title {
            text-align: center;
            margin-bottom: 40px;
            animation: slideInDown 0.8s ease-out;
        }

        .landing-title h1 {
            font-size: 3rem;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .landing-title p {
            font-size: 1.2rem;
            color: #64748b;
            font-weight: 500;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* Hexagonal Home Button */
        .hexagonal-home-btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: var(--shadow-primary);
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            margin-right: 15px;
        }

        .hexagonal-home-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-elevated);
            background: linear-gradient(135deg, #115e59 0%, #0f766e 100%);
        }

        .hexagonal-home-btn i {
            font-size: 1rem;
        }

        /* View Switcher Styles */
        .view-switcher {
            display: flex;
            gap: 4px;
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 4px;
            margin-right: 16px;
            box-shadow: var(--shadow-primary);
            transition: all 0.3s ease;
        }

        .view-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            position: relative;
            overflow: hidden;
        }

        .view-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 8px;
        }

        .view-btn:hover {
            color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: var(--shadow-hover);
        }

        .view-btn:hover::before {
            opacity: 0.1;
        }

        .view-btn.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-elevated);
            transform: translateY(-1px);
        }

        .view-btn.active::before {
            opacity: 0;
        }

        .view-btn i {
            position: relative;
            z-index: 1;
        }

        /* Hide Swagger UI initially */
        #swagger-ui {
            display: none;
        }

        #swagger-ui.show {
            display: block;
        }



        /* Responsive hexagon layout */
        @media (max-width: 1600px) and (min-width: 1201px) {
            /* Use computed transform via variables; no margin-left */
            .hexagon-grid { --hex-width: 200px; --hex-gap: 5px; --offset-tweak: 4px; }
        }

        @media (max-width: 1200px) {
            /* 180px hex, 10px gap */
            .hexagon-grid { --hex-width: 180px; --hex-gap: 10px; --offset-tweak: 4px; }

            .hexagon-item {
                width: 180px;
                height: 207px;
            }

            .hexagon-shape {
                width: 180px;
                height: 207px;
            }

            .hexagon-content {
                width: 140px;
                height: 160px;
            }

            .hexagon-title {
                font-size: 0.9rem;
            }

            .hexagon-grid {
                padding: 30px 20px;
            }
        }

        @media (max-width: 768px) {
            .hexagon-grid {
                padding: 20px 10px;
                /* 160px hex, 10px gap */
                --hex-width: 160px; --hex-gap: 10px; --offset-tweak: 4px;
            }

            .hexagon-row {
                justify-content: center;
                gap: 10px;
                margin: -12px 0; /* Reduced overlap */
            }

            .hexagon-item {
                width: 160px;
                height: 184px;
            }

            .hexagon-shape {
                width: 160px;
                height: 184px;
            }

            .hexagon-content {
                width: 120px;
                height: 140px;
                padding: 15px;
            }

            .hexagon-title {
                font-size: 0.85rem;
            }

            .domain-badge {
                font-size: 0.6rem;
                padding: 2px 6px;
            }



            .landing-title h1 {
                font-size: 2.5rem;
            }

            .landing-title p {
                font-size: 1.1rem;
                padding: 0 20px;
            }
        }

        @media (max-width: 480px) {
            .hexagon-grid {
                padding: 20px 5px;
                /* 140px hex, 8px gap */
                --hex-width: 140px; --hex-gap: 8px; --offset-tweak: 4px;
            }

            .hexagon-row {
                gap: 8px;
                margin: -10px 0; /* Reduced overlap */
            }

            .hexagon-item {
                width: 140px;
                height: 161px;
            }

            .hexagon-shape {
                width: 140px;
                height: 161px;
            }

            .hexagon-content {
                width: 100px;
                height: 100px;
                padding: 10px;
            }

            .hexagon-icon {
                font-size: 1.8rem;
            }

            .hexagon-title {
                font-size: 0.75rem;
            }

            .domain-badge {
                font-size: 0.55rem;
                padding: 2px 5px;
            }

            .landing-title h1 {
                font-size: 2rem;
            }
        }

        /* ========== VIEW LAYOUT STYLES ========== */

        /* Card View Styles */
        .card-view {
            display: none;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: calc(100vh - 120px);
            width: 100%;
            max-width: 100vw;
            margin: 0 auto;
            position: relative;
        }

        .card-view.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            position: relative;
            padding: 0px 40px 0px 40px;
            row-gap: 4px;
        }

        .api-card {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.9) 0%, rgba(250, 251, 252, 0.9) 50%, rgba(248, 250, 252, 0.9) 100%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 20px;
            padding: 16px 12px;
            box-shadow:
                0 4px 6px -1px rgba(0, 0, 0, 0.1),
                0 2px 4px -1px rgba(0, 0, 0, 0.06),
                0 2px 8px rgba(255, 255, 255, 0.15) inset;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: visible;
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            margin: 0px 1px;
            flex-shrink: 0;
            /* Remove animation for instant appearance when filtering */
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        .api-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 20px 20px 0 0;
        }

        .api-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(145deg, rgba(15, 118, 110, 0.02) 0%, rgba(6, 182, 212, 0.04) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 20px;
            pointer-events: none;
        }

        .api-card:hover {
            transform: translateY(-8px) scale(1.08);
            box-shadow:
                0 20px 25px -5px rgba(0, 0, 0, 0.12),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 0 1px rgba(15, 118, 110, 0.1) inset,
                0 4px 16px rgba(15, 118, 110, 0.2);
            border-color: rgba(15, 118, 110, 0.2);
            background: linear-gradient(145deg, #ffffff 0%, #f0fdfa 50%, #ecfdf5 100%);
        }

        .api-card:hover::before {
            /* grow the bottom border on hover */
            transform-origin: center;
            transform: scaleX(0.88);
            transition-timing-function: cubic-bezier(0.2, 0.9, 0.2, 1);
        }

        .api-card:hover::after {
            opacity: 0.1;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            z-index: 1;
            text-align: center;
            width: 100%;
            flex: 1;
            padding: 8px 4px 4px 4px;
        }

        .card-icon {
            width: 72px;
            height: 72px;
            font-size: 2.4rem;
            background: transparent;
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0f766e;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            margin: 0;
            opacity: 0.6;
            flex-shrink: 0;
        }

        .card-icon i {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-icon::before {
            content: none;
        }

        .api-card:hover .card-icon {
            opacity: 1;
            transform: translateY(-4px) scale(1.15);
        }

        .api-card.active {
            background: linear-gradient(135deg, #d1fae5 0%, #dcfce7 100%);
            box-shadow:
                0 0 0 3px rgba(16, 185, 129, 0.3),
                0 0 12px rgba(16, 185, 129, 0.4),
                0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .api-card.active .card-title {
            color: #1e293b;
        }

        .api-card.active .card-icon {
            opacity: 1;
        }

        .card-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
            flex: 1;
            justify-content: center;
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
            line-height: 1.3;
            white-space: nowrap;
            max-width: 100%;
            overflow: visible;
            text-align: center;
            width: 100%;
            letter-spacing: -0.025em;
            transition: color 0.3s ease;
            transform-origin: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-domain {
            position: absolute;
            /* sit on the card edge for a ribbon-like appearance */
            top: 0px;
            right: 0px;
            padding: 5px 10px;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            border: 1px solid rgba(15, 118, 110, 0.12);
            transition: all 0.22s cubic-bezier(0.2, 0.9, 0.2, 1);
            /* make the right top corner rounded */
            border-radius: 0 20px 0 12px;
            z-index: 15;
            /* reduced shadow and removed heavy inset for crisper look */
            box-shadow: 0 6px 12px rgba(2, 6, 23, 0.08);
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10px 100%, 0 calc(100% - 10px));
            /* remove heavy blur/backdrop for crisper text */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            min-width: 60px;
            text-align: center;
            max-width: 96px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-shadow: none;
            background-clip: padding-box;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
        }

        .card-domain::before {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-top: 6px solid currentColor;
            opacity: 0.7;
            filter: brightness(0.7);
        }

        .card-domain::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 50%, transparent 100%);
            pointer-events: none;
            clip-path: inherit;
        }

        .api-card:hover .card-domain {
            /* make the right top corner of card domain stays inside the card when hovered */
            border-color: rgba(15, 118, 110, 0.2);
            box-shadow: 0 8px 16px rgba(2, 6, 23, 0.12);
            filter: brightness(1.03) saturate(1.03);
            transform: translateY(-1px);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
        }

        .card-row {
            display: flex;
            justify-content: center;
            gap: 14px;
            width: 100%;
            flex-wrap: nowrap;
            margin-bottom: 6px;
            position: relative;
        }

        .api-card:hover .card-title {
            color: #0f766e;
            transform: translateY(-1px);
        }

        /* HTTP Method indicators */
        .method-indicators {
            position: absolute;
            bottom: 16px;
            left: 16px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: calc(100% - 32px);
        }

        .method-badge {
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            border: 1px solid;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            transition: transform 0.2s ease;
        }

        .method-badge:hover {
            transform: scale(1.1);
        }

        .method-badge.get {
            background: rgba(34, 197, 94, 0.9);
            color: white;
            border-color: #16a34a;
        }

        .method-badge.post {
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border-color: #2563eb;
        }

        .method-badge.put {
            background: rgba(245, 158, 11, 0.9);
            color: white;
            border-color: #d97706;
        }

        .method-badge.patch {
            background: rgba(168, 85, 247, 0.9);
            color: white;
            border-color: #7c3aed;
        }

        .method-badge.delete {
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-color: #dc2626;
        }

        /* Method indicators for hexagons */
        .hexagon-method-indicators {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%) rotate(-30deg);
            display: flex;
            gap: 2px;
            z-index: 20;
        }

        .hexagon-method-badge {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .hexagon-method-badge.get {
            background: #22c55e;
        }

        .hexagon-method-badge.post {
            background: #3b82f6;
        }

        .hexagon-method-badge.put {
            background: #f59e0b;
        }

        .hexagon-method-badge.patch {
            background: #a855f7;
        }

        .hexagon-method-badge.delete {
            background: #ef4444;
        }







        /* View container management */
        .hexagon-container.view-hexagon .hexagon-grid {
            display: flex;
        }

        .hexagon-container.view-card .hexagon-grid {
            display: none;
        }

        /* Responsive design for views - 6 cards per row on wide screens */
        @media (max-width: 1600px) {
            .api-card {
                width: 175px;
                height: 175px;
                padding: 20px 16px;
            }

            .card-icon {
                width: 64px;
                height: 64px;
                font-size: 2rem;
            }

            .card-title {
                font-size: 1rem;
            }

            .card-domain {
                font-size: 0.6rem;
                padding: 5px 10px 5px 8px;
            }

            .card-grid {
                padding: 0 20px;
                gap: 16px;
            }
        }

        @media (max-width: 1400px) {
            .api-card {
                width: 165px;
                height: 165px;
                padding: 18px 14px;
            }

            .card-icon {
                width: 60px;
                height: 60px;
                font-size: 1.9rem;
            }

            .card-title {
                font-size: 0.95rem;
            }

            .card-grid {
                gap: 14px;
                padding: 0 16px;
            }
        }

        @media (max-width: 1200px) {

            /* Still 6 cards per row but smaller on medium screens */
            .api-card {
                width: 155px;
                height: 155px;
                padding: 16px 12px;
            }

            .card-icon {
                width: 58px;
                height: 58px;
                font-size: 1.8rem;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-grid {
                gap: 12px;
                padding: 0 16px;
            }
        }

        @media (max-width: 1000px) {

            /* Show 4 cards per row on medium screens */
            .api-card {
                width: calc(25% - 14px);
                min-width: 160px;
                height: 160px;
            }
        }

        @media (max-width: 800px) {

            /* Show 3 cards per row on smaller screens */
            .api-card {
                width: calc(33.33% - 16px);
                min-width: 150px;
                height: 150px;
            }

            .card-icon {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }

            .card-grid {
                padding: 0 16px;
                gap: 14px;
            }
        }

        @media (max-width: 600px) {

            /* Show 2 cards per row on mobile */
            .api-card {
                width: calc(50% - 12px);
                min-width: 140px;
                height: 140px;
                padding: 16px 12px;
            }

            .card-icon {
                width: 56px;
                height: 56px;
                font-size: 1.6rem;
            }

            .card-title {
                font-size: 0.85rem;
            }

            .card-domain {
                font-size: 0.55rem;
                padding: 4px 8px 4px 6px;
            }

            .card-grid {
                gap: 12px;
            }

            .card-view {
                padding: 20px 12px;
            }
        }

        @media (max-width: 450px) {

            /* Single column on very small screens */
            .api-card {
                width: calc(100% - 16px);
                max-width: 320px;
                height: 140px;
                margin: 10px 0;
                padding: 18px;
            }

            .card-icon {
                width: 56px;
                height: 56px;
                font-size: 1.5rem;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-domain {
                font-size: 0.6rem;
                padding: 4px 8px 4px 6px;
                top: 14px;
                right: 14px;
            }

            .card-view {
                padding: 16px 8px;
            }

            .card-grid {
                padding: 0 8px;
                gap: 12px;
            }

            .endpointFilterBar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-slate-50 to-slate-200 min-h-screen">
    <header>
        <div class="header-content">
            <div class="brand"><img src="./logo.png" alt="saham Logo" class="hover-lift" />
                <div class="brand-text">API's DOCUMENTATION</div>
            </div>
            <div class="controls">
                <!-- Hexagonal Home Button (shown only in documentation view) -->
                <button id="hexagonalHomeButton" class="hexagonal-home-btn" style="display: none;"
                    title="Back to API Grid">
                    <i class="fas fa-th"></i>
                    <span>Home</span>
                </button>



                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" id="apiSearch" placeholder="Search APIs..." class="focus-ring hover-lift" />
                    <i class="fas fa-times clear-search-icon" id="clearSearch" style="display: none;"></i>
                    <div id="autocomplete-list" style="display: none;"></div>
                </div>
                
                <!-- Domain Filter Dropdown (new per manager request) -->
                <div class="dropdown-container">
                    <i class="fas fa-layer-group dropdown-icon"></i>
                    <div id="domainDropdown" class="dropdown-button focus-ring hover-lift" tabindex="0">
                        <span id="domainDropdownText">All Domains</span>
                    </div>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                    <div id="domainDropdownList" class="dropdown-list">
                        <!-- Domain options will be populated here -->
                    </div>
                </div>
                
                <!-- Domain Filter Chips Container (new per manager request) -->
                <div id="navbarDomainFilters" style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                    <!-- Domain chips will be added here dynamically -->
                </div>
                
                <!-- Filter Settings Dropdown -->
                <div class="dropdown-container" style="position: relative;">
                    <button class="hexagonal-home-btn" id="filterSettingsBtn" title="Filter Settings">
                        <i class="fas fa-filter"></i>
                    </button>
                    <div id="filterSettingsDropdown" class="dropdown-list" style="display: none; position: absolute; right: 0; top: 100%; margin-top: 8px; min-width: 280px; max-width: 400px; background: white; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.15); padding: 12px; z-index: 1000;">
                        <!-- Action Buttons -->
                        <button id="navbarClearFilters" style="width: 100%; display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 600; margin-bottom: 8px; transition: all 0.2s;" title="Clear all filters">
                            <i class="fas fa-times"></i>
                            <span>Clear Filters</span>
                        </button>
                        <button id="navbarToggleSaveFilters" style="width: 100%; display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: linear-gradient(135deg, #0f766e 0%, #0d9488 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: 600; margin-bottom: 12px; transition: all 0.2s;" title="Toggle filter saving">
                            <i class="fas fa-save"></i>
                            <span id="navbarSaveBtnText">Save: OFF</span>
                        </button>
                        
                        <!-- Filters Section -->
                        <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
                            <div id="filterSection1Title" style="font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: #64748b; margin-bottom: 8px; padding-left: 4px;">Filter by Domain</div>
                            <div id="filterDropdownDomainChips" style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <!-- Domain/Method chips will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Tags Section (for endpoint view only) -->
                        <div id="filterTagsSection" style="display: none; border-top: 1px solid #e5e7eb; padding-top: 12px; margin-top: 12px;">
                            <div style="font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: #64748b; margin-bottom: 8px; padding-left: 4px;">Filter by Tag</div>
                            <div id="filterDropdownTagChips" style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <!-- Tag chips will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- View Switcher -->
                <div class="view-switcher" id="viewSwitcher">
                    <button class="view-btn active" data-view="hexagon" title="Hexagon Grid View">
                        <svg fill="#ffffff" height="200px" width="200px" version="1.1" id="Capa_1"
                            xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                            viewBox="-5.2 -5.2 50.43 50.43" xml:space="preserve" stroke="#ffffff"
                            stroke-width="0.40029000000000003">
                            <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                            <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"
                                stroke="#6c6c6c" stroke-width="1.20087">
                                <g>
                                    <g id="b123_geometrical_shape">
                                        <path
                                            d="M34.408,10.246L23.48,10.367l-5.359,9.527l5.572,9.402l10.928-0.123l5.359-9.525L34.408,10.246z M33.661,27.551 l-9.043,0.104l-4.61-7.781l4.434-7.883l9.043-0.102l4.609,7.779L33.661,27.551z">
                                        </path>
                                        <path
                                            d="M16.549,18.932l5.357-9.527L16.334,0L5.406,0.125L0.049,9.65l5.57,9.402L16.549,18.932z M6.365,1.746l9.047-0.102 l4.607,7.781l-4.432,7.883l-9.044,0.104L1.936,9.629L6.365,1.746z">
                                        </path>
                                        <path
                                            d="M5.644,21.098l-5.358,9.525l5.57,9.406l10.93-0.123l5.357-9.527l-5.571-9.406L5.644,21.098z M15.823,38.283l-9.044,0.104 L2.17,30.602l4.433-7.881l9.046-0.105l4.607,7.783L15.823,38.283z">
                                        </path>
                                    </g>
                                    <g id="Capa_1_81_"> </g>
                                </g>
                            </g>
                            <g id="SVGRepo_iconCarrier">
                                <g>
                                    <g id="b123_geometrical_shape">
                                        <path
                                            d="M34.408,10.246L23.48,10.367l-5.359,9.527l5.572,9.402l10.928-0.123l5.359-9.525L34.408,10.246z M33.661,27.551 l-9.043,0.104l-4.61-7.781l4.434-7.883l9.043-0.102l4.609,7.779L33.661,27.551z">
                                        </path>
                                        <path
                                            d="M16.549,18.932l5.357-9.527L16.334,0L5.406,0.125L0.049,9.65l5.57,9.402L16.549,18.932z M6.365,1.746l9.047-0.102 l4.607,7.781l-4.432,7.883l-9.044,0.104L1.936,9.629L6.365,1.746z">
                                        </path>
                                        <path
                                            d="M5.644,21.098l-5.358,9.525l5.57,9.406l10.93-0.123l5.357-9.527l-5.571-9.406L5.644,21.098z M15.823,38.283l-9.044,0.104 L2.17,30.602l4.433-7.881l9.046-0.105l4.607,7.783L15.823,38.283z">
                                        </path>
                                    </g>
                                    <g id="Capa_1_81_"> </g>
                                </g>
                            </g>
                        </svg>
                    </button>
                    <button class="view-btn" data-view="card" title="Card View">
                        <svg fill="#ffffff" width="171px" height="171px" viewBox="0 0 256.00 256.00" id="Flat"
                            xmlns="http://www.w3.org/2000/svg" stroke="#ffffff" stroke-width="5.632">
                            <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                            <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"
                                stroke="#020202" stroke-width="12.288">
                                <path
                                    d="M112,44H48a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,112,44Zm-4,64H52V52h56ZM208,44H144a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,208,44Zm-4,64H148V52h56Zm-92,32H48a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,112,140Zm-4,64H52V148h56Zm100-64H144a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,208,140Zm-4,64H148V148h56Z">
                                </path>
                            </g>
                            <g id="SVGRepo_iconCarrier">
                                <path
                                    d="M112,44H48a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,112,44Zm-4,64H52V52h56ZM208,44H144a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4h64a4,4,0,0,0,4-4V48A4,4,0,0,0,208,44Zm-4,64H148V52h56Zm-92,32H48a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,112,140Zm-4,64H52V148h56Zm100-64H144a4,4,0,0,0-4,4v64a4.0002,4.0002,0,0,0,4,4h64a4.0002,4.0002,0,0,0,4-4V144A4,4,0,0,0,208,140Zm-4,64H148V148h56Z">
                                </path>
                            </g>
                        </svg> </button>
                </div>
            </div>
        </div>
    </header>



    <!-- Hexagonal Landing Page -->
    <div id="hexagonContainer" class="hexagon-container">
        <!-- Title removed per manager request - more space for APIs -->
        
        <div id="hexagonGrid" class="hexagon-grid">
            <!-- Hexagons will be dynamically generated here -->
        </div>

        <!-- Card View Container -->
        <div id="cardView" class="card-view">
            <div id="cardGrid" class="card-grid">
                <!-- Cards will be dynamically generated here -->
            </div>
        </div>


    </div>

    <!-- Hover filter removed per manager request - filters moved to navbar -->

    <!-- Swagger UI Container -->
    <div id="swagger-ui">
    </div>

    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js" charset="UTF-8"></script>
    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-standalone-preset.js" charset="UTF-8"></script>
    <script>    
        // ============================================================
        // CRITICAL: Preserve hash immediately on script execution
        // This must be the FIRST thing that runs to prevent hash loss
        // ============================================================
        (function() {
            const initialHash = window.location.hash;
            console.log('🔐 EARLY HASH CHECK (before anything else):', initialHash);
            
            // Store hash in a global variable that won't be cleared
            window.__INITIAL_HASH__ = initialHash;
            
            // If hash exists but will be lost due to redirects, store it
            if (initialHash && initialHash.startsWith('#/api/')) {
                console.log('🔒 Preserving hash in sessionStorage:', initialHash);
                sessionStorage.setItem('__PRESERVED_HASH__', initialHash);
            }
        })();
        
        // Track if we're handling a popstate event (back/forward navigation)
        let isHandlingPopstate = false;
        
        // Track only the LAST clicked API (persisted in localStorage)
        let lastClickedApi = null;
        
        // Load last clicked API from localStorage
        function loadLastClickedApi() {
            try {
                const stored = localStorage.getItem('lastClickedApi');
                if (stored) {
                    lastClickedApi = stored;
                    console.log('📋 Loaded last clicked API from localStorage:', lastClickedApi);
                }
            } catch (e) {
                console.warn('⚠️ Failed to load last clicked API:', e);
            }
        }
        
        // Save last clicked API to localStorage
        function saveLastClickedApi(apiUrl) {
            try {
                lastClickedApi = apiUrl;
                localStorage.setItem('lastClickedApi', apiUrl);
                console.log('✅ Saved last clicked API:', apiUrl);
            } catch (e) {
                console.warn('⚠️ Failed to save last clicked API:', e);
            }
        }
        
        // URL/View synchronization checker
        let urlSyncInterval = null;
        
        function startUrlViewSync() {
            // Clear any existing interval
            if (urlSyncInterval) clearInterval(urlSyncInterval);
            
            console.log('▶️ Starting URL/View sync monitor (checking every 50ms)');
            
            // Check every 50ms if URL matches view state (very frequent)
            urlSyncInterval = setInterval(() => {
                const currentPath = window.location.pathname;
                const currentHash = window.location.hash;
                
                // CASE 1: Landing page shown but URL has hash - CLEAN IT
                if (isLandingPage && currentHash) {
                    console.log('⚠️ [SYNC] Landing page + hash detected:', currentHash, '- FORCE CLEANING');
                    sessionStorage.removeItem('__PRESERVED_HASH__');
                    sessionStorage.removeItem('currentApiUrl');
                    sessionStorage.removeItem('currentApiName');
                    sessionStorage.removeItem('viewState');
                    window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                }
                // CASE 2: API doc shown but URL is home - should not happen but handle it
                else if (!isLandingPage && !currentHash && currentPath === '/') {
                    console.log('⚠️ [SYNC] API doc shown but URL is home - showing landing page');
                    showLandingPage();
                }
            }, 50); // Very fast check - every 50ms
        }
        
        let allApis = [];
        let ui;
        let isLandingPage = true;
        let activeDomains = new Set(); // Track active domain filters
        let apisByDomain = {}; // Cache APIs grouped by domain
        let shouldSaveFilters = false; // Global flag to control filter persistence

        // Endpoint filtering (for Swagger UI view)
        let activeEndpointMethods = new Set(); // Track active HTTP method filters in endpoint view
        let currentApiEndpoints = []; // Store current API endpoints for filtering
        let endpointFilteringEnabled = false; // Track if endpoint filtering is active

        // View management
        let currentView = 'hexagon'; // Track current view: 'hexagon', 'card'

        // View switching functions
        function switchView(viewType) {
            if (currentView === viewType) return;

            console.log(`🔄 Switching from ${currentView} to ${viewType} view`);

            // Check if all required elements exist
            const requiredElements = ['hexagonGrid', 'cardView'];
            const missingElements = requiredElements.filter(id => !document.getElementById(id));

            if (missingElements.length > 0) {
                console.error(`❌ Missing view elements: ${missingElements.join(', ')}`);
                return;
            }

            // Update view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-view') === viewType) {
                    btn.classList.add('active');
                }
            });

            // Update container classes
            const container = document.getElementById('hexagonContainer');
            container.className = `hexagon-container view-${viewType}`;

            // Remove active class from all views
            document.getElementById('hexagonGrid').style.display = 'none';
            document.getElementById('cardView').classList.remove('active');

            // Show selected view
            currentView = viewType;

            switch (viewType) {
                case 'hexagon':
                    document.getElementById('hexagonGrid').style.display = 'flex';
                    renderHexagonView(); // This will consider both search and domain filters
                    console.log("✅ Hexagon view activated");
                    break;
                case 'card':
                    document.getElementById('cardView').classList.add('active');
                    renderCardView(); // This will consider both search and domain filters
                    console.log("✅ Card view activated");
                    break;
                default:
                    console.error(`❌ Unknown view type: ${viewType}`);
                    return;
            }

            // Save view preference
            localStorage.setItem('preferred-view', viewType);
            console.log(`💾 Saved view preference: ${viewType}`);
        }

        function getVisibleApis() {
            console.log("🔍 Getting visible APIs...");
            console.log(`🔍 Total APIs: ${allApis.length}`);

            const filtered = allApis.filter(api => {
                const hexElement = document.querySelector(`[data-api-name="${api.name}"]`);
                if (!hexElement) {
                    console.log(`⚠️ No hex element found for API: ${api.name}`);
                    return true; // Include if no hex element found (fallback)
                }

                const isVisible = !hexElement.classList.contains('filtered-out') && !hexElement.classList.contains('domain-filtered-out');
                return isVisible;
            });

            console.log(`🔍 Visible APIs: ${filtered.length}`);
            return filtered;
        }

        // NEW: Unified function to apply filters and render
        function filterAndRenderAPIs() {
            switch (currentView) {
                case 'hexagon':
                    renderHexagonView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                default:
                    renderHexagonView();
                    break;
            }
        }
        
        function renderCardView() {
            console.log("🗃️ Rendering card view...");

            // Get current search query
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Get filtered APIs based on domain and search filters
            const visibleApis = allApis.filter(api => {
                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // NEW: Check domain filter - respect navbar dropdown selection
                let matchesDomain;
                if (selectedDomain) {
                    // If a specific domain is selected in dropdown, only show that domain
                    matchesDomain = domain === selectedDomain;
                } else {
                    // If "All Domains" selected, apply chip filters if any
                    matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);
                }

                // Check search filter - searches domain name and API name
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                return matchesDomain && matchesSearch;
            });

            console.log(`🗃️ Card view: Found ${visibleApis.length} visible APIs (search: "${searchQuery}", domain: "${selectedDomain || 'All'}", chips: ${Array.from(activeDomains).join(', ')})`);

            renderCardViewWithTransitions(visibleApis);

            // Update counter for card view
            updateViewCounter(visibleApis.length, searchQuery);
        }

        function renderCardViewWithTransitions(apis) {
            const cardGrid = document.getElementById('cardGrid');

            // Clear existing cards immediately (no fade out)
            cardGrid.innerHTML = '';

            // Render new cards immediately
            renderNewCards(apis);
        }

        function renderNewCards(apis) {
            const cardGrid = document.getElementById('cardGrid');

            // Clear existing content
            cardGrid.innerHTML = '';

            // Get current search query for highlighting
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // COPY HEXAGONAL VIEW LOGIC - Calculate optimal sizing based on number of APIs and screen size
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight - 300;
            const apiCount = apis.length;
            
            let maxItemsPerRow;
            let cardWidth;

            // Determine items per row and size based on API count and screen width (SAME AS HEXAGONAL VIEW)
            if (apiCount <= 12) {
                maxItemsPerRow = screenWidth >= 1600 ? 5 : screenWidth >= 1200 ? 4 : 3;
                cardWidth = screenWidth >= 1600 ? 240 : 220;
            } else if (apiCount <= 24) {
                maxItemsPerRow = screenWidth >= 1600 ? 6 : screenWidth >= 1200 ? 5 : 4;
                cardWidth = screenWidth >= 1600 ? 220 : 200;
            } else if (apiCount <= 48) {
                maxItemsPerRow = screenWidth >= 1600 ? 7 : screenWidth >= 1200 ? 6 : 5;
                cardWidth = screenWidth >= 1600 ? 200 : 180;
            } else {
                // Lots of APIs - alternating 11 and 10 cards per row (SAME AS HEXAGONAL VIEW)
                maxItemsPerRow = screenWidth >= 1600 ? 11 : screenWidth >= 1200 ? 9 : 8;
                cardWidth = screenWidth >= 1600 ? 155 : 135;
            }

            const cardHeight = cardWidth;
            const horizontalGap = 14;
            const oddRowOffset = -10;

            // Build rows with alternating pattern (11, 10, 11, 10...) - EXACT COPY OF HEXAGONAL LOGIC
            let apiIndex = 0;
            let rowIndex = 0;
            
            while (apiIndex < apis.length) {
                const row = document.createElement('div');
                row.className = 'card-row';
                row.style.gap = `${horizontalGap}px`;
                row.style.display = 'flex';
                row.style.justifyContent = 'center';
                row.style.position = 'relative';
                row.style.marginBottom = '14px';
                
                // Alternate between maxItemsPerRow and (maxItemsPerRow - 1)
                // Even rows (0, 2, 4...) get maxItemsPerRow (11) - no offset
                // Odd rows (1, 3, 5...) get maxItemsPerRow - 1 (10) - offset for alignment
                const itemsPerRow = rowIndex % 2 === 0 ? maxItemsPerRow : (maxItemsPerRow - 1);
                const itemsInRow = Math.min(itemsPerRow, apis.length - apiIndex);
                
                // Apply offset to odd rows (SAME AS HEXAGONAL VIEW)
                if (rowIndex % 2 === 1) {
                    row.style.transform = `translateX(${oddRowOffset}px)`;
                } else {
                    row.style.transform = 'none';
                }

                // Add cards to this row
                for (let i = 0; i < itemsInRow; i++) {
                    const api = apis[apiIndex];
                    const serviceName = extractServiceName(api.name);
                    const domain = extractDomain(api.name);
                    const icon = getApiIcon(api.name);
                    const domainColors = getDomainColor(domain);

                    // Apply highlighting if there's a search query
                    const displayName = searchQuery ? highlightMatch(serviceName, searchQuery) : serviceName;

                    const card = document.createElement('div');
                    card.className = 'api-card';
                    card.style.width = `${cardWidth}px`;
                    card.style.height = `${cardHeight}px`;

                    // Start with hidden state for animation
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.8) translateY(20px)';
                    card.style.transition = 'opacity 0.4s ease, transform 0.4s ease';

                    card.innerHTML = `
                <div class="card-content">
                    <div class="card-icon">
                        <i class="${icon}"></i>
                    </div>
                    <div class="card-info">
                        <h3 class="card-title" data-text="${serviceName}">${displayName}</h3>
                    </div>
                </div>
                <div class="card-domain" style="background: ${domainColors.bg}; color: ${domainColors.text};">${domain}</div>
            `;
                    
                    // Auto-resize text to fit with better minimum size
                    setTimeout(() => {
                        const titleElement = card.querySelector('.card-title');
                        const cardContent = card.querySelector('.card-content');
                        if (titleElement && cardContent) {
                            const maxWidth = cardWidth * 0.88; // 88% of card width for better fit
                            let fontSize = 1.05; // Start with 1.05rem for more consistent sizing
                            titleElement.style.fontSize = fontSize + 'rem';
                            
                            while (titleElement.scrollWidth > maxWidth && fontSize > 0.9) {
                                fontSize -= 0.025;
                                titleElement.style.fontSize = fontSize + 'rem';
                            }
                        }
                    }, 50);
                    
                    card.addEventListener('click', () => {
                        // Remove active class from all cards
                        document.querySelectorAll('.api-card').forEach(c => {
                            c.classList.remove('active');
                        });
                        // Add active class to clicked card
                        card.classList.add('active');
                        // Navigate to API
                        navigateToApi(api.url);
                    });
                    
                    // Check if this API is the last clicked one and apply the active class
                    if (lastClickedApi === api.url) {
                        card.classList.add('active');
                    }
                    
                    row.appendChild(card);
                    apiIndex++;
                }

                cardGrid.appendChild(row);
                rowIndex++;
            }

            // Trigger fade-in animation with staggered timing
            requestAnimationFrame(() => {
                const newCards = cardGrid.querySelectorAll('.api-card');
                newCards.forEach((card, index) => {
                    card.style.transitionDelay = `${index * 0.05}s`;
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1) translateY(0)';
                    }, 50);
                });
            });

            console.log("✅ Card view rendered successfully with transitions");
        }



        // Cache functions for domain filters
        function saveDomainFilters() {
            if (!shouldSaveFilters) {
                console.log("💾 Filter saving disabled, skipping save");
                return;
            }
            const filtersArray = Array.from(activeDomains);
            localStorage.setItem('activedomainFilters', JSON.stringify(filtersArray));
            console.log("💾 Saved domain filters:", filtersArray);
        }

        function loadDomainFilters() {
            try {
                const savedFilters = localStorage.getItem('activedomainFilters');
                if (savedFilters) {
                    const filtersArray = JSON.parse(savedFilters);
                    activeDomains = new Set(filtersArray);
                    console.log("📂 Loaded domain filters:", filtersArray);
                    return filtersArray.length > 0;
                }
            } catch (error) {
                console.warn("⚠️ Failed to load domain filters:", error);
            }
            return false;
        }

        function clearDomainFiltersCache() {
            localStorage.removeItem('activedomainFilters');
            console.log("🗑️ Cleared domain filters cache");
        }

        // Save and load functions for endpoint filters
        function saveEndpointFilters() {
            if (!shouldSaveFilters) {
                console.log("💾 Filter saving disabled, skipping endpoint filters save");
                return;
            }
            try {
                // Get current API URL to make filters API-specific
                const currentApiUrl = sessionStorage.getItem('currentApiUrl') || 'default';
                const methodsKey = `activeEndpointMethods_${currentApiUrl}`;
                const tagsKey = `activeEndpointTags_${currentApiUrl}`;
                
                const methodsArray = Array.from(activeEndpointMethods);
                const tagsArray = Array.from(activeEndpointTags);
                localStorage.setItem(methodsKey, JSON.stringify(methodsArray));
                localStorage.setItem(tagsKey, JSON.stringify(tagsArray));
                console.log("💾 Saved endpoint filters for API:", currentApiUrl, "- methods:", methodsArray, "tags:", tagsArray);
            } catch (error) {
                console.warn("⚠️ Failed to save endpoint filters:", error);
            }
        }

        function loadEndpointFilters() {
            if (!shouldSaveFilters) {
                console.log("💾 Filter saving disabled, skipping endpoint filters restore");
                return false;
            }
            try {
                // Get current API URL to load API-specific filters
                const currentApiUrl = sessionStorage.getItem('currentApiUrl') || 'default';
                const methodsKey = `activeEndpointMethods_${currentApiUrl}`;
                const tagsKey = `activeEndpointTags_${currentApiUrl}`;
                
                const savedMethods = localStorage.getItem(methodsKey);
                const savedTags = localStorage.getItem(tagsKey);
                let hasFilters = false;
                
                // Clear existing filters first
                activeEndpointMethods.clear();
                activeEndpointTags.clear();
                
                if (savedMethods) {
                    const methodsArray = JSON.parse(savedMethods);
                    methodsArray.forEach(m => activeEndpointMethods.add(m));
                    console.log("📂 Loaded endpoint methods for API:", currentApiUrl, methodsArray);
                    hasFilters = true;
                }
                
                if (savedTags) {
                    const tagsArray = JSON.parse(savedTags);
                    tagsArray.forEach(t => activeEndpointTags.add(t));
                    console.log("📂 Loaded endpoint tags for API:", currentApiUrl, tagsArray);
                    hasFilters = true;
                }
                
                if (hasFilters) {
                    console.log("✅ Endpoint filters loaded successfully for API:", currentApiUrl, "- Methods:", Array.from(activeEndpointMethods), "Tags:", Array.from(activeEndpointTags));
                } else {
                    console.log("ℹ️ No saved filters found for API:", currentApiUrl);
                }
                
                return hasFilters;
            } catch (error) {
                console.warn("⚠️ Failed to load endpoint filters:", error);
                return false;
            }
        }

        function clearEndpointFiltersCache() {
            // Get current API URL to clear API-specific filters
            const currentApiUrl = sessionStorage.getItem('currentApiUrl') || 'default';
            const methodsKey = `activeEndpointMethods_${currentApiUrl}`;
            const tagsKey = `activeEndpointTags_${currentApiUrl}`;
            
            localStorage.removeItem(methodsKey);
            localStorage.removeItem(tagsKey);
            console.log("🗑️ Cleared endpoint filters cache for API:", currentApiUrl);
        }

        // Toggle filter saving on/off
        function toggleFilterSaving() {
            shouldSaveFilters = !shouldSaveFilters;
            localStorage.setItem('shouldSaveFilters', shouldSaveFilters ? '1' : '0');
            
            // Update button UI
            const btn = document.getElementById('panelToggleSaveFilters');
            const btnText = document.getElementById('saveBtnText');
            if (btn && btnText) {
                if (shouldSaveFilters) {
                    btnText.textContent = 'Save Filters: ON';
                    btn.style.background = 'rgba(15, 118, 110, 0.2)';
                    btn.style.color = 'rgb(15, 118, 110)';
                    btn.style.borderColor = 'rgba(15, 118, 110, 0.5)';
                    // Save current filters immediately when enabled
                    saveDomainFilters();
                } else {
                    btnText.textContent = 'Save Filters: OFF';
                    btn.style.background = 'rgba(156, 163, 175, 0.1)';
                    btn.style.color = 'rgb(107, 114, 128)';
                    btn.style.borderColor = 'rgba(156, 163, 175, 0.3)';
                    // Clear saved filters when disabled
                    clearDomainFiltersCache();
                    clearEndpointFiltersCache();
                }
            }
            console.log(`💾 Filter saving ${shouldSaveFilters ? 'enabled' : 'disabled'}`);
        }

        // Initialize filter saving state from localStorage
        function initializeFilterSaving() {
            try {
                const saved = localStorage.getItem('shouldSaveFilters');
                shouldSaveFilters = saved === '1';
                
                // Update button UI
                const btn = document.getElementById('panelToggleSaveFilters');
                const btnText = document.getElementById('saveBtnText');
                if (btn && btnText) {
                    if (shouldSaveFilters) {
                        btnText.textContent = 'Save Filters: ON';
                        btn.style.background = 'rgba(15, 118, 110, 0.2)';
                        btn.style.color = 'rgb(15, 118, 110)';
                        btn.style.borderColor = 'rgba(15, 118, 110, 0.5)';
                    } else {
                        btnText.textContent = 'Save Filters: OFF';
                        btn.style.background = 'rgba(156, 163, 175, 0.1)';
                        btn.style.color = 'rgb(107, 114, 128)';
                        btn.style.borderColor = 'rgba(156, 163, 175, 0.3)';
                    }
                }
                
                console.log(`💾 Filter saving initialized: ${shouldSaveFilters ? 'ON' : 'OFF'}`);
            } catch (e) {
                console.warn("⚠️ Failed to initialize filter saving state:", e);
            }
        }

        // Global function to reset all filters (can be called from console)
        function resetAllFilters() {
            clearAllDomainFilters();
            clearAllMethodFilters();

            // Clear search input
            const searchInput = document.getElementById('apiSearch');
            if (searchInput) {
                searchInput.value = '';
            }

            // Update view with no filters
            switch (currentView) {
                case 'hexagon':
                    renderHexagonView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                default:
                    applyFiltersDirectly();
                    break;
            }

            console.log("🔄 All filters have been reset");
        }

        // Shared highlighting function
        function highlightMatch(text, query) {
            if (!query || !text) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<span style="background: #fef3c7; color: #92400e; padding: 1px 2px; border-radius: 3px;">$1</span>');
        }

        // Unified function to update API counter with the requested phrasing
        function updateViewCounter(visibleCount, searchQuery = '') {
            const hasSearch = Boolean(searchQuery && searchQuery.trim());
            const hasDomainFilter = activeDomains.size > 0;
            const total = Array.isArray(allApis) ? allApis.length : 0;

            // If there are no filters/search, show the total with arrow
            if (!hasSearch && !hasDomainFilter) {
                updateApiCounter(total, `APIs Available`, total);
                return;
            }

            // Build domain list text when domains are active
            let domainText = '';
            if (hasDomainFilter) {
                const domains = Array.from(activeDomains);
                if (domains.length === 1) domainText = ` in ${domains[0]}`;
                else domainText = ` in ${domains.join(', ')}`;
            }

            // When filters are active, show "<visible> of <total> APIs Available" and append domains if any
            const message = `of ${total} APIs Available${domainText}`;
            updateApiCounter(visibleCount, message, visibleCount);
        }

        // Dedicated function to update API counter reliably
        // countDisplayed: number to show in the big count; message: the explanatory string
        function updateApiCounter(countDisplayed, message = null, countForScreenReader = null) {
            // Only update the floating panel counter. The header counter has been removed.
            try {
                if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                    const notchMode = window.filterNotchInstance.mode || 'domain';
                    let panelFooter = window.filterNotchInstance.panel.querySelector('.panel-footer');
                    if (!panelFooter) panelFooter = window.filterNotchInstance.panel;

                    const existingPanelCounter = panelFooter.querySelector('#api-filter-counter');

                    if (notchMode === 'domain') {
                        let panelCounter = existingPanelCounter;
                        if (!panelCounter) {
                            panelCounter = document.createElement('div');
                            panelCounter.id = 'api-filter-counter';
                            panelCounter.style.cssText = 'padding: 8px 16px; background: rgba(15, 118, 110, 0.06); border-radius: 12px; color: rgb(15, 118, 110); font-size: 0.9rem; font-weight: 600; text-align: center; margin: 8px 12px; border: 1px solid rgba(15, 118, 110, 0.12);';
                            panelFooter.appendChild(panelCounter);
                        }

                        const compactMsg = (message || 'APIs Available');
                        panelCounter.innerHTML = `<span class="count">${countDisplayed}</span> ${compactMsg}`;
                    } else {
                        if (existingPanelCounter) existingPanelCounter.remove();
                    }
                }
            } catch (e) {
                // ignore if panel not available yet
            }
        }

        // Endpoint filtering functions (for Swagger UI view)
        function initializeEndpointFiltering(spec) {
            console.log("🔄 Initializing endpoint filtering for current API...");

            if (!spec || !spec.paths) {
                console.warn("No paths found in API spec");
                return;
            }

            // Extract all endpoints with their methods
            currentApiEndpoints = [];
            const methodCounts = {};

            Object.keys(spec.paths).forEach(path => {
                const pathObject = spec.paths[path];
                Object.keys(pathObject).forEach(method => {
                    const httpMethod = method.toLowerCase();
                    if (['get', 'post', 'put', 'patch', 'delete', 'options', 'head'].includes(httpMethod)) {
                        const endpoint = {
                            path: path,
                            method: httpMethod,
                            summary: pathObject[method].summary || '',
                            description: pathObject[method].description || '',
                            operationId: pathObject[method].operationId || '',
                            tags: pathObject[method].tags || []
                        };

                        currentApiEndpoints.push(endpoint);
                        methodCounts[httpMethod] = (methodCounts[httpMethod] || 0) + 1;
                    }
                });
            });

            console.log(`Found ${currentApiEndpoints.length} endpoints`, methodCounts);

            // Generate method filter chips for current API
            generateEndpointMethodFilters(methodCounts);

            // If the reusable FilterNotch exists, configure it for endpoint mode so the same UI can be reused.
            // IMPORTANT: only switch the floating panel into endpoint mode when the Swagger UI (API docs)
            // view is actually visible. Switching the panel to endpoint mode while on the landing page
            // would wipe out the domain chips and make the panel show only methods (the "get" tag).
            try {
                const swaggerElEarly = document.getElementById('swagger-ui');
                const swaggerVisibleEarly = swaggerElEarly && swaggerElEarly.classList.contains('show');
                if (window.filterNotchInstance && swaggerVisibleEarly) {
                    // Build method items and tag items so the floating panel can show both groups
                    const methodItems = Object.keys(methodCounts).sort().map(m => ({ key: m, count: methodCounts[m], kind: 'method' }));
                    const tagCounts = {};
                    // Build tagCounts from currentApiEndpoints
                    currentApiEndpoints.forEach(ep => {
                        if (Array.isArray(ep.tags)) {
                            ep.tags.forEach(t => {
                                const tg = String(t || '').trim();
                                if (!tg) return;
                                tagCounts[tg] = (tagCounts[tg] || 0) + 1;
                            });
                        }
                    });
                    const tagItems = Object.keys(tagCounts).sort().map(t => ({ key: t, count: tagCounts[t], kind: 'tag' }));

                    // Also populate legacy tag filters UI if present
                    try { if (Object.keys(tagCounts).length > 0) generateEndpointTagFilters(tagCounts); } catch (e) { }

                    window.filterNotchInstance.setMode('endpoint', {
                        getItems: () => ([...methodItems, ...tagItems]),
                        // onToggle will receive (key, kind) from the panel click handler
                        onToggle: (key, kind) => {
                            try {
                                if (kind === 'tag') {
                                    toggleEndpointTagFilter(key);
                                } else {
                                    const normalized = String(key || '').toLowerCase();
                                    toggleEndpointMethodFilter(normalized);
                                }
                            } catch (e) { /* ignore */ }
                        },
                        onSearch: (query) => {
                            const searchInput = document.getElementById('endpointSearch');
                            if (searchInput) searchInput.value = query;
                            const panelInput = window.filterNotchInstance && window.filterNotchInstance.panel
                                ? window.filterNotchInstance.panel.querySelector('.panel-search-row input')
                                : null;
                            if (panelInput) panelInput.value = query;
                            applyEndpointFilters();
                        },
                        clearCallback: () => {
                            // Clear both HTTP method filters and tag filters, plus the search input.
                            activeEndpointMethods.clear();
                            activeEndpointTags.clear();
                            updateEndpointMethodFilterUI();
                            updateEndpointTagFilterUI();

                            const si = document.getElementById('endpointSearch');
                            if (si) si.value = '';
                            const panelInput = window.filterNotchInstance && window.filterNotchInstance.panel
                                ? window.filterNotchInstance.panel.querySelector('.panel-search-row input')
                                : null;
                            if (panelInput) panelInput.value = '';

                            // Save the cleared state
                            saveEndpointFilters();

                            // Re-apply endpoint filters to update the UI and counters
                            applyEndpointFilters();
                        }
                    });
                }
            } catch (e) {
                console.warn('Could not configure FilterNotch for endpoint mode', e);
            }

            // Show the endpoint filter bar, but only when the Swagger UI (API documentation) view is visible.
            // This prevents the filter bar from appearing on the landing / APIs grid.
            // Enable endpoint filtering when the Swagger UI is visible; rely on the floating panel for UI
            const swaggerEl = document.getElementById('swagger-ui');
            const swaggerVisible = swaggerEl && swaggerEl.classList.contains('show');
            if (swaggerVisible) {
                endpointFilteringEnabled = true;
                console.log("✅ Endpoint filtering enabled (API doc view)");
                setSwaggerUiPaddingForFilterBar(true);
                
                // Update navbar dropdown to show endpoint tags instead of domains
                populateNavbarEndpointTagsDropdown();
            } else {
                endpointFilteringEnabled = false;
                console.log("ℹ️ Endpoint filtering prepared but hidden (not in API doc view)");
                setSwaggerUiPaddingForFilterBar(false);
            }

            // Set up endpoint search and filtering
            setupEndpointSearch();

            // Ensure endpoint filters are applied immediately so the endpoint counter is created/visible
            try {
                // apply filters now and again shortly after to catch timing when Swagger UI renders opblocks
                if (endpointFilteringEnabled) applyEndpointFilters();
                setTimeout(() => { try { if (endpointFilteringEnabled) applyEndpointFilters(); } catch (e) { } }, 300);
            } catch (e) { /* ignore */ }
        }

        function generateEndpointMethodFilters(methodCounts) {

            const filterContainer = document.getElementById('endpointMethodFilters');
            // If the legacy endpointMethodFilters element is missing (we now use the floating panel), skip DOM updates here.
            if (!filterContainer) return;

            // Clear any existing content and event listeners
            filterContainer.innerHTML = '';

            Object.keys(methodCounts).sort().forEach(method => {
                const count = methodCounts[method];
                const chip = document.createElement('div');
                chip.className = 'endpoint-method-chip';
                chip.dataset.method = method;
                // Use dedicated class for HTTP method count so it doesn't inherit
                // domain tag styles. We avoid reusing the generic 'chip-count'.
                chip.innerHTML = `${method.toUpperCase()} <span class="http-chip-count" data-method="${method}">${count}</span>`;

                // Use a more robust click handler
                chip.onclick = function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    const clickedMethod = this.dataset.method;
                    toggleEndpointMethodFilter(clickedMethod);
                };

                chip.title = `Show only ${method.toUpperCase()} endpoints (${count} found)`;
                filterContainer.appendChild(chip);
            });


        }

        // Generate endpoint tag filters for legacy container (if present)
        function generateEndpointTagFilters(tagCounts) {
            const filterContainer = document.getElementById('endpointTagFilters');
            if (!filterContainer) return;

            filterContainer.innerHTML = '';

            Object.keys(tagCounts).sort().forEach(tag => {
                const count = tagCounts[tag];
                const chip = document.createElement('div');
                chip.className = 'endpoint-tag-chip domain-chip';
                chip.dataset.tag = tag;
                chip.innerHTML = `${tag} <span class="chip-count">${count}</span>`;

                chip.onclick = function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    toggleEndpointTagFilter(tag);
                };

                chip.title = `Filter by tag: ${tag} (${count})`;
                filterContainer.appendChild(chip);
            });
        }

        // Toggle endpoint tag filtering (keeps a separate set on activeEndpointTags)
        const activeEndpointTags = new Set();
        function toggleEndpointTagFilter(tag) {
            if (activeEndpointTags.has(tag)) activeEndpointTags.delete(tag); else activeEndpointTags.add(tag);
            saveEndpointFilters();
            updateEndpointTagFilterUI();
            applyEndpointFilters();
        }

        function updateEndpointTagFilterUI() {
            const chips = document.querySelectorAll('.endpoint-tag-chip, .endpoint-chip[data-kind="tag"]');
            chips.forEach(chip => {
                const tag = chip.dataset.tag || chip.dataset.value;
                if (tag && activeEndpointTags.has(tag)) chip.classList.add('active'); else chip.classList.remove('active');
            });
        }

        function setupEndpointSearch() {
            // Support either the legacy top bar input (#endpointSearch) or the floating panel's search input
            let searchInput = document.getElementById('endpointSearch');
            let clearSearchButton = document.getElementById('clearEndpointSearch');

            // If top-level elements are missing, try to find panel input inserted by FilterNotch
            if (!searchInput && window.filterNotchInstance && window.filterNotchInstance.panel) {
                const panelInput = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
                if (panelInput) {
                    searchInput = panelInput;
                    // Do NOT create a clear (x) button for the panel search input — keep UI minimal.
                    // Leaving clearSearchButton null prevents the code below from showing an 'x'.
                }
            }

            if (!searchInput) return; // nothing to wire up

            searchInput.addEventListener('input', function () {
                const query = this.value.trim();
                applyEndpointFilters();

                // Show/hide clear button
                if (clearSearchButton) clearSearchButton.style.display = query ? 'block' : 'none';
            });

            if (clearSearchButton) {
                clearSearchButton.addEventListener('click', function () {
                    searchInput.value = '';
                    clearSearchButton.style.display = 'none';
                    applyEndpointFilters();
                    searchInput.focus();
                });
            }
        }

        /*
         * Ensure Swagger UI content is padded when the endpoint filter bar is visible
         * so the sticky filter does not overlap the API operation list.
         */
        function setSwaggerUiPaddingForFilterBar(show) {
            const swagger = document.getElementById('swagger-ui');
            if (!swagger) return;

            // Prefer legacy filter bar if present, otherwise fall back to floating panel height
            const filterBar = document.getElementById('endpointFilterBar');
            let pad = 0;

            if (filterBar) {
                if (show && filterBar.style.display !== 'none') {
                    pad = filterBar.offsetHeight + 12;
                }
            } else if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                const panel = window.filterNotchInstance.panel;
                // If panel is currently open/visible and we want to show padding, use its height.
                if (show && panel.style.display !== 'none') {
                    pad = panel.offsetHeight + 12;
                }
            }

            if (pad) swagger.style.paddingTop = pad + 'px';
            else swagger.style.paddingTop = '';
        }

        // Enhanced API icons mapping based on actual API categories
        const apiIcons = {
            // Cloud services
            'cloud': 'fas fa-cloud',
            'audit': 'fas fa-clipboard-check',

            // Contract and banking
            'contract': 'fas fa-file-contract',
            'bancassurance': 'fas fa-shield-alt',

            // Data services
            'data': 'fas fa-database',
            'customer-data': 'fas fa-users-cog',

            // Distribution services
            'distribution': 'fas fa-network-wired',
            'appointment': 'fas fa-calendar-check',
            'card-holder': 'fas fa-id-card',
            'ldg': 'fas fa-sitemap',
            'operationaltask': 'fas fa-tasks',

            // Guarantee services
            'garantie': 'fas fa-shield-alt',
            'caution': 'fas fa-handshake',

            // Product services
            'product': 'fas fa-cube',
            'loan': 'fas fa-hand-holding-usd',
            'offer': 'fas fa-gift',
            'term-deposit': 'fas fa-piggy-bank',
            'titre': 'fas fa-certificate',

            // Risk and compliance
            'riskandcompliance': 'fas fa-exclamation-triangle',
            'compliance': 'fas fa-balance-scale',

            // Sales services
            'sales': 'fas fa-chart-line',
            'advice': 'fas fa-lightbulb',
            'after-sale': 'fas fa-tools',
            'feasibility': 'fas fa-search-dollar',
            'opportunity': 'fas fa-bullseye',
            'sale': 'fas fa-shopping-cart',

            // SOGE services
            'soge': 'fas fa-building',

            // Support services
            'support': 'fas fa-headset',
            'av-scanner': 'fas fa-virus-slash',
            'biochecker': 'fas fa-fingerprint',
            'chatbot': 'fas fa-robot',
            'document': 'fas fa-file-alt',
            'exchangerate': 'fas fa-exchange-alt',
            'featuretoggles': 'fas fa-toggle-on',
            'geoloc': 'fas fa-map-marker-alt',
            'ladrad': 'fas fa-cogs',
            'notification': 'fas fa-bell',
            'otp': 'fas fa-key',
            'parcours': 'fas fa-route',
            'pilotage': 'fas fa-tachometer-alt',
            'reclamation': 'fas fa-exclamation-circle',
            'rh': 'fas fa-user-tie',
            'task-management': 'fas fa-clipboard-list',

            // Template services
            'template': 'fas fa-file-code',
            'template-contract': 'fas fa-file-signature',

            // Third party services
            'tiers': 'fas fa-external-link-alt',
            'account': 'fas fa-user-circle',
            'customer': 'fas fa-users',
            'favorite': 'fas fa-heart',
            'prospect': 'fas fa-user-plus',

            // Transaction services
            'transaction': 'fas fa-credit-card',
            'cagnotte': 'fas fa-coins',
            'card': 'fas fa-credit-card',
            'cheque-book': 'fas fa-book',
            'instant-transfer': 'fas fa-bolt',
            'lcn': 'fas fa-file-invoice-dollar',
            'operation-core': 'fas fa-calculator',
            'payment': 'fas fa-money-check-alt',
            'provision': 'fas fa-wallet',
            'token-core': 'fas fa-shield-alt',
            'trade': 'fas fa-chart-area',
            'transfer': 'fas fa-paper-plane',
            'wallet-core': 'fas fa-wallet',

        };

        function getApiIcon(apiName) {
            const name = apiName.toLowerCase();

            // Check for exact matches first
            for (const [key, icon] of Object.entries(apiIcons)) {
                if (name.includes(key)) {
                    return icon;
                }
            }

            // Category-based fallbacks
            if (name.includes('transaction') || name.includes('payment') || name.includes('money')) {
                return 'fas fa-credit-card';
            }
            if (name.includes('support') || name.includes('help')) {
                return 'fas fa-headset';
            }
            if (name.includes('data') || name.includes('customer')) {
                return 'fas fa-database';
            }
            if (name.includes('product') || name.includes('offer')) {
                return 'fas fa-cube';
            }
            if (name.includes('sales') || name.includes('opportunity')) {
                return 'fas fa-chart-line';
            }
            if (name.includes('distribution') || name.includes('network')) {
                return 'fas fa-network-wired';
            }

            return 'fas fa-cog'; // default icon
        }

        // Extract domain from API name (e.g., "cloud/audit/v1" -> "cloud")
        function extractDomain(apiName) {
            const parts = apiName.split('/');
            return parts[0] || 'other';
        }

        // Extract API service name (e.g., "cloud/audit/v1" -> "audit" or "contract/bancassurance-service/v1/api-docs" -> "bancassurance-service")
        function extractServiceName(apiName) {
            const parts = apiName.split('/');
            // Remove "api-docs" if it's the last part
            const filteredApiDocs = parts.filter(part => part !== 'api-docs');
            // Remove version (v1, v2, etc.) from the end
            const filtered = filteredApiDocs.filter(part => !part.match(/^v\d+$/));
            // Return the last non-version, non-api-docs part (the service name)
            return filtered[filtered.length - 1] || apiName;
        }

        // Get domain color scheme
        function getDomainColor(domain) {
            const colors = {
                'cloud': { bg: 'rgba(59, 130, 246, 0.3)', border: 'rgba(59, 130, 246, 0.4)', text: 'rgb(59, 130, 246)' },
                'contract': { bg: 'rgba(168, 85, 247, 0.3)', border: 'rgba(168, 85, 247, 0.4)', text: 'rgb(168, 85, 247)' },
                'data': { bg: 'rgba(34, 197, 94, 0.3)', border: 'rgba(34, 197, 94, 0.4)', text: 'rgb(34, 197, 94)' },
                'distribution': { bg: 'rgba(249, 115, 22, 0.3)', border: 'rgba(249, 115, 22, 0.4)', text: 'rgb(249, 115, 22)' },
                'garantie': { bg: 'rgba(236, 72, 153, 0.3)', border: 'rgba(236, 72, 153, 0.4)', text: 'rgb(236, 72, 153)' },
                'product': { bg: 'rgba(14, 165, 233, 0.3)', border: 'rgba(14, 165, 233, 0.4)', text: 'rgb(14, 165, 233)' },
                'riskandcompliance': { bg: 'rgba(239, 68, 68, 0.3)', border: 'rgba(239, 68, 68, 0.4)', text: 'rgb(239, 68, 68)' },
                'sales': { bg: 'rgba(245, 158, 11, 0.3)', border: 'rgba(245, 158, 11, 0.4)', text: 'rgb(245, 158, 11)' },
                'soge': { bg: 'rgba(99, 102, 241, 0.3)', border: 'rgba(99, 102, 241, 0.4)', text: 'rgb(99, 102, 241)' },
                'support': { bg: 'rgba(20, 184, 166, 0.3)', border: 'rgba(20, 184, 166, 0.4)', text: 'rgb(20, 184, 166)' },
                'template': { bg: 'rgba(139, 92, 246, 0.3)', border: 'rgba(139, 92, 246, 0.4)', text: 'rgb(139, 92, 246)' },
                'tiers': { bg: 'rgba(244, 63, 94, 0.3)', border: 'rgba(244, 63, 94, 0.4)', text: 'rgb(244, 63, 94)' },
                'transaction': { bg: 'rgba(16, 185, 129, 0.3)', border: 'rgba(16, 185, 129, 0.4)', text: 'rgb(16, 185, 129)' },
            };
            return colors[domain.toLowerCase()] || { bg: 'rgba(100, 116, 139, 0.3)', border: 'rgba(100, 116, 139, 0.4)', text: 'rgb(100, 116, 139)' };
        }

        // Group APIs by domain
        function groupApisByDomain(apis) {
            const grouped = {};
            apis.forEach(api => {
                const domain = extractDomain(api.name);
                if (!grouped[domain]) {
                    grouped[domain] = [];
                }
                grouped[domain].push(api);
            });
            return grouped;
        }

        // Generate domain filter chips
        function generateDomainFilters(apis) {
            apisByDomain = groupApisByDomain(apis);
            const domains = Object.keys(apisByDomain).sort();
            
            // Populate navbar domain dropdown (new per manager request)
            populateNavbarDomainDropdown(domains);
            
            // OLD PANEL CODE - Keep for API documentation page if needed
            const filterBar = document.getElementById('filterBar');
            const panelContainer = document.getElementById('panelDomainFilters');
            const notch = document.getElementById('filterNotch');

            // Hide old components - filters now in navbar
            if (filterBar) filterBar.style.display = 'none';
            if (notch) notch.style.display = 'none';
            if (panelContainer) panelContainer.style.display = 'none';
        }
        
        // NEW: Populate navbar domain dropdown per manager request
        function populateNavbarDomainDropdown(domains) {
            const dropdownList = document.getElementById('domainDropdownList');
            if (!dropdownList) return;
            
            dropdownList.innerHTML = '';
            
            // Determine which domains to show based on active filters
            const domainsToShow = activeDomains.size > 0 ? Array.from(activeDomains).sort() : domains;
            
            // Add "All Domains" option only if no filters are active
            if (activeDomains.size === 0) {
                const allOption = document.createElement('div');
                allOption.className = 'dropdown-item';
                allOption.dataset.value = '';
                const totalCount = domains.reduce((sum, d) => sum + (apisByDomain[d]?.length || 0), 0);
                allOption.style.display = 'flex';
                allOption.style.alignItems = 'center';
                allOption.style.justifyContent = 'space-between';
                allOption.style.gap = '12px';
                allOption.innerHTML = `
                    <span style="flex: 1; color: #1f2937; font-weight: 500;">All Domains</span>
                    <span style="display: inline-flex; align-items: center; justify-content: center; min-width: 28px; height: 28px; background: #10b981; color: white; border-radius: 50%; font-size: 0.75rem; font-weight: 700;">${totalCount}</span>
                `;
                allOption.addEventListener('click', () => selectDomainFilter(''));
                dropdownList.appendChild(allOption);
            }
            
            // Add each domain with simple text + green circular count
            domainsToShow.forEach(domain => {
                const count = apisByDomain[domain]?.length || 0;
                const option = document.createElement('div');
                option.className = 'dropdown-item';
                option.dataset.value = domain;
                option.style.display = 'flex';
                option.style.alignItems = 'center';
                option.style.justifyContent = 'space-between';
                option.style.gap = '12px';
                option.innerHTML = `
                    <span style="flex: 1; color: #1f2937; font-weight: 500;">${domain}</span>
                    <span style="display: inline-flex; align-items: center; justify-content: center; min-width: 28px; height: 28px; background: #10b981; color: white; border-radius: 50%; font-size: 0.75rem; font-weight: 700;">${count}</span>
                `;
                option.addEventListener('click', () => selectDomainFilter(domain));
                dropdownList.appendChild(option);
            });
            
            // Only setup interaction once, not every time we populate
            if (!dropdownList.dataset.initialized) {
                setupDomainDropdownInteraction();
                dropdownList.dataset.initialized = 'true';
            }
        }
        
        // NEW: Populate endpoint tags in domain dropdown for API documentation view
        function populateNavbarEndpointTagsDropdown() {
            const dropdownList = document.getElementById('domainDropdownList');
            const dropdownText = document.getElementById('domainDropdownText');
            if (!dropdownList) return;
            
            dropdownList.innerHTML = '';
            
            // Extract tags from current endpoints
            const tagCounts = {};
            if (currentApiEndpoints && currentApiEndpoints.length > 0) {
                currentApiEndpoints.forEach(endpoint => {
                    if (Array.isArray(endpoint.tags)) {
                        endpoint.tags.forEach(tag => {
                            const tagStr = String(tag || '').trim();
                            if (tagStr) {
                                tagCounts[tagStr] = (tagCounts[tagStr] || 0) + 1;
                            }
                        });
                    }
                });
            }
            
            const tags = Object.keys(tagCounts).sort();
            
            // Update dropdown button text
            if (dropdownText) {
                dropdownText.textContent = activeEndpointTags.size > 0 
                    ? `${activeEndpointTags.size} Tag${activeEndpointTags.size > 1 ? 's' : ''} Selected`
                    : 'All Tags';
            }
            
            // Show all tags or only active tags based on filter state
            const tagsToShow = activeEndpointTags.size > 0 ? Array.from(activeEndpointTags).sort() : tags;
            
            tagsToShow.forEach(tag => {
                const count = tagCounts[tag] || 0;
                const option = document.createElement('div');
                option.className = 'dropdown-item';
                option.dataset.value = tag;
                option.style.display = 'flex';
                option.style.alignItems = 'center';
                option.style.justifyContent = 'space-between';
                option.style.gap = '12px';
                option.style.cursor = 'pointer';
                option.innerHTML = `
                    <span style="flex: 1; color: #1f2937; font-weight: 500;">${tag}</span>
                    <span style="display: inline-flex; align-items: center; justify-content: center; min-width: 28px; height: 28px; background: #10b981; color: white; border-radius: 50%; font-size: 0.75rem; font-weight: 700;">${count}</span>
                `;
                option.addEventListener('click', () => {
                    // Scroll to the tag in the Swagger UI
                    scrollToTag(tag);
                    // Close the dropdown
                    dropdownList.classList.remove('show');
                });
                dropdownList.appendChild(option);
            });
            
            // Only setup interaction once, not every time we populate
            if (!dropdownList.dataset.initialized) {
                setupDomainDropdownInteraction();
                dropdownList.dataset.initialized = 'true';
            }
        }
        
        // Scroll to a specific tag in the Swagger UI
        function scrollToTag(tag) {
            try {
                // Find the tag section in Swagger UI
                const tagElements = document.querySelectorAll('.opblock-tag-section');
                for (const element of tagElements) {
                    const tagTitle = element.querySelector('.opblock-tag');
                    if (tagTitle && tagTitle.textContent.trim().toLowerCase().includes(tag.toLowerCase())) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        // Expand the tag if it's collapsed
                        if (!element.classList.contains('is-open')) {
                            const expandButton = element.querySelector('.expand-operation');
                            if (expandButton) {
                                expandButton.click();
                            }
                        }
                        break;
                    }
                }
            } catch (e) {
                console.warn('Could not scroll to tag:', e);
            }
        }
        
        // NEW: Handle domain dropdown interaction
        function setupDomainDropdownInteraction() {
            const dropdownButton = document.getElementById('domainDropdown');
            const dropdownList = document.getElementById('domainDropdownList');
            
            if (!dropdownButton || !dropdownList) return;
            
            // Prevent adding multiple listeners
            if (dropdownButton.dataset.listenerAttached) return;
            dropdownButton.dataset.listenerAttached = 'true';
            
            dropdownButton.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownList.classList.toggle('show');
            });
            
            // Close when clicking outside
            document.addEventListener('click', (e) => {
                if (!dropdownButton.contains(e.target) && !dropdownList.contains(e.target)) {
                    dropdownList.classList.remove('show');
                }
            });
        }
        
        // NEW: Select a domain filter from dropdown
        let selectedDomain = '';
        function selectDomainFilter(domain) {
            selectedDomain = domain;
            const dropdownText = document.getElementById('domainDropdownText');
            const dropdownList = document.getElementById('domainDropdownList');
            
            if (dropdownText) {
                dropdownText.textContent = domain || 'All Domains';
            }
            
            if (dropdownList) {
                dropdownList.classList.remove('show');
            }
            
            // Update active filters
            activeDomains.clear();
            if (domain) {
                activeDomains.add(domain);
            }
            
            // Apply filter
            filterAndRenderAPIs();
            updateNavbarDomainChips();
            
            if (shouldSaveFilters) {
                saveDomainFilters();
            }
        }
        
        // NEW: Update domain chips in navbar (DISABLED - removed domain tags from navbar)
        function updateNavbarDomainChips() {
            // Function disabled - domain tags no longer displayed in navbar
            return;
        }

        /*
         * FilterNotch component: encapsulates notch drag, open/close animations,
         * and a configurable panel that can act in different modes (domain or endpoint).
         */
        class FilterNotch {
            constructor({ notchSelector = '#filterNotch', panelSelector = '#filterPanel' } = {}) {
                this.notch = document.querySelector(notchSelector);
                this.panel = document.querySelector(panelSelector);
                if (!this.notch || !this.panel) return;

                this.mode = 'domain';
                this.config = {};
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                // restore saved position if any
                try {
                    const saved = localStorage.getItem('filterNotchPos');
                    if (saved) {
                        const pos = JSON.parse(saved);
                        this.notch.style.left = pos.left || '';
                        this.notch.style.top = pos.top || '';
                        this.notch.style.right = 'auto';
                    }
                } catch (e) { }

                // bind events
                this._bindDrag();
                // Prevent rapid toggles and rely on class-based state rather than inline styles
                this._lastToggleMs = 0;
                this.notch.addEventListener('click', (e) => {
                    if (this.isDragging) return;
                    const now = Date.now();
                    if (now - this._lastToggleMs < 250) return; // debounce rapid toggles

                    // If panel has explicit 'open' class, close it. If it's currently 'closing', ignore the click.
                    if (this.panel.classList.contains('open')) {
                        this.close();
                        this._lastToggleMs = now;
                        return;
                    }
                    if (this.panel.classList.contains('closing')) {
                        // Ignore clicks while closing animation is in progress
                        return;
                    }

                    // Otherwise open the panel
                    this.open();
                    this._lastToggleMs = now;
                });

                // close button inside panel
                const panelClose = this.panel.querySelector('#panelClose');
                if (panelClose) panelClose.addEventListener('click', () => this.close());

                // clear button
                const panelClear = this.panel.querySelector('#panelClearFilters');
                if (panelClear) panelClear.addEventListener('click', () => {
                    if (this.config.clearCallback) this.config.clearCallback();
                });

                // toggle save filters button
                const toggleSaveBtn = this.panel.querySelector('#panelToggleSaveFilters');
                if (toggleSaveBtn) toggleSaveBtn.addEventListener('click', () => {
                    toggleFilterSaving();
                });
            }

            _bindDrag() {
                const notch = this.notch;
                document.addEventListener('mousedown', (e) => {
                    if (e.target === notch || notch.contains(e.target)) {
                        this.isDragging = true;
                        this.dragOffsetX = e.clientX - notch.getBoundingClientRect().left;
                        this.dragOffsetY = e.clientY - notch.getBoundingClientRect().top;
                        notch.classList.add('dragging');
                        e.preventDefault();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    const left = Math.max(8, Math.min(window.innerWidth - notch.offsetWidth - 8, e.clientX - this.dragOffsetX));
                    const top = Math.max(48, Math.min(window.innerHeight - notch.offsetHeight - 8, e.clientY - this.dragOffsetY));
                    notch.style.left = left + 'px';
                    notch.style.top = top + 'px';
                    notch.style.right = 'auto';
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.notch.classList.remove('dragging');
                        try {
                            const rect = this.notch.getBoundingClientRect();
                            localStorage.setItem('filterNotchPos', JSON.stringify({ left: rect.left + 'px', top: rect.top + 'px' }));
                        } catch (e) { }
                    }
                });

                // touch support
                this.notch.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.isDragging = true;
                    this.dragOffsetX = touch.clientX - this.notch.getBoundingClientRect().left;
                    this.dragOffsetY = touch.clientY - this.notch.getBoundingClientRect().top;
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging) return;
                    const touch = e.touches[0];
                    const left = Math.max(8, Math.min(window.innerWidth - this.notch.offsetWidth - 8, touch.clientX - this.dragOffsetX));
                    const top = Math.max(48, Math.min(window.innerHeight - this.notch.offsetHeight - 8, touch.clientY - this.dragOffsetY));
                    this.notch.style.left = left + 'px';
                    this.notch.style.top = top + 'px';
                    this.notch.style.right = 'auto';
                }, { passive: false });

                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        try {
                            const rect = this.notch.getBoundingClientRect();
                            localStorage.setItem('filterNotchPos', JSON.stringify({ left: rect.left + 'px', top: rect.top + 'px' }));
                        } catch (e) { }
                    }
                });
            }

            setMode(mode, config = {}) {
                this.mode = mode;
                this.config = config;
                this._renderPanelContent();

                // Ensure only the relevant counter is present in the panel footer
                try {
                    let panelFooter = this.panel.querySelector('.panel-footer');
                    if (!panelFooter) panelFooter = this.panel;

                    if (this.mode === 'endpoint') {
                        // remove any lingering API counter
                        const apiCounter = panelFooter.querySelector('#api-filter-counter');
                        if (apiCounter) apiCounter.remove();
                    } else if (this.mode === 'domain') {
                        // remove any lingering endpoint counter
                        const epCounter = panelFooter.querySelector('#endpoint-counter');
                        if (epCounter) epCounter.remove();
                    }
                } catch (e) { /* ignore */ }

                // After rendering panel content, ensure the visual active state of chips matches active filters
                try {
                    if (this.mode === 'domain') {
                        if (typeof updateDomainFilterUI === 'function') updateDomainFilterUI();
                    } else if (this.mode === 'endpoint') {
                        // Update endpoint filter UI to reflect saved/active filters
                        if (typeof updateEndpointMethodFilterUI === 'function') updateEndpointMethodFilterUI();
                        if (typeof updateEndpointTagFilterUI === 'function') updateEndpointTagFilterUI();
                    }
                } catch (e) { /* ignore */ }
            }

            _renderPanelContent() {
                const container = this.panel.querySelector('#panelDomainFilters');
                if (!container) return;
                // Update panel title based on mode
                const titleEl = this.panel.querySelector('.panel-title');
                if (titleEl) titleEl.textContent = (this.mode === 'endpoint') ? 'Endpoints' : 'Domains';

                container.innerHTML = '';

                // populate chips using getItems
                const items = (this.config.getItems && typeof this.config.getItems === 'function') ? this.config.getItems() : [];
                // items can be array of strings or objects { key, count, kind }
                if (this.mode === 'endpoint') {
                    // Group items by kind for explicit ordering: methods -> search -> tags
                    const methodItems = items.filter(it => (typeof it === 'object' && it && it.kind === 'method') || (typeof it === 'string' && String(it).match(/^(get|post|put|patch|delete|options|head)$/i)));
                    const tagItems = items.filter(it => (typeof it === 'object' && it && it.kind === 'tag'));

                    // Render Methods section
                    if (methodItems.length > 0) {
                        const header = document.createElement('div');
                        header.className = 'panel-section-header';
                        header.textContent = 'Methods';
                        header.style.fontSize = '0.8rem';
                        header.style.fontWeight = '700';
                        header.style.margin = '8px 4px 4px 4px';
                        header.style.color = '#374151';
                        container.appendChild(header);

                        methodItems.forEach(it => {
                            const key = typeof it === 'string' ? it : it.key;
                            const count = (typeof it === 'string') ? null : (Object.prototype.hasOwnProperty.call(it, 'count') ? it.count : null);
                            const kind = 'method';

                            const chip = document.createElement('div');
                            chip.className = 'domain-chip endpoint-chip endpoint-method-chip';
                            chip.dataset.value = key;
                            chip.dataset.kind = kind;
                            chip.dataset.method = (typeof key === 'string') ? key.toLowerCase() : '';
                            chip.setAttribute('role', 'button');
                            chip.tabIndex = 0;
                            chip.appendChild(document.createTextNode((typeof key === 'string') ? key.toUpperCase() : String(key)));
                            if (count !== null) {
                                const span = document.createElement('span');
                                // mark method counts with http-chip-count so they get
                                // method-specific colors and don't pick up domain rules
                                span.className = 'http-chip-count';
                                span.dataset.method = chip.dataset.method || '';
                                span.textContent = count;
                                chip.appendChild(document.createTextNode(' '));
                                chip.appendChild(span);
                            }
                            chip.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); chip.click(); } });
                            chip.addEventListener('click', (e) => { e.stopPropagation(); try { if (this.config.onToggle) this.config.onToggle(key, kind); } catch (err) { } });
                            try { if (activeEndpointMethods && activeEndpointMethods.has && activeEndpointMethods.has((key || '').toLowerCase())) chip.classList.add('active'); } catch (e) { }
                            container.appendChild(chip);
                        });
                    }

                    // Insert search input between methods and tags
                    let searchRow = this.panel.querySelector('.panel-search-row');
                    if (!searchRow) {
                        searchRow = document.createElement('div');
                        searchRow.className = 'panel-search-row';
                        searchRow.style.display = 'flex';
                        searchRow.style.width = '100%';
                        searchRow.style.margin = '8px 0';
                        const input = document.createElement('input');
                        input.type = 'search';
                        input.placeholder = 'Search endpoints...';
                        input.style.width = '100%';
                        input.style.padding = '8px 10px';
                        input.style.borderRadius = '8px';
                        input.style.border = '1px solid rgba(226,232,240,0.8)';
                        input.addEventListener('input', (e) => { if (this.config.onSearch) this.config.onSearch(e.target.value); });
                        searchRow.appendChild(input);
                    }
                    container.appendChild(searchRow);

                    // Render Tags section
                    if (tagItems.length > 0) {
                        const header2 = document.createElement('div');
                        header2.className = 'panel-section-header';
                        header2.textContent = 'Tags';
                        header2.style.fontSize = '0.8rem';
                        header2.style.fontWeight = '700';
                        header2.style.margin = '8px 4px 4px 4px';
                        header2.style.color = '#374151';
                        container.appendChild(header2);

                        tagItems.forEach(it => {
                            const key = typeof it === 'string' ? it : it.key;
                            const count = (typeof it === 'string') ? null : (Object.prototype.hasOwnProperty.call(it, 'count') ? it.count : null);
                            const kind = 'tag';

                            const chip = document.createElement('div');
                            chip.className = 'domain-chip endpoint-chip endpoint-tag-chip';
                            chip.dataset.value = key;
                            chip.dataset.kind = kind;
                            chip.setAttribute('role', 'button');
                            chip.tabIndex = 0;
                            chip.appendChild(document.createTextNode(String(key)));
                            if (count !== null) {
                                const span = document.createElement('span');
                                span.className = 'chip-count';
                                span.textContent = count;
                                chip.appendChild(document.createTextNode(' '));
                                chip.appendChild(span);
                            }
                            chip.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); chip.click(); } });
                            chip.addEventListener('click', (e) => { e.stopPropagation(); try { if (this.config.onToggle) this.config.onToggle(key, kind); } catch (err) { } });
                            try { if (activeEndpointTags && activeEndpointTags.has && activeEndpointTags.has(key)) chip.classList.add('active'); } catch (e) { }
                            container.appendChild(chip);
                        });
                    }
                } else {
                    // Domain mode (unchanged)
                    // items can be array of strings or objects { key, count }
                    items.forEach(it => {
                        const key = typeof it === 'string' ? it : it.key;
                        const count = (typeof it === 'string') ? null : (Object.prototype.hasOwnProperty.call(it, 'count') ? it.count : null);

                        const chip = document.createElement('div');
                        chip.className = 'domain-chip';
                        chip.dataset.domain = key;
                        const labelSpan = document.createElement('span');
                        labelSpan.style.display = 'inline-block';
                        labelSpan.style.verticalAlign = 'middle';
                        labelSpan.textContent = key;

                        const countSpan = document.createElement('span');
                        countSpan.className = 'chip-count';
                        countSpan.style.minWidth = '20px';
                        countSpan.style.height = '20px';
                        countSpan.style.padding = '0 7px';
                        countSpan.style.lineHeight = '20px';
                        countSpan.style.display = 'inline-flex';
                        countSpan.style.alignItems = 'center';
                        countSpan.style.justifyContent = 'center';
                        countSpan.style.borderRadius = '50%';
                        countSpan.style.background = '#fff';
                        countSpan.style.color = '#0f766e';
                        countSpan.style.fontSize = '0.75rem';
                        countSpan.style.fontWeight = '800';
                        countSpan.style.boxShadow = '0 2px 6px rgba(2,6,23,0.12)';
                        countSpan.style.marginLeft = '8px';
                        countSpan.style.border = '2px solid #0f766e';
                        countSpan.textContent = count;

                        chip.appendChild(labelSpan);
                        chip.appendChild(countSpan);

                        chip.setAttribute('role', 'button');
                        chip.tabIndex = 0;
                        chip.addEventListener('keydown', function (e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this.click(); } });

                        chip.addEventListener('click', function () { toggleDomainFilter(key); });

                        try { if (activeDomains && activeDomains.has && activeDomains.has(key)) chip.classList.add('active'); } catch (e) { }

                        container.appendChild(chip);
                    });
                }
            }

            open() {
                // Clear any pending close fallback to avoid race between open/close
                if (this._closeFallbackTimer) { clearTimeout(this._closeFallbackTimer); this._closeFallbackTimer = null; }

                const rect = this.notch.getBoundingClientRect();
                const panelW = Math.min(420, window.innerWidth - 40);
                const panelH = 260;
                let left = rect.left - panelW - 8;
                if (left < 8) left = rect.right + 8;
                if (left + panelW > window.innerWidth - 8) left = window.innerWidth - panelW - 8;
                let top = rect.top;
                if (top + panelH > window.innerHeight - 8) top = window.innerHeight - panelH - 8;

                this.panel.style.left = left + 'px';
                this.panel.style.top = top + 'px';

                const notchCenterX = rect.left + rect.width / 2;
                const notchCenterY = rect.top + rect.height / 2;
                const localX = Math.round(notchCenterX - left);
                const localY = Math.round(notchCenterY - top);

                this.panel.style.display = 'flex';
                this.panel.setAttribute('aria-hidden', 'false');
                this.panel.style.setProperty('--clip-x', localX + 'px');
                this.panel.style.setProperty('--clip-y', localY + 'px');
                this.panel.style.clipPath = `circle(0px at ${localX}px ${localY}px)`;
                this.panel.style.transform = 'scale(0.96)';
                this.panel.style.opacity = '0';
                // force reflow
                this.panel.offsetHeight;

                requestAnimationFrame(() => {
                    this.panel.classList.remove('closing');
                    this.panel.classList.add('open');
                    const diag = Math.hypot(panelW, panelH) * 1.25;
                    this.panel.style.clipPath = `circle(${diag}px at ${localX}px ${localY}px)`;
                    this.panel.style.transform = 'scale(1)';
                    this.panel.style.opacity = '1';
                    // After the opening transition completes, remove the clip-path so
                    // the panel can expand/scroll freely without being visually clipped
                    // by the reveal circle. Use a transitionend handler with a
                    // fallback timeout to ensure it always runs.
                    try {
                        // remove any previous open handler/fallback
                        if (this._onOpenEndListener) {
                            this.panel.removeEventListener('transitionend', this._onOpenEndListener);
                            this._onOpenEndListener = null;
                        }
                        if (this._openFinalizeTimer) { clearTimeout(this._openFinalizeTimer); this._openFinalizeTimer = null; }

                        const onEndOpen = (e) => {
                            if (e.propertyName === 'clip-path' || e.propertyName === 'opacity') {
                                try { this.panel.style.clipPath = 'none'; } catch (err) { }
                                try { this.panel.removeEventListener('transitionend', onEndOpen); } catch (err) { }
                                this._onOpenEndListener = null;
                                if (this._openFinalizeTimer) { clearTimeout(this._openFinalizeTimer); this._openFinalizeTimer = null; }
                            }
                        };

                        this._onOpenEndListener = onEndOpen;
                        this.panel.addEventListener('transitionend', onEndOpen);

                        // safety fallback in case transitionend doesn't fire
                        this._openFinalizeTimer = setTimeout(() => {
                            try { this.panel.style.clipPath = 'none'; } catch (err) { }
                            try { if (this._onOpenEndListener) this.panel.removeEventListener('transitionend', this._onOpenEndListener); } catch (err) { }
                            this._onOpenEndListener = null;
                            if (this._openFinalizeTimer) { clearTimeout(this._openFinalizeTimer); this._openFinalizeTimer = null; }
                        }, 700);
                    } catch (err) { /* ignore */ }
                });
            }

            close() {
                // If we had an open finalize pending, cancel it so we don't remove
                // the clip-path unexpectedly while closing.
                try {
                    if (this._onOpenEndListener) {
                        try { this.panel.removeEventListener('transitionend', this._onOpenEndListener); } catch (e) { }
                        this._onOpenEndListener = null;
                    }
                    if (this._openFinalizeTimer) { clearTimeout(this._openFinalizeTimer); this._openFinalizeTimer = null; }
                } catch (e) { }

                const rect = this.notch.getBoundingClientRect();
                const panelRect = this.panel.getBoundingClientRect();
                const localX = Math.round(rect.left + rect.width / 2 - panelRect.left);
                const localY = Math.round(rect.top + rect.height / 2 - panelRect.top);
                this.panel.style.setProperty('--clip-x', localX + 'px');
                this.panel.style.setProperty('--clip-y', localY + 'px');
                this.panel.classList.remove('open');
                this.panel.classList.add('closing');
                this.panel.style.clipPath = `circle(0px at ${localX}px ${localY}px)`;
                this.panel.style.transform = 'scale(0.96)';
                this.panel.style.opacity = '0';
                // Finalize close helper (ensures we don't get stuck in 'closing' state)
                let cleaned = false;
                const finalizeClose = () => {
                    if (cleaned) return;
                    cleaned = true;
                    try { this.panel.removeEventListener('transitionend', onEndClose); } catch (e) { }
                    try { this.panel.style.display = 'none'; } catch (e) { }
                    try { this.panel.setAttribute('aria-hidden', 'true'); } catch (e) { }
                    try { this.panel.classList.remove('closing'); } catch (e) { }
                    if (this._closeFallbackTimer) { clearTimeout(this._closeFallbackTimer); this._closeFallbackTimer = null; }
                };

                const onEndClose = (e) => {
                    if (e.propertyName === 'clip-path' || e.propertyName === 'opacity') {
                        finalizeClose();
                    }
                };

                this.panel.addEventListener('transitionend', onEndClose);

                // If there is no transition (0s) the transitionend may never fire; use computed style or fallback timeout
                try {
                    const cs = window.getComputedStyle(this.panel);
                    const dur = cs && cs.transitionDuration ? cs.transitionDuration : '';
                    const seconds = parseFloat(dur) || 0;
                    if (!seconds) {
                        // finalize immediately
                        finalizeClose();
                        return;
                    }
                } catch (e) { /* ignore */ }

                // Safety fallback: finalize after 600ms in case transitionend doesn't fire
                this._closeFallbackTimer = setTimeout(() => { finalizeClose(); }, 600);
            }
        }

        // Instantiate the reusable notch component (if not already)
        function initFilterNotch() {
            if (window.filterNotchInstance) return;
            window.filterNotchInstance = new FilterNotch({ notchSelector: '#filterNotch', panelSelector: '#filterPanel' });

            // Default mode: domain filters
            if (window.filterNotchInstance) {
                window.filterNotchInstance.setMode('domain', {
                    // Return items with counts so the panel renders chip-count badges
                    getItems: () => Object.keys(apisByDomain || {}).sort().map(d => ({ key: d, count: (apisByDomain[d] || []).length })),
                    onToggle: (domain) => toggleDomainFilter(domain),
                    clearCallback: () => clearAllDomainFilters()
                });
            }
        }

        // Toggle domain filter
        function toggleDomainFilter(domain) {
            // Add micro-interaction feedback
            const chip = document.querySelector(`.domain-chip[data-domain="${domain}"], .domain-chip[data-value="${domain}"]`);
            if (chip) {
                chip.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    chip.style.transform = '';
                }, 100);
            }

            if (activeDomains.has(domain)) {
                activeDomains.delete(domain);
            } else {
                activeDomains.add(domain);
            }

            // Save filters to localStorage
            saveDomainFilters();

            updateDomainFilterUI();
            
            // Update domain dropdown to show only filtered domains
            if (apisByDomain) {
                const allDomains = Object.keys(apisByDomain).sort();
                populateNavbarDomainDropdown(allDomains);
            }

            // Use RAF for smoother transitions
            requestAnimationFrame(() => {
                applyDomainFilter();
            });
        }

        // Clear all domain filters
        function clearAllDomainFilters() {
            activeDomains.clear();

            // Clear cache
            clearDomainFiltersCache();

            updateDomainFilterUI();

            // Use RAF for smoother transitions
            requestAnimationFrame(() => {
                applyAllFilters();
            });
        }

        // Endpoint method filtering functions
        function toggleEndpointMethodFilter(method) {
            // Add micro-interaction feedback
            const chip = document.querySelector(`.endpoint-method-chip[data-method="${method}"]`);
            if (chip) {
                chip.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    chip.style.transform = '';
                }, 100);
            }

            if (activeEndpointMethods.has(method)) {
                activeEndpointMethods.delete(method);
            } else {
                activeEndpointMethods.add(method);
            }

            saveEndpointFilters();
            updateEndpointMethodFilterUI();
            applyEndpointFilters();
        }



        function updateEndpointMethodFilterUI() {
            // Toggle active state for both legacy method chips and floating panel method chips
            const chips = document.querySelectorAll('.endpoint-method-chip, .endpoint-chip[data-kind="method"]');

            chips.forEach(chip => {
                const method = (chip.dataset.method || chip.dataset.value || '').toLowerCase();
                if (method && activeEndpointMethods.has(method)) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            });
        }

        // Apply all filters (domain + endpoint) - used by clear and other flows
        function applyAllFilters() {
            try {
                // Reapply domain filters (landing views)
                applyDomainFilter();

                // Reapply endpoint filters if API docs view is active
                if (endpointFilteringEnabled) {
                    applyEndpointFilters();
                }

                // Update counters explicitly
                try {
                    const visibleEndpointCount = document.querySelectorAll('.swagger-ui .opblock:not([style*="display: none"])').length;
                    updateEndpointCounter(visibleEndpointCount);
                } catch (e) { /* ignore if swagger not present */ }

                // Ensure API counter is up to date for landing views
                try {
                    if (allApis) updateApiCounter(Array.isArray(allApis) ? allApis.length : 0);
                } catch (e) { }
            } catch (err) {
                console.warn('applyAllFilters failed', err);
            }
        }

        function applyEndpointFilters() {
            if (!endpointFilteringEnabled) return;

            // Resolve search input (legacy or panel)
            let searchEl = document.getElementById('endpointSearch');
            if (!searchEl && window.filterNotchInstance && window.filterNotchInstance.panel) {
                searchEl = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
            }
            const searchQuery = (searchEl ? (searchEl.value || '') : '').toLowerCase().trim();

            // Get all Swagger UI operation elements
            const operations = document.querySelectorAll('.swagger-ui .opblock');

            operations.forEach(operation => {
                const methodElement = operation.querySelector('.opblock-summary-method');
                const pathElement = operation.querySelector('.opblock-summary-path');
                const summaryElement = operation.querySelector('.opblock-summary-description');

                if (!methodElement) return;

                const method = methodElement.textContent.toLowerCase().trim();
                const path = pathElement ? pathElement.textContent.toLowerCase() : '';
                const summary = summaryElement ? summaryElement.textContent.toLowerCase() : '';

                // Check method filter
                const matchesMethod = activeEndpointMethods.size === 0 || activeEndpointMethods.has(method);

                // Check tag filter: try to resolve tags from currentApiEndpoints by matching method+path
                let matchesTag = true;
                try {
                    if (activeEndpointTags.size > 0 && Array.isArray(currentApiEndpoints)) {
                        const opPathText = pathElement ? pathElement.textContent.trim().toLowerCase() : '';
                        const epObj = currentApiEndpoints.find(ep => (ep.method || '').toLowerCase() === method && (String(ep.path || '').trim().toLowerCase() === opPathText));
                        if (epObj && Array.isArray(epObj.tags) && epObj.tags.length > 0) {
                            matchesTag = epObj.tags.some(t => activeEndpointTags.has(String(t)));
                        } else {
                            // If we can't determine tags for this op, be permissive and allow it
                            matchesTag = true;
                        }
                    }
                } catch (e) { matchesTag = true; }

                // Check search filter
                const matchesSearch = !searchQuery ||
                    path.includes(searchQuery) ||
                    summary.includes(searchQuery) ||
                    method.includes(searchQuery);

                // Show/hide operation (also honor tag filters)
                const shouldShow = matchesMethod && matchesSearch && matchesTag;
                operation.style.display = shouldShow ? 'block' : 'none';

                // Add visual feedback for filtered state
                if (shouldShow) {
                    operation.style.opacity = '1';
                    operation.style.transform = 'scale(1)';
                } else {
                    operation.style.opacity = '0.3';
                    operation.style.transform = 'scale(0.95)';
                }
            });

            // Update results count
            const visibleCount = document.querySelectorAll('.swagger-ui .opblock[style*="display: block"], .swagger-ui .opblock:not([style*="display: none"])').length;
            updateEndpointCounter(visibleCount);

            // If user filtered by tag or performed a search, scroll to the first
            // visible operation so the user sees the matched result immediately.
            try {
                const shouldScroll = Boolean(searchQuery && searchQuery.length) || (activeEndpointTags && activeEndpointTags.size > 0);
                if (shouldScroll) {
                    // Delay slightly to ensure layout updates are applied
                    setTimeout(() => {
                        const ops = document.querySelectorAll('.swagger-ui .opblock');
                        for (let i = 0; i < ops.length; i++) {
                            const op = ops[i];
                            // check visibility
                            const cs = window.getComputedStyle(op);
                            if (cs.display !== 'none' && cs.visibility !== 'hidden' && op.offsetParent !== null) {
                                try {
                                    op.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    // focus the op summary for keyboard users (don't force scroll)
                                    const summ = op.querySelector('.opblock-summary');
                                    if (summ && summ.focus) summ.focus({ preventScroll: true });
                                } catch (e) { /* ignore scrolling errors */ }
                                break;
                            }
                        }
                    }, 80);
                }
            } catch (e) { /* ignore scroll helper errors */ }
        }

        function updateEndpointCounter(visibleCount) {
            // Try to find or create a counter element in the Swagger UI
            let counter = document.getElementById('endpoint-counter');
            if (!counter) {
                counter = document.createElement('div');
                counter.id = 'endpoint-counter';
                counter.style.cssText = `
                    padding: 8px 16px;
                    background: rgba(15, 118, 110, 0.06);
                    border-radius: 12px;
                    color: #0f766e;
                    font-size: 0.9rem;
                    font-weight: 600;
                    text-align: center;
                    margin: 8px 12px;
                    border: 1px solid rgba(15, 118, 110, 0.12);
                `;
                // Insert inside the endpoint filter CONTENT so it collapses with the other elements
                // If legacy endpointFilterBar exists, insert there. Otherwise append to the floating panel footer.
                const filterBar = document.getElementById('endpointFilterBar');
                if (filterBar) {
                    const content = filterBar.querySelector('.endpoint-filter-content');
                    if (content) {
                        content.appendChild(counter);
                    } else {
                        const wrapper = filterBar.querySelector('.endpoint-filter-wrapper');
                        if (wrapper) wrapper.appendChild(counter);
                        else filterBar.appendChild(counter);
                    }
                } else if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                    // Insert into panel footer (so it appears with the panel)
                    const footer = window.filterNotchInstance.panel.querySelector('.panel-footer');
                    if (footer) footer.appendChild(counter);
                    else window.filterNotchInstance.panel.appendChild(counter);
                }
            }

            const totalCount = currentApiEndpoints.length;

            // If endpoint filtering isn't active or we're back on the landing page,
            // hide the endpoint counter to avoid showing endpoint messages on the home grid.
            if (!endpointFilteringEnabled || isLandingPage) {
                try { counter.style.display = 'none'; } catch (e) { }
                return;
            } else {
                try { counter.style.display = ''; } catch (e) { }
            }

            // Determine if any filters are active: method chips or search text (legacy or panel)
            let searchEl = document.getElementById('endpointSearch');
            if (!searchEl && window.filterNotchInstance && window.filterNotchInstance.panel) {
                searchEl = window.filterNotchInstance.panel.querySelector('.panel-search-row input');
            }
            const hasSearch = Boolean(searchEl && searchEl.value && searchEl.value.trim());
            const hasMethodFilter = activeEndpointMethods.size > 0;
            const hasFilters = hasMethodFilter || hasSearch;

            // Build message per user request
            if (!hasFilters) {
                // No filters — show arrow + total
                counter.innerHTML = `<span style="margin-right:6px;"></span><span class="count">${totalCount}</span> Endpoints Available`;
                return;
            }

            // Filters active — show visible/total and method info if available (no arrow)
            if (hasMethodFilter) {
                const methods = Array.from(activeEndpointMethods).map(m => m.toUpperCase());
                if (methods.length === 1) {
                    counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints matches ${methods[0]}`;
                } else {
                    counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints match ${methods.join(', ')}`;
                }
            } else {
                counter.innerHTML = `<span class="count">${visibleCount}</span> of ${totalCount} Endpoints Available`;
            }
        }

        // Update domain filter UI
        function updateDomainFilterUI() {
            const chips = document.querySelectorAll('.domain-chip');

            chips.forEach(chip => {
                const domain = chip.dataset.domain || chip.dataset.value;
                if (domain && activeDomains.has(domain)) {
                    chip.classList.add('active');
                } else {
                    chip.classList.remove('active');
                }
            });
        }

        // Apply domain filter with search integration
        function applyDomainFilter() {
            const apiCounter = document.getElementById('apiCount');

            // Use RAF for smooth rendering with immediate, consistent behavior
            requestAnimationFrame(() => {
                // Always regenerate the current view with domain and search filters
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        // Fallback to direct hexagon filtering for compatibility
                        applyFiltersDirectly();
                        break;
                }
            });
        }

        // Direct filtering for domain and search (fallback)
        function applyFiltersDirectly() {
            const hexagons = document.querySelectorAll('.hexagon-item');
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';
            let visibleCount = 0;

            hexagons.forEach((hexagon, index) => {
                const api = allApis[index];
                if (!api) return;

                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // Check domain filter
                const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                // Check search filter
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                const shouldShow = matchesDomain && matchesSearch;

                if (shouldShow) {
                    // Show immediately with clean positioning - no memory of old positions
                    hexagon.style.display = 'block';
                    hexagon.style.visibility = 'visible';
                    hexagon.style.position = 'relative';
                    hexagon.style.transform = 'scale(1) translateY(0)'; // Reset any transforms
                    hexagon.style.opacity = '1';
                    hexagon.style.filter = 'none';

                    // Clean class management - no animation delays or position memory
                    hexagon.classList.remove('domain-filtered-out');
                    hexagon.classList.add('domain-filtered-in');

                    // No transition delays to prevent position memory
                    hexagon.style.transitionDelay = '0s';

                    visibleCount++;
                } else {
                    // Hide immediately and cleanly like card view
                    hexagon.classList.remove('domain-filtered-in');
                    hexagon.classList.add('domain-filtered-out');
                    hexagon.style.transitionDelay = '0s';

                    // Immediate hiding to prevent flickering
                    hexagon.style.display = 'none';
                    hexagon.style.visibility = 'hidden';
                    hexagon.style.opacity = '0';
                }
            });

            // Update counter
            updateViewCounter(visibleCount, searchQuery);
        }



        async function loadApis() {
            try {
                console.log("🔄 Fetching APIs...");

                // Show loading state in the floating panel (if available)
                try {
                    if (window.filterNotchInstance && window.filterNotchInstance.panel) {
                        let panelFooter = window.filterNotchInstance.panel.querySelector('.panel-footer');
                        if (!panelFooter) panelFooter = window.filterNotchInstance.panel;
                        let panelCounter = panelFooter.querySelector('#api-filter-counter');
                        if (!panelCounter) {
                            panelCounter = document.createElement('div');
                            panelCounter.id = 'api-filter-counter';
                            panelCounter.style.cssText = 'padding: 8px 16px; background: rgba(15, 118, 110, 0.06); border-radius: 12px; color: rgb(15, 118, 110); font-size: 0.9rem; font-weight: 600; text-align: center; margin: 8px 12px; border: 1px solid rgba(15, 118, 110, 0.12);';
                            panelFooter.appendChild(panelCounter);
                        }
                        panelCounter.innerHTML = `<span class="count"><i class="fas fa-spinner fa-spin"></i></span> Loading APIs...`;
                    }
                } catch (e) { /* ignore */ }

                const res = await fetch("/api/swagger-config");

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }

                const data = await res.json();
                console.log("📡 Received data:", data);

                const urls = data.urls || [];
                console.log(`📊 Raw APIs count: ${urls.length}`);

                // Filter out null/invalid API entries
                const filteredUrls = urls.filter(api =>
                    api &&
                    api.name &&
                    api.url &&
                    !api.name.includes('null/null/null') &&
                    api.name !== 'null/null/null/api-docs'
                );

                console.log(`✅ Filtered APIs count: ${filteredUrls.length}`);
                allApis = filteredUrls;

                // Update API counter immediately
                updateApiCounter(filteredUrls.length);

                // Populate custom dropdown (if it exists)
                const dropdown = document.getElementById("apiDropdown");
                const customDropdown = document.getElementById("customDropdown");
                const dropdownList = document.getElementById("dropdownList");
                const dropdownText = document.getElementById("dropdownText");

                // Only populate dropdown if elements exist
                if (dropdown && dropdownList) {
                    // Clear old content
                    dropdown.innerHTML = '<option value="">Select an API...</option>';
                    dropdownList.innerHTML = '';

                    // Add APIs to both hidden select and custom dropdown
                    filteredUrls.forEach((api, index) => {
                        // Hidden select option
                        const option = document.createElement("option");
                        option.value = api.url;
                        const serviceName = extractServiceName(api.name);
                        const domain = extractDomain(api.name);
                        option.text = `${serviceName} (${domain})`;
                        dropdown.appendChild(option);

                        // Custom dropdown item
                        const dropdownItem = document.createElement("div");
                        dropdownItem.className = "dropdown-item";
                        const domainColors = getDomainColor(domain);
                        dropdownItem.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; width: 100%; box-sizing: border-box;">
                    <span style="font-weight: 600; flex: 1; min-width: 0; word-break: break-word; line-height: 1.3;">${serviceName}</span>
                    <span class="domain-tag" style="font-size: 0.75rem; padding: 3px 10px; border-radius: 12px; background: ${domainColors.bg}; color: ${domainColors.text}; border: 1px solid ${domainColors.border}; font-weight: 600; flex-shrink: 0; white-space: nowrap;">
                        ${domain}
                    </span>
                </div>
            `;
                        dropdownItem.dataset.value = api.url;
                        dropdownItem.dataset.name = `${serviceName} (${domain})`;

                        // Click selects the API
                        dropdownItem.addEventListener('click', function () {
                            selectDropdownItem(this, api);
                        });

                        // Ripple feedback on mousedown
                        dropdownItem.addEventListener('mousedown', function (e) {
                            createRippleEffect(this, e);
                        });

                        dropdownList.appendChild(dropdownItem);
                    });
                }

                // Setup custom dropdown behavior (if exists)
                if (customDropdown && dropdownList) {
                    setupCustomDropdown();
                }

                // Original dropdown change handler (for compatibility)
                if (dropdown) {
                    dropdown.addEventListener("change", e => {
                        if (e.target.value) {
                            navigateToApi(e.target.value);
                        }
                    });

                    // Add click animation for dropdown
                    dropdown.addEventListener("mousedown", function (e) {
                        createRippleEffect(this, e);
                    });

                    dropdown.addEventListener("focus", function () {
                        // Add opening animation class
                        this.classList.add('dropdown-opening');
                        setTimeout(() => {
                            this.classList.remove('dropdown-opening');
                        }, 600);
                    });
                }

                // Generate hexagonal grid
                renderHexagonView();

                // Generate domain filters (populate panel) and init notch interactions
                generateDomainFilters(filteredUrls);
                try { initFilterNotch(); } catch (e) { /* ignore if not available */ }

                // Initialize other views with the loaded APIs
                if (currentView !== 'hexagon') {
                    switch (currentView) {
                        case 'card':
                            renderCardView();
                            break;
                    }
                }

                // Initialize filter saving preference
                initializeFilterSaving();

                // Restore cached domain filters only if saving is enabled
                if (shouldSaveFilters) {
                    const hasRestoredFilters = loadDomainFilters();
                    if (hasRestoredFilters) {
                        console.log("🔄 Restoring domain filter UI and applying filters...");
                        updateDomainFilterUI();
                        // Apply filters after a small delay to ensure DOM is ready
                        setTimeout(() => {
                            applyDomainFilter();
                        }, 100);
                    } else {
                        // No filters restored, make sure counter shows all APIs
                        setTimeout(() => {
                            updateApiCounter(filteredUrls.length);
                        }, 200);
                    }
                } else {
                    // Saving disabled, don't restore filters
                    console.log("💾 Filter saving disabled, skipping restore");
                    setTimeout(() => {
                        updateApiCounter(filteredUrls.length);
                    }, 200);
                }

                setupAutocomplete();
                setupNavigation();

                // Initialize view switcher with loaded APIs
                initializeViewSwitcher();

                // Restore previous state if exists (after page refresh)
                restoreSessionState();

            } catch (err) {
                console.error("❌ Failed to load API list:", err);

                // Show error state in UI
                updateApiCounter("Error", "Failed to load APIs");
                // Also try direct update with error styling
                setTimeout(() => {
                    const apiCountText = document.getElementById('apiCountText');
                    if (apiCountText) {
                        apiCountText.innerHTML = `<span class="count" style="color: #ef4444;">Error</span> Failed to load APIs`;
                    }
                }, 100);

                // Show error message to user
                const hexagonGrid = document.getElementById('hexagonGrid');
                if (hexagonGrid) {
                    hexagonGrid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #ef4444;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 16px;"></i>
                    <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 8px;">Failed to Load APIs</div>
                    <div style="font-size: 1rem; opacity: 0.8;">${err.message}</div>
                    <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        <i class="fas fa-redo" style="margin-right: 8px;"></i>Retry
                    </button>
                </div>
            `;
                }
            }
        }

        // Restore session state after page refresh
        function restoreSessionState() {
            // Normalize URL: if we're at /swagger-ui/index.html, clean it up
            if (window.location.pathname.includes('/swagger-ui/index.html')) {
                const cleanPath = window.location.hash || '/';
                const newUrl = window.location.origin + (cleanPath.startsWith('#') ? '/' + cleanPath : cleanPath);
                window.history.replaceState(null, '', newUrl);
            }

            // First check for deep link in URL hash (e.g., #/api/ServiceName)
            // IMPORTANT: Hash takes priority over sessionStorage
            
            // Check preserved hash first (in case current hash was lost or truncated)
            let hash = window.location.hash;
            const preservedHash = sessionStorage.getItem('__PRESERVED_HASH__') || window.__INITIAL_HASH__;
            
            // Always prefer the preserved hash if it exists and is longer/more complete
            if (preservedHash && preservedHash.startsWith('#/api/')) {
                // Check if current hash is missing, truncated, or different
                if (!hash || hash.length < preservedHash.length || hash !== preservedHash) {
                    console.log('🔄 Using preserved hash instead of current hash');
                    console.log('   Current hash:', hash, `(${hash.length} chars)`);
                    console.log('   Preserved hash:', preservedHash, `(${preservedHash.length} chars)`);
                    hash = preservedHash;
                    // Restore it to the URL
                    window.location.hash = hash;
                }
            }
            
            console.log('🔍 Checking URL hash on page load:', hash);
            console.log('📦 Current sessionStorage:', {
                viewState: sessionStorage.getItem('viewState'),
                currentApiUrl: sessionStorage.getItem('currentApiUrl'),
                currentApiName: sessionStorage.getItem('currentApiName'),
                preservedHash: preservedHash
            });
            
            if (hash && hash.startsWith('#/api/')) {
                try {
                    const apiName = decodeURIComponent(hash.substring(6)); // Remove '#/api/'
                    console.log('🔗 Deep link detected for API:', apiName);
                    
                    // Clear any conflicting sessionStorage to prevent override
                    console.log('🧹 Clearing conflicting sessionStorage entries');
                    sessionStorage.removeItem('viewState');
                    sessionStorage.removeItem('currentApiUrl');
                    sessionStorage.removeItem('currentApiName');
                    sessionStorage.removeItem('__PRESERVED_HASH__'); // Clear preserved hash after use
                    
                    // Find the API by name - try multiple matching strategies with detailed logging
                    console.log('🔎 Searching for API in', allApis.length, 'available APIs');
                    
                    let targetApi = null;
                    
                    // Strategy 1: Exact match on full name (most precise)
                    targetApi = allApis.find(api => api.name === apiName);
                    if (targetApi) {
                        console.log('✅ Strategy 1 (exact match) found:', targetApi.name);
                        setTimeout(() => navigateToApi(targetApi.url), 100);
                        return;
                    }
                    
                    // Strategy 2: Exact match with /api-docs suffix removed
                    targetApi = allApis.find(api => api.name.replace('/api-docs', '') === apiName);
                    if (targetApi) {
                        console.log('✅ Strategy 2 (without /api-docs) found:', targetApi.name);
                        setTimeout(() => navigateToApi(targetApi.url), 100);
                        return;
                    }
                    
                    // Strategy 3: Match with "product/" prefix added (for URLs like transaction/card/v1 → product/transaction/card/v1)
                    targetApi = allApis.find(api => api.name === `product/${apiName}` || api.name.replace('/api-docs', '') === `product/${apiName}`);
                    if (targetApi) {
                        console.log('✅ Strategy 3 (with product/ prefix) found:', targetApi.name);
                        setTimeout(() => navigateToApi(targetApi.url), 100);
                        return;
                    }
                    
                    // Strategy 4: Match extracted service name
                    targetApi = allApis.find(api => extractServiceName(api.name) === apiName);
                    if (targetApi) {
                        console.log('✅ Strategy 4 (extracted name) found:', targetApi.name);
                        setTimeout(() => navigateToApi(targetApi.url), 100);
                        return;
                    }
                    
                    // Strategy 5: Contains match (least precise - only use as last resort)
                    // This is dangerous as it can match the wrong API, so we'll be very careful
                    const possibleMatches = allApis.filter(api => api.name.includes(apiName));
                    if (possibleMatches.length === 1) {
                        targetApi = possibleMatches[0];
                        console.log('✅ Strategy 5 (contains - single match) found:', targetApi.name);
                        setTimeout(() => navigateToApi(targetApi.url), 100);
                        return;
                    } else if (possibleMatches.length > 1) {
                        console.warn('⚠️ Strategy 5 found multiple matches:', possibleMatches.map(a => a.name));
                        console.warn('❌ Cannot determine correct API, showing landing page');
                    }
                    
                    // No match found
                    console.warn('⚠️ API not found for deep link:', apiName);
                    console.log('📋 Available API names:', allApis.map(a => a.name));
                    // Clear the invalid hash and show landing page
                    window.location.hash = '';
                    showLandingPage();
                } catch (e) {
                    console.error('❌ Error processing deep link:', e);
                }
                return; // Always return here to prevent sessionStorage fallback
            }

            // Fall back to session storage restoration only if no hash was present
            console.log('ℹ️ No hash found, checking sessionStorage');
            const savedViewState = sessionStorage.getItem('viewState');
            const savedApiUrl = sessionStorage.getItem('currentApiUrl');

            if (savedViewState === 'api-documentation' && savedApiUrl) {
                // Find the API in the loaded list to get full details
                const savedApi = allApis.find(api => api.url === savedApiUrl);

                if (savedApi) {
                    // Set initial history state for API documentation
                    if (!history.state) {
                        history.replaceState(
                            { view: 'api-documentation', apiUrl: savedApiUrl, apiName: savedApi.name },
                            `${savedApi.name} - API Documentation`,
                            `#/api/${encodeURIComponent(savedApi.name)}`
                        );
                    }

                    // Restore the API documentation view
                    setTimeout(() => {
                        // Update dropdown selection
                        const dropdown = document.getElementById("apiDropdown");
                        const dropdownText = document.getElementById("dropdownText");
                        const dropdownItems = document.querySelectorAll('.dropdown-item');

                        dropdown.value = savedApiUrl;

                        // Update custom dropdown
                        dropdownItems.forEach(item => {
                            item.classList.remove('selected');
                            if (item.dataset.value === savedApiUrl) {
                                const serviceName = extractServiceName(savedApi.name);
                                const domain = extractDomain(savedApi.name);
                                dropdownText.textContent = `${serviceName} (${domain})`;
                                item.classList.add('selected');
                            }
                        });

                        // Load API documentation without updating history
                        loadApiDocumentation(savedApiUrl, false);
                    }, 100);
                } else {
                    // API not found, clear invalid state
                    sessionStorage.removeItem('currentApiUrl');
                    sessionStorage.removeItem('viewState');
                }
            } else {
                // Set initial history state for home page
                if (!history.state) {
                    history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                }
            }
        }

        function renderHexagonView() {
            console.log("🔷 Rendering hexagon view...");

            // Get current search query
            const searchInput = document.getElementById("apiSearch");
            const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // Get filtered APIs based on domain and search filters
            const visibleApis = allApis.filter(api => {
                const domain = extractDomain(api.name);
                const serviceName = extractServiceName(api.name);

                // NEW: Check domain filter - respect navbar dropdown selection
                let matchesDomain;
                if (selectedDomain) {
                    // If a specific domain is selected in dropdown, only show that domain
                    matchesDomain = domain === selectedDomain;
                } else {
                    // If "All Domains" selected, apply chip filters if any
                    matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);
                }

                // Check search filter - searches domain name and API name
                const matchesSearch = !searchQuery ||
                    serviceName.toLowerCase().includes(searchQuery) ||
                    api.name.toLowerCase().includes(searchQuery) ||
                    domain.toLowerCase().includes(searchQuery);

                return matchesDomain && matchesSearch;
            });

            console.log(`🔷 Hexagon view: Found ${visibleApis.length} visible APIs (search: "${searchQuery}", domain: "${selectedDomain || 'All'}", chips: ${Array.from(activeDomains).join(', ')})`);

            // Regenerate the grid with filtered APIs
            generateHexagonGrid(visibleApis);

            // Update counter
            updateViewCounter(visibleApis.length, searchQuery);
        }

        function generateHexagonGrid(apis) {
            const grid = document.getElementById('hexagonGrid');
            grid.innerHTML = '';

            // Calculate optimal sizing based on number of APIs and screen size
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight - 300; // Reserve space for header and margins
            const apiCount = apis.length;
            
            let maxItemsPerRow; // Maximum items per row (for even rows)
            let hexagonWidth; // Base width for hexagons

            // Determine items per row and size based on API count and screen width
            if (apiCount <= 12) {
                // Few APIs - larger hexagons
                maxItemsPerRow = screenWidth >= 1600 ? 5 : screenWidth >= 1200 ? 4 : 3;
                hexagonWidth = screenWidth >= 1600 ? 240 : 220;
            } else if (apiCount <= 24) {
                // Medium number - medium hexagons
                maxItemsPerRow = screenWidth >= 1600 ? 6 : screenWidth >= 1200 ? 5 : 4;
                hexagonWidth = screenWidth >= 1600 ? 220 : 200;
            } else if (apiCount <= 48) {
                // Many APIs - smaller hexagons
                maxItemsPerRow = screenWidth >= 1600 ? 7 : screenWidth >= 1200 ? 6 : 5;
                hexagonWidth = screenWidth >= 1600 ? 200 : 180;
            } else {
                // Lots of APIs - alternating 11 and 10 hexagons per row for perfect fit with 53 APIs in 5 rows
                maxItemsPerRow = screenWidth >= 1600 ? 11 : screenWidth >= 1200 ? 9 : 8;
                hexagonWidth = screenWidth >= 1600 ? 155 : 135;
            }

            // Calculate hexagon height (proper hexagon ratio: height = width * 1.15)
            const hexagonHeight = hexagonWidth * 1.15;

            // Calculate proper beehive offset for honeycomb interlocking pattern
            const horizontalGap = 14; // Small gap - just enough for scale hover without touching
            // For proper honeycomb: offset to position hexagons exactly in the gaps
            // Small negative offset for fine-tuning - slightly more left
            const oddRowOffset = 0;
            // Less overlap to create more vertical space - matches side gaps
            const verticalOverlap = hexagonHeight * 0.18; // Reduced overlap for equal gap on all sides during hover

            // Build rows with alternating pattern (10, 9, 10, 9...)
            let apiIndex = 0;
            let rowIndex = 0;
            
            while (apiIndex < apis.length) {
                const row = document.createElement('div');
                row.className = 'hexagon-row';
                row.style.gap = `${horizontalGap}px`;
                
                // Alternate between maxItemsPerRow and (maxItemsPerRow - 1)
                // Even rows (0, 2, 4...) get maxItemsPerRow (10) - no offset
                // Odd rows (1, 3, 5...) get maxItemsPerRow - 1 (9) - offset to create honeycomb
                const itemsPerRow = rowIndex % 2 === 0 ? maxItemsPerRow : (maxItemsPerRow - 1);
                const itemsInRow = Math.min(itemsPerRow, apis.length - apiIndex);
                
                // Apply proper vertical spacing
                if (apiIndex + itemsInRow < apis.length) {
                    row.style.marginBottom = `-${verticalOverlap}px`;
                }
                
                // Apply honeycomb offset and handle incomplete rows
                if (rowIndex % 2 === 1) {
                    // Odd rows (10 items) - offset to nestle in gaps with centered layout
                    row.style.transform = `translateX(${oddRowOffset}px)`;
                } else {
                    // Even rows (11 items) - no offset, stays centered
                    row.style.transform = 'none';
                }

                // Add hexagons to this row
                for (let i = 0; i < itemsInRow; i++) {
                    const api = apis[apiIndex];
                    const hexagon = createHexagon(api, apiIndex, hexagonWidth, hexagonHeight);
                    row.appendChild(hexagon);
                    apiIndex++;
                }

                grid.appendChild(row);
                rowIndex++;
            }
        }

        function createHexagon(api, index, width, height) {
            const hexagonItem = document.createElement('div');
            hexagonItem.className = 'hexagon-item';
            hexagonItem.style.animationDelay = `${(index + 1) * 0.05}s`; // Faster animation for many items
            hexagonItem.setAttribute('data-api-name', api.name);
            
            // Apply dynamic sizing if provided
            if (width && height) {
                hexagonItem.style.width = `${width}px`;
                hexagonItem.style.height = `${height}px`;
            }

            const icon = getApiIcon(api.name);

            // Extract domain and service name
            const domain = extractDomain(api.name);
            const serviceName = extractServiceName(api.name);
            const domainColors = getDomainColor(domain);

            // Apply sizing to internal elements
            const shapeStyle = (width && height) ? `width: ${width}px; height: ${height}px;` : '';
            const contentStyle = (width && height) ? `width: ${width * 0.8}px; height: ${height * 0.78}px;` : '';

            hexagonItem.innerHTML = `
        <div class="hexagon-shape" style="${shapeStyle}">
            <div class="hexagon-content" style="${contentStyle}">
                <div class="hexagon-icon">
                    <i class="${icon}"></i>
                </div>
                <div class="hexagon-title" data-text="${serviceName}">${serviceName}</div>
            </div>
        </div>
        <div class="domain-badge" style="background: ${domainColors.bg}; color: ${domainColors.text};">
            ${domain}
        </div>
    `;
    
            // Auto-resize text to fit
            setTimeout(() => {
                const titleElement = hexagonItem.querySelector('.hexagon-title');
                const contentElement = hexagonItem.querySelector('.hexagon-content');
                if (titleElement && contentElement) {
                    const maxWidth = contentElement.offsetWidth * 0.9; // 90% of content width
                    let fontSize = 1.1; // Start with 1.1rem
                    titleElement.style.fontSize = fontSize + 'rem';
                    
                    while (titleElement.scrollWidth > maxWidth && fontSize > 0.6) {
                        fontSize -= 0.05;
                        titleElement.style.fontSize = fontSize + 'rem';
                    }
                }
            }, 50);

            // Simple hover effect - no push away, just scale and z-index
            hexagonItem.addEventListener('mouseenter', function(e) {
                this.classList.add('hexagon-hovered');
            });
            
            hexagonItem.addEventListener('mouseleave', function(e) {
                this.classList.remove('hexagon-hovered');
            });

            hexagonItem.addEventListener('click', () => {
                selectHexagon(hexagonItem, api);
            });
            
            // Check if this API is the last clicked one and apply the active class
            if (lastClickedApi === api.url) {
                hexagonItem.classList.add('active');
            }

            return hexagonItem;
        }



        function selectHexagon(hexagonElement, api) {
            // Add active state to clicked hexagon
            document.querySelectorAll('.hexagon-item').forEach(item => {
                item.classList.remove('active');
            });
            hexagonElement.classList.add('active');

            // Navigate to API immediately
            navigateToApi(api.url);
            updateDropdownSelection(api.url);
        }

        function updateDropdownSelection(url) {
            const dropdown = document.getElementById("apiDropdown");
            const dropdownText = document.getElementById("dropdownText");
            const dropdownItems = document.querySelectorAll('.dropdown-item');

            dropdown.value = url;

            // Find and update custom dropdown
            dropdownItems.forEach(item => {
                item.classList.remove('selected');
                if (item.dataset.value === url) {
                    dropdownText.textContent = item.dataset.name;
                    item.classList.add('selected');
                }
            });
        }

        function showLandingPage() {
            isLandingPage = true;

            // Clear ALL saved state when returning to landing page
            sessionStorage.removeItem('currentApiUrl');
            sessionStorage.removeItem('currentApiName');
            sessionStorage.removeItem('viewState');
            sessionStorage.removeItem('__PRESERVED_HASH__'); // Clear preserved hash

            // Update URL to clean root path - use only History API for consistency
            const cleanUrlIfNeeded = () => {
                const currentPath = window.location.pathname;
                const currentHash = window.location.hash;
                
                if (currentPath !== '/' || currentHash) {
                    console.log('🧹 Cleaning URL on landing page:', currentPath + currentHash, '→ /');
                    // Use replaceState to clean URL - this handles both path and hash
                    window.history.replaceState({ view: 'home' }, 'API Documentation Portal', window.location.origin + '/');
                }
            };
            
            // Clean URL immediately
            cleanUrlIfNeeded();
            
            // Also clean URL after a brief delay to handle race conditions
            setTimeout(cleanUrlIfNeeded, 50);
            
            // Final verification after 150ms
            setTimeout(() => {
                if (isLandingPage && (window.location.pathname !== '/' || window.location.hash)) {
                    console.log('🔧 Final cleanup - forcing URL to clean state');
                    window.history.replaceState({ view: 'home' }, 'API Documentation Portal', window.location.origin + '/');
                }
            }, 150);
            
            // Start continuous URL/view synchronization
            startUrlViewSync();

            document.getElementById('hexagonContainer').style.display = 'flex';
            document.getElementById('swagger-ui').classList.remove('show');
            document.getElementById('hexagonalHomeButton').style.display = 'none';
            
            const apiDropdown = document.getElementById('apiDropdown');
            if (apiDropdown) {
                apiDropdown.value = '';
            }

            // Ensure endpoint filtering is disabled when returning to landing page
            endpointFilteringEnabled = false;
            setSwaggerUiPaddingForFilterBar(false);
            
            // Restore domain dropdown instead of tags
            const domainDropdownText = document.getElementById('domainDropdownText');
            if (domainDropdownText) {
                domainDropdownText.textContent = 'All Domains';
            }
            
            if (apisByDomain) {
                const allDomains = Object.keys(apisByDomain).sort();
                populateNavbarDomainDropdown(allDomains);
            }
            
            // Reset search placeholder to 'Search APIs...'
            const searchInput = document.getElementById('apiSearch');
            if (searchInput) {
                searchInput.placeholder = 'Search APIs...';
            }

            // Hide/remove endpoint counter when on landing page to avoid message overlap
            try {
                const epCounter = document.getElementById('endpoint-counter');
                if (epCounter) {
                    epCounter.remove();
                }
            } catch (e) { /* ignore */ }

            // If the FilterNotch is present, restore it to domain mode so the panel shows domain chips on the home page
            try {
                if (window.filterNotchInstance) {
                    window.filterNotchInstance.setMode('domain', {
                        getItems: () => Object.keys(apisByDomain || {}).sort().map(d => ({ key: d, count: (apisByDomain[d] || []).length })),
                        onToggle: (domain) => toggleDomainFilter(domain),
                        clearCallback: () => clearAllDomainFilters()
                    });
                    // Close the panel to avoid showing endpoint UI while on landing
                    try { window.filterNotchInstance.close(); } catch (e) { }
                }
            } catch (err) {
                console.warn('Could not reset FilterNotch to domain mode', err);
            }

            // Clear any active endpoint method filters when leaving API docs
            if (activeEndpointMethods && activeEndpointMethods.size > 0) {
                activeEndpointMethods.clear();
                updateEndpointMethodFilterUI();
            }

            // Show view switcher when returning to landing page
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'flex';
            }

            // Reset custom dropdown
            const dropdownText = document.getElementById("dropdownText");
            if (dropdownText) {
                dropdownText.textContent = "Select an API...";
            }
            document.querySelectorAll('.dropdown-item').forEach(item => {
                item.classList.remove('selected');
            });
            if (typeof closeCustomDropdown === 'function') {
                closeCustomDropdown();
            }

            // Clear search input and restore placeholder for API searching
            const searchInputClear = document.getElementById('apiSearch');
            if (searchInputClear) {
                searchInputClear.value = '';
                searchInputClear.placeholder = 'Search APIs...';
            }

            // Clear any active hexagons but maintain domain filtering state
            document.querySelectorAll('.hexagon-item').forEach(item => {
                item.classList.remove('active');
            });

            // Reapply domain filters if they were active
            if (activeDomains.size > 0 || (searchInputClear && searchInputClear.value.trim())) {
                // Apply both domain and search filters
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        applyDomainFilter();
                        break;
                }
            } else {
                // Reset filtering consistently for all views
                switch (currentView) {
                    case 'hexagon':
                        renderHexagonView();
                        break;
                    case 'card':
                        renderCardView();
                        break;
                    default:
                        // Direct reset for hexagon elements
                        document.querySelectorAll('.hexagon-item').forEach(item => {
                            item.classList.remove('domain-filtered-out');
                            item.classList.add('domain-filtered-in');
                            item.style.display = 'block';
                            item.style.visibility = 'visible';
                            item.style.opacity = '1';
                            item.style.transform = 'scale(1) translateY(0)';
                            item.style.filter = 'none';
                            item.style.position = 'relative';
                            item.style.transitionDelay = '0s';
                        });
                        break;
                }

                // Reset API counter only if no filters are active
                if (allApis) {
                    updateApiCounter(allApis.length);
                }
            }

            // Hide no results message
            hideNoResultsMessage();
        }

        function showSwaggerUI() {
            isLandingPage = false;
            
            // Stop URL sync when viewing API docs
            if (urlSyncInterval) {
                clearInterval(urlSyncInterval);
                urlSyncInterval = null;
            }
            
            document.getElementById('hexagonContainer').style.display = 'none';
            document.getElementById('swagger-ui').classList.add('show');
            document.getElementById('hexagonalHomeButton').style.display = 'flex';

            // Enable endpoint filtering UI via floating FilterNotch when viewing API docs
            endpointFilteringEnabled = true;
            setSwaggerUiPaddingForFilterBar(true);

            // Update search placeholder for endpoint searching
            const searchInput = document.getElementById('apiSearch');
            if (searchInput) {
                searchInput.placeholder = 'Search endpoints...';
            }

            // Try to initialize endpoint filtering if not already done
            setTimeout(() => {
                if (!endpointFilteringEnabled && typeof ui !== 'undefined') {
                    console.log("🔄 Attempting to initialize endpoint filtering from showSwaggerUI...");
                    try {
                        const spec = ui.getState().getIn(['spec', 'json']);
                        if (spec && spec.toJS) {
                            const specJson = spec.toJS();
                            initializeEndpointFiltering(specJson);
                        }
                    } catch (error) {
                        console.log("⚠️ Could not initialize from showSwaggerUI:", error);
                    }
                }
            }, 1500);

            // Hide view switcher when viewing API documentation
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'none';
            }
        }

        function setupNavigation() {
            // Setup hexagonal home button
            const hexagonalHomeButton = document.getElementById('hexagonalHomeButton');
            if (hexagonalHomeButton) {
                hexagonalHomeButton.addEventListener('click', () => {
                    // Push to history to enable browser back functionality
                    history.pushState({ view: 'home' }, 'API Documentation Portal', '/');
                    showLandingPage();
                });
            }

            // CRITICAL: Handle URL hash changes to keep view and URL in sync
            window.addEventListener('hashchange', (event) => {
                console.log('🔗 Hash changed:', event.oldURL, '→', event.newURL);
                const currentHash = window.location.hash;
                
                // If we're on landing page but hash exists, clean it immediately
                if (isLandingPage && currentHash) {
                    console.log('⚠️ Landing page with hash detected in hashchange - cleaning');
                    sessionStorage.removeItem('__PRESERVED_HASH__');
                    window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                }
                // If hash was removed but we're showing API doc, show landing page
                else if (!isLandingPage && !currentHash) {
                    console.log('🏠 Hash removed but showing API doc - showing landing page');
                    showLandingPage();
                }
            });
            
            // Handle browser back/forward navigation
            window.addEventListener('popstate', (event) => {
                console.log('⬅️ Popstate event fired, state:', event.state);
                isHandlingPopstate = true;
                
                if (event.state) {
                    if (event.state.view === 'home') {
                        // Going back to home
                        if (window.location.pathname !== '/' || window.location.hash) {
                            window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                        }
                        showLandingPage();
                    } else if (event.state.view === 'api-documentation' && event.state.apiUrl) {
                        loadApiDocumentation(event.state.apiUrl, false); // false to not push to history again
                    }
                } else {
                    // No state found - this happens after a page refresh when user clicks back
                    console.log('⚠️ Popstate with no state, checking URL...');
                    
                    // Check the current URL to determine what to do
                    const currentPath = window.location.pathname;
                    const currentHash = window.location.hash;
                    
                    console.log('   Current view: isLandingPage =', isLandingPage);
                    console.log('   Current URL:', window.location.href);
                    
                    // CRITICAL FIX: If we're showing landing page but URL has hash, clean it
                    // This happens when back button is clicked after refresh (no history to go back to)
                    if (isLandingPage && currentHash) {
                        console.log('🧹 Landing page shown but URL has hash - cleaning immediately');
                        sessionStorage.removeItem('__PRESERVED_HASH__');
                        window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                        return;
                    }
                    
                    // If URL is home (/ with no hash) but we're showing API doc, navigate to home
                    if ((currentPath === '/' || currentPath === '') && !currentHash && !isLandingPage) {
                        console.log('🏠 Back button pressed - URL is home but showing API doc, navigating to home');
                        
                        // Clear stored state
                        sessionStorage.removeItem('__PRESERVED_HASH__');
                        sessionStorage.removeItem('currentApiUrl');
                        sessionStorage.removeItem('currentApiName');
                        sessionStorage.removeItem('viewState');
                        
                        // Show landing page
                        showLandingPage();
                        
                        // Ensure URL stays clean
                        window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                    }
                    // If URL still has API hash and we're NOT on landing page, let page load normally
                    else if (currentHash && currentHash.startsWith('#/api/') && !isLandingPage) {
                        console.log('📄 URL has API hash and showing API doc - normal state');
                        // Don't do anything - let the page load normally
                    }
                    // If on landing page and URL is wrong, clean it
                    else if (isLandingPage && (currentPath !== '/' || currentHash)) {
                        console.log('🧹 Cleaning URL on landing page');
                        sessionStorage.removeItem('__PRESERVED_HASH__');
                        window.history.replaceState({ view: 'home' }, 'API Documentation Portal', '/');
                    }
                }
                
                setTimeout(() => {
                    isHandlingPopstate = false;
                }, 200);
            });
        }

        function navigateToApi(url) {
            if (!url) return;
            
            // Save this as the last clicked API
            saveLastClickedApi(url);

            // Save current state to sessionStorage for restoration after page refresh
            const currentApi = allApis.find(api => api.url === url);
            if (currentApi) {
                sessionStorage.setItem('currentApiUrl', url);
                sessionStorage.setItem('currentApiName', currentApi.name);
                sessionStorage.setItem('viewState', 'api-documentation');

                // Push to browser history to enable back/forward navigation
                history.pushState(
                    { view: 'api-documentation', apiUrl: url, apiName: currentApi.name },
                    `${currentApi.name} - API Documentation`,
                    `#/api/${encodeURIComponent(currentApi.name)}`
                );
            }

            // Load the API documentation
            loadApiDocumentation(url, true);
        }

        function loadApiDocumentation(url, updateHistory = true) {
            if (!url) return;

            // Show Swagger UI and hide landing page
            showSwaggerUI();

            // Update Swagger UI with the selected API
            if (typeof ui !== 'undefined') {
                ui.specActions.updateUrl(url);
                ui.specActions.download(url);

                // Initialize endpoint filtering for the new API spec
                // Try multiple times with increasing delays to catch when spec loads
                let attempts = 0;
                const maxAttempts = 10;

                const tryInitializeFiltering = () => {
                    attempts++;
                    try {
                        const spec = ui.getState().getIn(['spec', 'json']);
                        if (spec && spec.toJS) {
                            const specJson = spec.toJS();
                            console.log(`🎯 Spec loaded on attempt ${attempts}, initializing filtering...`);
                            
                            // IMPORTANT: Restore endpoint filters BEFORE initializing the UI
                            // This ensures the chips are generated with the correct active state
                            if (shouldSaveFilters) {
                                const hasRestoredFilters = loadEndpointFilters();
                                if (hasRestoredFilters) {
                                    console.log('🔄 Restored endpoint filters before UI initialization');
                                }
                            }
                            
                            // Now initialize the UI with the restored filters already in place
                            initializeEndpointFiltering(specJson);
                            
                            // Apply filters to update the visible endpoints
                            if (shouldSaveFilters && (activeEndpointMethods.size > 0 || activeEndpointTags.size > 0)) {
                                setTimeout(() => {
                                    console.log('✅ Applying restored endpoint filters...');
                                    updateEndpointMethodFilterUI();
                                    updateEndpointTagFilterUI();
                                    applyEndpointFilters();
                                }, 300);
                            }
                            
                            return true;
                        }
                    } catch (error) {
                        console.log(`Attempt ${attempts}: Could not access spec:`, error);
                    }

                    if (attempts < maxAttempts) {
                        setTimeout(tryInitializeFiltering, attempts * 500);
                    } else {
                        console.warn("⚠️ Could not initialize endpoint filtering after all attempts");
                    }
                    return false;
                };

                tryInitializeFiltering();
            }

            // Update history if needed (for direct navigation, not browser back/forward)
            if (updateHistory) {
                const currentApi = allApis.find(api => api.url === url);
                if (currentApi) {
                    history.replaceState(
                        { view: 'api-documentation', apiUrl: url, apiName: currentApi.name },
                        `${currentApi.name} - API Documentation`,
                        `#/api/${encodeURIComponent(currentApi.name)}`
                    );
                }
            }
        }

        function setupCustomDropdown() {
            const customDropdown = document.getElementById("customDropdown");
            const dropdownList = document.getElementById("dropdownList");
            const dropdownText = document.getElementById("dropdownText");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            // Toggle dropdown on click
            customDropdown.addEventListener("click", function (e) {
                e.stopPropagation();
                toggleCustomDropdown();
            });

            // Close dropdown when clicking outside
            document.addEventListener("click", function (e) {
                if (!customDropdown.contains(e.target) && !dropdownList.contains(e.target)) {
                    closeCustomDropdown();
                }
            });

            // Keyboard navigation
            customDropdown.addEventListener("keydown", function (e) {
                e.preventDefault();
                if (e.key === "Enter" || e.key === " ") {
                    toggleCustomDropdown();
                } else if (e.key === "ArrowDown") {
                    openCustomDropdown();
                    focusNextItem(-1);
                } else if (e.key === "ArrowUp") {
                    openCustomDropdown();
                    focusNextItem(1);
                } else if (e.key === "Escape") {
                    closeCustomDropdown();
                }
            });

            // Add keyboard navigation to dropdown items
            dropdownList.addEventListener("keydown", function (e) {
                const items = Array.from(dropdownList.querySelectorAll('.dropdown-item'));
                const currentIndex = items.findIndex(item => item.classList.contains('focused'));

                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    focusNextItem(currentIndex);
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    focusPrevItem(currentIndex);
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (currentIndex >= 0) {
                        items[currentIndex].click();
                    }
                } else if (e.key === "Escape") {
                    closeCustomDropdown();
                    customDropdown.focus();
                }
            });
        }

        function toggleCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");

            if (dropdownList.classList.contains("show")) {
                closeCustomDropdown();
            } else {
                openCustomDropdown();
            }
        }

        function openCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            dropdownList.classList.add("show");
            customDropdown.classList.add("active");
            dropdownArrow.style.transform = "translateY(-50%) rotate(180deg)";
        }

        function closeCustomDropdown() {
            const dropdownList = document.getElementById("dropdownList");
            const customDropdown = document.getElementById("customDropdown");
            const dropdownArrow = document.querySelector(".dropdown-arrow");

            dropdownList.classList.remove("show");
            customDropdown.classList.remove("active");
            dropdownArrow.style.transform = "translateY(-50%) rotate(0deg)";

            // Clear focus from items
            dropdownList.querySelectorAll('.dropdown-item').forEach(item => {
                item.classList.remove('focused');
            });
        }

        function focusNextItem(currentIndex) {
            const items = Array.from(document.getElementById("dropdownList").querySelectorAll('.dropdown-item'));
            const nextIndex = currentIndex + 1;

            items.forEach(item => item.classList.remove('focused'));

            if (nextIndex < items.length) {
                items[nextIndex].classList.add('focused');
                items[nextIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function focusPrevItem(currentIndex) {
            const items = Array.from(document.getElementById("dropdownList").querySelectorAll('.dropdown-item'));
            const prevIndex = currentIndex - 1;

            items.forEach(item => item.classList.remove('focused'));

            if (prevIndex >= 0) {
                items[prevIndex].classList.add('focused');
                items[prevIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectDropdownItem(item, api) {
            const dropdownText = document.getElementById("dropdownText");
            const dropdown = document.getElementById("apiDropdown");

            // Update display text
            dropdownText.textContent = item.dataset.name;

            // Update hidden select
            dropdown.value = api.url;

            // Clear previous selection and mark current as selected
            document.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');

            // Close dropdown
            closeCustomDropdown();

            // Add visual feedback
            const customDropdown = document.getElementById("customDropdown");
            customDropdown.style.borderColor = "#10b981";
            customDropdown.style.background = "linear-gradient(135deg, rgba(240, 253, 244, 1) 0%, rgba(220, 252, 231, 0.98) 100%)";

            setTimeout(() => {
                customDropdown.style.borderColor = "";
                customDropdown.style.background = "";
            }, 1000);

            // Navigate to API
            navigateToApi(api.url);
        }

        function setupAutocomplete() {
            const input = document.getElementById("apiSearch");
            const list = document.getElementById("autocomplete-list");
            const dropdown = document.getElementById("apiDropdown");
            let searchTimeout;
            let rafId;

            input.addEventListener("input", function () {
                clearTimeout(searchTimeout);
                if (rafId) cancelAnimationFrame(rafId);

                const query = this.value.toLowerCase().trim();

                // Instant visual feedback for filtering using RAF
                if (isLandingPage) {
                    rafId = requestAnimationFrame(() => {
                        performRealTimeFiltering(query);
                    });
                } else if (endpointFilteringEnabled) {
                    // Apply endpoint filtering in real-time when in API docs mode
                    rafId = requestAnimationFrame(() => {
                        applyEndpointFilters();
                    });
                }

                // Autocomplete suggestions with minimal delay
                if (!query) {
                    hideAutocomplete();
                    return;
                }

                // Reduced delay for faster response
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 100);
            });

            // Clear search when input is cleared
            input.addEventListener("keyup", function (e) {
                if (e.key === "Escape" || this.value === "") {
                    clearSearch();
                }
                toggleClearButton();
            });

            // Handle clear search button
            const clearButton = document.getElementById('clearSearch');
            clearButton.addEventListener('click', function () {
                input.value = '';
                clearSearch();
                toggleClearButton();
                input.focus();
            });

            // Show/hide clear button based on input content
            function toggleClearButton() {
                const clearButton = document.getElementById('clearSearch');
                if (input.value.trim()) {
                    clearButton.style.display = 'block';
                } else {
                    clearButton.style.display = 'none';
                }
            }

            function performSearch(query) {
                // Clear existing items immediately
                list.innerHTML = "";

                // Use RAF for smoother rendering
                requestAnimationFrame(() => {
                    // If in API documentation view, search endpoints instead of APIs
                    if (endpointFilteringEnabled && !isLandingPage && Array.isArray(currentApiEndpoints)) {
                        const matches = currentApiEndpoints.filter(endpoint => {
                            const path = (endpoint.path || '').toLowerCase();
                            const method = (endpoint.method || '').toLowerCase();
                            const summary = (endpoint.summary || '').toLowerCase();
                            const description = (endpoint.description || '').toLowerCase();
                            const tags = Array.isArray(endpoint.tags) ? endpoint.tags.map(t => String(t).toLowerCase()).join(' ') : '';
                            
                            return path.includes(query) ||
                                method.includes(query) ||
                                summary.includes(query) ||
                                description.includes(query) ||
                                tags.includes(query);
                        });

                        if (matches.length > 0) {
                            const fragment = document.createDocumentFragment();

                            matches.slice(0, 8).forEach((endpoint, index) => {
                                const item = document.createElement("div");
                                item.classList.add("autocomplete-item");
                                
                                const methodColors = {
                                    'get': '#0284c7',
                                    'post': '#16a34a',
                                    'put': '#ca8a04',
                                    'patch': '#ea580c',
                                    'delete': '#dc2626',
                                    'options': '#9333ea',
                                    'head': '#64748b'
                                };
                                
                                const method = (endpoint.method || '').toUpperCase();
                                const methodColor = methodColors[method.toLowerCase()] || '#64748b';
                                const pathHighlighted = highlightMatch(endpoint.path || '', query);
                                const summaryHighlighted = endpoint.summary ? highlightMatch(endpoint.summary, query) : '';
                                const tags = Array.isArray(endpoint.tags) ? endpoint.tags.join(', ') : '';
                                
                                item.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <span style="font-weight: 700; color: ${methodColor}; font-size: 0.7rem; min-width: 50px;">${method}</span>
                                <span style="font-weight: 600; font-size: 0.85rem;">${pathHighlighted}</span>
                            </div>
                            ${summaryHighlighted ? `<div style="font-size: 0.75rem; color: #64748b; margin-bottom: 2px;">${summaryHighlighted}</div>` : ''}
                            ${tags ? `<div style="font-size: 0.7rem; color: #0f766e;">
                                <i class="fas fa-tag" style="margin-right: 4px;"></i>${tags}
                            </div>` : ''}
                        `;
                                item.onclick = () => {
                                    selectEndpoint(endpoint);
                                };
                                item.style.opacity = "0";
                                item.style.transform = "translateY(10px)";
                                item.style.transition = "opacity 0.2s ease, transform 0.2s ease";

                                fragment.appendChild(item);

                                // Stagger animations with RAF
                                requestAnimationFrame(() => {
                                    setTimeout(() => {
                                        item.style.opacity = "1";
                                        item.style.transform = "translateY(0)";
                                    }, index * 30);
                                });
                            });

                            list.appendChild(fragment);
                            showAutocomplete();
                        } else {
                            const noResults = document.createElement("div");
                            noResults.classList.add("autocomplete-item");
                            noResults.innerHTML = `<div style="color: #64748b; text-align: center; font-style: italic;">
                                <i class="fas fa-search" style="margin-right: 8px;"></i>No endpoints found matching "${query}"
                            </div>`;
                            noResults.style.cursor = "default";
                            list.appendChild(noResults);
                            showAutocomplete();
                        }
                    } else {
                        // Landing page mode: search APIs
                        const matches = allApis.filter(api => {
                            const serviceName = extractServiceName(api.name);
                            const domain = extractDomain(api.name);
                            return serviceName.toLowerCase().includes(query) ||
                                api.name.toLowerCase().includes(query) ||
                                domain.toLowerCase().includes(query);
                        });

                        if (matches.length > 0) {
                            // Create a document fragment for better performance
                            const fragment = document.createDocumentFragment();

                            matches.slice(0, 8).forEach((api, index) => {
                                const item = document.createElement("div");
                                item.classList.add("autocomplete-item");
                                const serviceName = extractServiceName(api.name);
                                const domain = extractDomain(api.name);
                                const nameHighlighted = highlightMatch(serviceName, query);
                                const domainColors = getDomainColor(domain);
                                item.innerHTML = `
                            <div style="font-weight: 600; margin-bottom: 2px;">${nameHighlighted}</div>
                            <div style="font-size: 0.75rem; color: ${domainColors.text}; font-weight: 500;">
                                <i class="fas fa-tag" style="margin-right: 4px; font-size: 0.7rem;"></i>${domain}
                            </div>
                        `;
                                item.onclick = () => {
                                    selectApi(api);
                                };
                                item.style.opacity = "0";
                                item.style.transform = "translateY(10px)";
                                item.style.transition = "opacity 0.2s ease, transform 0.2s ease";

                                fragment.appendChild(item);

                                // Stagger animations with RAF
                                requestAnimationFrame(() => {
                                    setTimeout(() => {
                                        item.style.opacity = "1";
                                        item.style.transform = "translateY(0)";
                                    }, index * 30);
                                });
                            });

                            list.appendChild(fragment);
                            showAutocomplete();
                        } else {
                            const noResults = document.createElement("div");
                            noResults.classList.add("autocomplete-item");
                            noResults.innerHTML = `      <div style="color: #64748b; text-align: center; font-style: italic;">        <i class="fas fa-search" style="margin-right: 8px;"></i>        No APIs found matching "${query}"      </div>    `;
                            noResults.style.cursor = "default";
                            list.appendChild(noResults);
                            showAutocomplete();
                        }
                    }
                });
            }

            function selectApi(api) {
                input.value = "";
                hideAutocomplete();
                dropdown.value = api.url;
                input.style.borderColor = "#10b981";
                setTimeout(() => {
                    input.style.borderColor = "";
                }, 1000);

                // Clear any search filtering
                clearSearch();

                // Highlight the corresponding hexagon if on landing page
                if (isLandingPage) {
                    const hexagons = document.querySelectorAll('.hexagon-item');
                    hexagons.forEach((hexagon, index) => {
                        hexagon.classList.remove('active');
                        if (allApis[index] && allApis[index].url === api.url) {
                            hexagon.classList.add('active');
                            setTimeout(() => {
                                navigateToApi(api.url);
                            }, 300);
                            return;
                        }
                    });
                } else {
                    navigateToApi(api.url);
                }
            }

            function selectEndpoint(endpoint) {
                input.value = "";
                hideAutocomplete();
                
                input.style.borderColor = "#10b981";
                setTimeout(() => {
                    input.style.borderColor = "";
                }, 1000);

                // Scroll to the endpoint in Swagger UI
                setTimeout(() => {
                    const operations = document.querySelectorAll('.swagger-ui .opblock');
                    const method = (endpoint.method || '').toLowerCase();
                    const path = (endpoint.path || '').toLowerCase();
                    
                    for (const operation of operations) {
                        const methodElement = operation.querySelector('.opblock-summary-method');
                        const pathElement = operation.querySelector('.opblock-summary-path');
                        
                        if (methodElement && pathElement) {
                            const opMethod = methodElement.textContent.toLowerCase().trim();
                            const opPath = pathElement.textContent.toLowerCase().trim();
                            
                            if (opMethod === method && opPath === path) {
                                // Scroll to the operation
                                operation.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                
                                // Expand the operation if it's collapsed
                                const isExpanded = operation.classList.contains('is-open');
                                if (!isExpanded) {
                                    const summaryButton = operation.querySelector('.opblock-summary');
                                    if (summaryButton) {
                                        summaryButton.click();
                                    }
                                }
                                
                                // Visual feedback
                                operation.style.transition = 'background-color 0.3s ease';
                                operation.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                setTimeout(() => {
                                    operation.style.backgroundColor = '';
                                }, 2000);
                                
                                break;
                            }
                        }
                    }
                }, 100);
            }

            // Real-time filtering function that works across all views
            function performRealTimeFiltering(query) {
                const trimmedQuery = query.toLowerCase().trim();

                if (isLandingPage) {
                    // Apply filtering to current view
                    switch (currentView) {
                        case 'hexagon':
                            renderHexagonView(); // This will now consider all filters: search, domain, and method
                            break;
                        case 'card':
                            renderCardView(); // This will now consider all filters: search, domain, and method
                            break;
                        default:
                            // Fallback to direct hexagon filtering for compatibility
                            filterHexagonsDirectly(trimmedQuery);
                            break;
                    }

                    // Show/hide no results message
                    const visibleCount = getVisibleItemsCount();
                    showNoResultsMessage(visibleCount === 0 && (trimmedQuery || activeDomains.size > 0));
                }
            }

            // Helper function to count visible items in current view
            function getVisibleItemsCount() {
                switch (currentView) {
                    case 'hexagon':
                        return document.querySelectorAll('.hexagon-item:not(.domain-filtered-out)').length;
                    case 'card':
                        return document.querySelectorAll('.api-card').length;
                    default:
                        return allApis.length;
                }
            }

            // Real-time hexagon filtering function with consistent behavior
            function filterHexagonsDirectly(query) {
                const hexagons = document.querySelectorAll('.hexagon-item');
                let visibleCount = 0;

                // Use RAF for smooth rendering with immediate, consistent behavior
                requestAnimationFrame(() => {
                    hexagons.forEach((hexagon, index) => {
                        const api = allApis[index];
                        if (!api) return;

                        const serviceName = extractServiceName(api.name);
                        const domain = extractDomain(api.name);

                        // Check if matches search query
                        const matchesQuery = !query ||
                            serviceName.toLowerCase().includes(query) ||
                            api.name.toLowerCase().includes(query) ||
                            domain.toLowerCase().includes(query);

                        // Check if matches domain filter
                        const matchesDomain = activeDomains.size === 0 || activeDomains.has(domain);

                        // Show only if matches search and domain conditions
                        const shouldShow = matchesQuery && matchesDomain;

                        if (shouldShow) {
                            // Show immediately and cleanly - no position memory
                            hexagon.classList.remove('domain-filtered-out');
                            hexagon.classList.add('domain-filtered-in');
                            hexagon.style.display = 'block';
                            hexagon.style.visibility = 'visible';
                            hexagon.style.position = 'relative';
                            hexagon.style.opacity = '1';
                            hexagon.style.transform = 'scale(1) translateY(0)';
                            hexagon.style.filter = 'none';
                            visibleCount++;

                            // Highlight matching text in hexagon
                            if (query) {
                                highlightHexagonText(hexagon, query, serviceName);
                            } else {
                                clearHexagonHighlight(hexagon);
                            }
                        } else {
                            // Hide immediately and cleanly like card view
                            hexagon.classList.remove('domain-filtered-in');
                            hexagon.classList.add('domain-filtered-out');
                            hexagon.style.display = 'none';
                            hexagon.style.visibility = 'hidden';
                            hexagon.style.opacity = '0';

                            clearHexagonHighlight(hexagon);
                        }
                    });

                    // Update counter
                    updateViewCounter(visibleCount, query);

                    // Show "no results" message if needed
                    showNoResultsMessage(visibleCount === 0 && (query || activeDomains.size > 0));
                });
            }

            function highlightHexagonText(hexagon, query, displayName) {
                const titleElement = hexagon.querySelector('.hexagon-title');

                if (titleElement && !titleElement.dataset.originalText) {
                    titleElement.dataset.originalText = displayName || titleElement.textContent;
                }

                if (titleElement && titleElement.dataset.originalText) {
                    titleElement.innerHTML = highlightMatch(titleElement.dataset.originalText, query);
                }
            }

            function clearHexagonHighlight(hexagon) {
                const titleElement = hexagon.querySelector('.hexagon-title');

                if (titleElement && titleElement.dataset.originalText) {
                    titleElement.textContent = titleElement.dataset.originalText;
                }
            }

            function clearSearch() {
                if (isLandingPage) {
                    // Clear search for all views
                    switch (currentView) {
                        case 'hexagon':
                            renderHexagonView(); // This will render without search query
                            break;
                        case 'card':
                            renderCardView(); // This will render without search query  
                            break;
                        default:
                            // Fallback to direct filtering
                            clearSearchDirect();
                            break;
                    }

                    hideNoResultsMessage();
                }
            }

            function clearSearchDirect() {
                // Reapply domain filters without search query
                if (activeDomains.size > 0) {
                    applyDomainFilter();
                } else {
                    // Use RAF for smooth rendering with immediate, consistent behavior
                    requestAnimationFrame(() => {
                        const hexagons = document.querySelectorAll('.hexagon-item');

                        hexagons.forEach(hexagon => {
                            // Clean reset - no position memory or animation delays
                            hexagon.classList.remove('domain-filtered-out');
                            hexagon.classList.add('domain-filtered-in');
                            hexagon.style.display = 'block';
                            hexagon.style.visibility = 'visible';
                            hexagon.style.position = 'relative';
                            hexagon.style.opacity = '1';
                            hexagon.style.transform = 'scale(1) translateY(0)';
                            hexagon.style.filter = 'none';
                            hexagon.style.transitionDelay = '0s';
                            clearHexagonHighlight(hexagon);
                        });

                        // Reset counter immediately
                        if (allApis) {
                            updateApiCounter(allApis.length);
                        }
                    });
                }
            }

            function showNoResultsMessage(show) {
                let noResultsDiv = document.getElementById('no-results-message');

                if (show && !noResultsDiv) {
                    noResultsDiv = document.createElement('div');
                    noResultsDiv.id = 'no-results-message';
                    noResultsDiv.style.cssText = `
                text-align: center;
                padding: 40px 20px;
                color: #64748b;
                font-size: 1.1rem;
                font-weight: 500;
                animation: fadeInScale 0.3s ease;
            `;
                    noResultsDiv.innerHTML = `
                <i class="fas fa-search" style="font-size: 3rem; margin-bottom: 16px; opacity: 0.5;"></i>
                <div>No APIs match your search criteria</div>
                <div style="font-size: 0.9rem; margin-top: 8px; opacity: 0.7;">Try adjusting your search terms</div>
            `;
                    document.getElementById('hexagonGrid').appendChild(noResultsDiv);
                } else if (!show && noResultsDiv) {
                    noResultsDiv.remove();
                }
            }

            function hideNoResultsMessage() {
                const noResultsDiv = document.getElementById('no-results-message');
                if (noResultsDiv) {
                    noResultsDiv.remove();
                }
            }

            function showAutocomplete() {
                list.style.display = "block";
            }

            function hideAutocomplete() {
                list.style.display = "none";
            }

            input.addEventListener("keydown", function (e) {
                const items = list.querySelectorAll(".autocomplete-item");
                let selectedIndex = Array.from(items).findIndex(item => item.classList.contains("selected"));
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    if (selectedIndex < items.length - 1) {
                        if (selectedIndex >= 0) items[selectedIndex].classList.remove("selected");
                        items[selectedIndex + 1].classList.add("selected");
                    }
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    if (selectedIndex > 0) {
                        items[selectedIndex].classList.remove("selected");
                        items[selectedIndex - 1].classList.add("selected");
                    }
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex].onclick) {
                        items[selectedIndex].click();
                    }
                } else if (e.key === "Escape") {
                    hideAutocomplete();
                    input.blur();
                }
            });
            document.addEventListener("click", e => {
                if (!list.contains(e.target) && e.target !== input) {
                    hideAutocomplete();
                }
            });
        }

        // Global helper function for hiding no results message
        function hideNoResultsMessage() {
            const noResultsDiv = document.getElementById('no-results-message');
            if (noResultsDiv) {
                noResultsDiv.remove();
            }
        }

        // Ripple effect function
        function createRippleEffect(element, event) {
            const ripple = document.createElement('span');
            const rect = element.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const x = event ? event.clientX - rect.left - size / 2 : rect.width / 2 - size / 2;
            const y = event ? event.clientY - rect.top - size / 2 : rect.height / 2 - size / 2;

            ripple.style.cssText = `
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple 0.6s linear;
        background-color: rgba(14, 165, 233, 0.3);
        left: ${x}px;
        top: ${y}px;
        width: ${size}px;
        height: ${size}px;
        pointer-events: none;
        z-index: 1;
    `;

            element.style.position = 'relative';
            element.style.overflow = 'hidden';
            element.appendChild(ripple);

            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        // Initialize view switcher functionality
        // Initialize view switcher functionality
        function initializeViewSwitcherEvents() {
            console.log("🎯 Setting up view switcher event listeners...");

            // Add click event listeners to view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const viewType = this.getAttribute('data-view');
                    switchView(viewType);
                });
            });

            console.log("✅ View switcher event listeners set up");
        }

        function initializeViewSwitcher() {
            console.log("🎯 Initializing view switcher with loaded APIs...");

            // Load saved view preference
            const savedView = localStorage.getItem('preferred-view') || 'hexagon';
            if (['hexagon', 'card'].includes(savedView)) {
                // Actually switch to the saved view
                currentView = 'hexagon'; // Reset to ensure switchView will work
                switchView(savedView);
            }

            console.log(`✅ View switcher initialized with ${currentView} view`);
        }

        // NEW: Initialize navbar filter controls per manager request
        function initializeNavbarFilterControls() {
            // Clear filters button
            const clearBtn = document.getElementById('navbarClearFilters');
            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    // Check if we're in endpoint filtering mode
                    if (endpointFilteringEnabled && !isLandingPage) {
                        // Clear endpoint filters
                        activeEndpointMethods.clear();
                        activeEndpointTags.clear();
                        updateEndpointMethodFilterUI();
                        updateEndpointTagFilterUI();
                        applyEndpointFilters();
                        console.log('🧹 Cleared all endpoint filters from navbar');
                        
                        // Refresh the filter dropdown chips to show all methods again
                        populateFilterDropdownEndpointChips();
                        
                        // Update dropdown to show all tags
                        populateNavbarEndpointTagsDropdown();
                    } else {
                        // Clear domain filters
                        activeDomains.clear();
                        selectedDomain = '';
                        selectDomainFilter('');
                        console.log('🧹 Cleared all domain filters from navbar');
                        
                        // Refresh the filter dropdown chips to show all domains again
                        populateFilterDropdownDomainChips();
                        
                        // Update domain dropdown to show all domains
                        if (apisByDomain) {
                            const allDomains = Object.keys(apisByDomain).sort();
                            populateNavbarDomainDropdown(allDomains);
                        }
                    }
                    
                    // Keep the dropdown open so user can continue filtering
                    // Don't close it
                });
            }
            
            // Save filters toggle button
            const saveBtn = document.getElementById('navbarToggleSaveFilters');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    toggleFilterSaving();
                    // Update button text
                    const btnText = document.getElementById('navbarSaveBtnText');
                    if (btnText) {
                        btnText.textContent = shouldSaveFilters ? 'Save: ON' : 'Save: OFF';
                    }
                    // Update button style
                    if (shouldSaveFilters) {
                        saveBtn.style.background = 'var(--primary-gradient)';
                        saveBtn.style.color = 'white';
                    } else {
                        saveBtn.style.background = 'rgba(15, 118, 110, 0.1)';
                        saveBtn.style.color = '#0f766e';
                    }
                    // Don't close dropdown - keep it open for continued filtering
                });
                
                // Initialize button state from localStorage
                const savedState = localStorage.getItem('shouldSaveFilters');
                const isEnabled = savedState === '1';
                shouldSaveFilters = isEnabled; // Update global variable
                
                const btnText = document.getElementById('navbarSaveBtnText');
                if (btnText) {
                    btnText.textContent = isEnabled ? 'Save: ON' : 'Save: OFF';
                }
                if (isEnabled) {
                    saveBtn.style.background = 'var(--primary-gradient)';
                    saveBtn.style.color = 'white';
                } else {
                    saveBtn.style.background = 'rgba(15, 118, 110, 0.1)';
                    saveBtn.style.color = '#0f766e';
                }
            }
        }
        
        // Setup filter settings dropdown toggle
        function setupFilterSettingsDropdown() {
            const settingsBtn = document.getElementById('filterSettingsBtn');
            const settingsDropdown = document.getElementById('filterSettingsDropdown');
            
            if (settingsBtn && settingsDropdown) {
                settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = settingsDropdown.style.display === 'block';
                    settingsDropdown.style.display = isVisible ? 'none' : 'block';
                    
                    // Populate appropriate chips based on current view
                    if (!isVisible) {
                        if (endpointFilteringEnabled && !isLandingPage) {
                            populateFilterDropdownEndpointChips();
                        } else {
                            populateFilterDropdownDomainChips();
                        }
                    }
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!settingsBtn.contains(e.target) && !settingsDropdown.contains(e.target)) {
                        settingsDropdown.style.display = 'none';
                    }
                });
                
                // Prevent dropdown from closing when clicking inside it
                settingsDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
        }
        
        // Populate domain chips in filter dropdown
        function populateFilterDropdownDomainChips() {
            const container = document.getElementById('filterDropdownDomainChips');
            if (!container || !allApis || allApis.length === 0) return;
            
            // Update section title and hide tags section
            const sectionTitle = document.getElementById('filterSection1Title');
            if (sectionTitle) {
                sectionTitle.textContent = 'Filter by Domain';
            }
            const tagSection = document.getElementById('filterTagsSection');
            if (tagSection) {
                tagSection.style.display = 'none';
            }
            
            // Group APIs by domain
            const domainGroups = groupApisByDomain(allApis);
            const domains = Object.keys(domainGroups).sort();
            
            container.innerHTML = '';
            
            domains.forEach(domain => {
                const count = domainGroups[domain].length;
                const colors = getDomainColor(domain);
                const isActive = activeDomains.has(domain);
                
                const chip = document.createElement('div');
                chip.className = 'domain-chip';
                chip.dataset.domain = domain;
                chip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    padding: 6px 12px;
                    border-radius: 20px;
                    font-size: 0.8rem;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                    background: ${isActive ? colors.bg : 'rgba(0,0,0,0.03)'};
                    color: ${isActive ? colors.text : '#64748b'};
                    border: 1.5px solid ${isActive ? colors.border : 'rgba(0,0,0,0.08)'};
                `;
                
                chip.innerHTML = `
                    <span>${domain}</span>
                    <span style="background: ${isActive ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.1)'}; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">${count}</span>
                `;
                
                chip.addEventListener('click', () => {
                    toggleDomainFilter(domain);
                    // Update chip appearance
                    populateFilterDropdownDomainChips();
                });
                
                container.appendChild(chip);
            });
        }
        
        // Populate endpoint method and tag chips in filter dropdown (for API documentation view)
        function populateFilterDropdownEndpointChips() {
            const methodContainer = document.getElementById('filterDropdownDomainChips');
            const tagContainer = document.getElementById('filterDropdownTagChips');
            const tagSection = document.getElementById('filterTagsSection');
            const sectionTitle = document.getElementById('filterSection1Title');
            
            if (!methodContainer) return;
            
            // Update section title and show tags section
            if (sectionTitle) {
                sectionTitle.textContent = 'Filter by HTTP Method';
            }
            if (tagSection) {
                tagSection.style.display = 'block';
            }
            
            methodContainer.innerHTML = '';
            if (tagContainer) tagContainer.innerHTML = '';
            
            // Get HTTP methods and tags from current endpoints
            const methodCounts = {};
            const tagCounts = {};
            if (currentApiEndpoints && currentApiEndpoints.length > 0) {
                currentApiEndpoints.forEach(endpoint => {
                    const method = endpoint.method.toLowerCase();
                    methodCounts[method] = (methodCounts[method] || 0) + 1;
                    
                    // Count tags
                    if (Array.isArray(endpoint.tags)) {
                        endpoint.tags.forEach(tag => {
                            const tagStr = String(tag || '').trim();
                            if (tagStr) {
                                tagCounts[tagStr] = (tagCounts[tagStr] || 0) + 1;
                            }
                        });
                    }
                });
            }
            
            const methodColors = {
                'get': { bg: '#e0f2fe', text: '#0284c7', border: '#7dd3fc' },
                'post': { bg: '#dcfce7', text: '#16a34a', border: '#86efac' },
                'put': { bg: '#fef3c7', text: '#ca8a04', border: '#fde047' },
                'patch': { bg: '#fed7aa', text: '#ea580c', border: '#fdba74' },
                'delete': { bg: '#fee2e2', text: '#dc2626', border: '#fca5a5' },
                'options': { bg: '#f3e8ff', text: '#9333ea', border: '#d8b4fe' },
                'head': { bg: '#e5e7eb', text: '#6b7280', border: '#d1d5db' }
            };
            
            // Populate HTTP methods
            Object.keys(methodCounts).sort().forEach(method => {
                const count = methodCounts[method];
                const colors = methodColors[method] || { bg: '#f3f4f6', text: '#6b7280', border: '#d1d5db' };
                const isActive = activeEndpointMethods.has(method);
                
                const chip = document.createElement('div');
                chip.className = 'endpoint-method-chip';
                chip.dataset.method = method;
                chip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    padding: 6px 12px;
                    border-radius: 20px;
                    font-size: 0.8rem;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                    background: ${isActive ? colors.bg : 'rgba(0,0,0,0.03)'};
                    color: ${isActive ? colors.text : '#64748b'};
                    border: 1.5px solid ${isActive ? colors.border : 'rgba(0,0,0,0.08)'};
                `;
                
                chip.innerHTML = `
                    <span>${method.toUpperCase()}</span>
                    <span style="background: ${isActive ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.1)'}; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">${count}</span>
                `;
                
                chip.addEventListener('click', () => {
                    toggleEndpointMethodFilter(method);
                    populateFilterDropdownEndpointChips();
                    populateNavbarEndpointTagsDropdown();
                });
                
                methodContainer.appendChild(chip);
            });
            
            // Populate tags
            if (tagContainer) {
                Object.keys(tagCounts).sort().forEach(tag => {
                    const count = tagCounts[tag];
                    const isActive = activeEndpointTags.has(tag);
                    
                    const chip = document.createElement('div');
                    chip.className = 'endpoint-tag-chip';
                    chip.dataset.tag = tag;
                    chip.style.cssText = `
                        display: inline-flex;
                        align-items: center;
                        gap: 6px;
                        padding: 6px 12px;
                        border-radius: 20px;
                        font-size: 0.8rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                        background: ${isActive ? '#e0f2fe' : 'rgba(0,0,0,0.03)'};
                        color: ${isActive ? '#0284c7' : '#64748b'};
                        border: 1.5px solid ${isActive ? '#7dd3fc' : 'rgba(0,0,0,0.08)'};
                    `;
                    
                    chip.innerHTML = `
                        <span>${tag}</span>
                        <span style="background: ${isActive ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.1)'}; padding: 2px 6px; border-radius: 10px; font-size: 0.7rem;">${count}</span>
                    `;
                    
                    chip.addEventListener('click', () => {
                        toggleEndpointTagFilter(tag);
                        populateFilterDropdownEndpointChips();
                        populateNavbarEndpointTagsDropdown();
                    });
                    
                    tagContainer.appendChild(chip);
                });
            }
        }
        
        window.onload = function () {
            console.log("🚀 Page loaded, initializing...");

            // Ensure essential DOM elements exist (header counters removed on purpose)
            const requiredElements = ['hexagonGrid', 'apiSearch'];
            const missingElements = requiredElements.filter(id => !document.getElementById(id));

            if (missingElements.length > 0) {
                console.error("❌ Missing required DOM elements:", missingElements);
                return;
            }

            console.log("✅ All required DOM elements found");

            // Initialize Swagger UI (hidden initially)
            ui = SwaggerUIBundle({
                dom_id: "#swagger-ui",
                url: "/api",
                deepLinking: true,
                presets: [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset],
                layout: "BaseLayout",
                docExpansion: "list",
                defaultModelsExpandDepth: 2,
                defaultModelExpandDepth: 2,
                showExtensions: true,
                showCommonExtensions: true,
                tryItOutEnabled: true,
                onComplete: function () {
                    // Swagger UI is ready
                    console.log("✅ Swagger UI initialized successfully");

                    // Try to initialize endpoint filtering
                    setTimeout(() => {
                        try {
                            const spec = ui.getState().getIn(['spec', 'json']);
                            if (spec && spec.toJS) {
                                const specJson = spec.toJS();
                                console.log("🔄 Spec found in onComplete, initializing endpoint filtering...");
                                
                                // IMPORTANT: Restore endpoint filters BEFORE initializing the UI
                                if (shouldSaveFilters) {
                                    const hasRestoredFilters = loadEndpointFilters();
                                    if (hasRestoredFilters) {
                                        console.log('🔄 Restored endpoint filters in onComplete before UI initialization');
                                    }
                                }
                                
                                initializeEndpointFiltering(specJson);
                                
                                // Apply filters if any were restored
                                if (shouldSaveFilters && (activeEndpointMethods.size > 0 || activeEndpointTags.size > 0)) {
                                    setTimeout(() => {
                                        console.log('✅ Applying restored endpoint filters from onComplete...');
                                        updateEndpointMethodFilterUI();
                                        updateEndpointTagFilterUI();
                                        applyEndpointFilters();
                                    }, 300);
                                }
                            } else {
                                console.log("⏳ Spec not yet loaded in onComplete");
                            }
                        } catch (error) {
                            console.log("⚠️ Could not access spec in onComplete:", error);
                        }
                    }, 500);
                }
            });

            // Initialize view switcher event listeners only
            initializeViewSwitcherEvents();
            
            // Initialize navbar filter controls (new per manager request)
            initializeNavbarFilterControls();
            
            // Setup filter settings dropdown
            setupFilterSettingsDropdown();

            // Load APIs and show landing page
            console.log("🔄 Starting API loading...");
            loadApis();

            // Show landing page only if no saved state exists AND no hash in URL
            const hash = window.location.hash;
            const savedViewState = sessionStorage.getItem('viewState');
            
            // If there's a hash for deep linking, don't show landing page
            if (hash && hash.startsWith('#/api/')) {
                console.log('🔗 Hash detected in URL, skipping landing page');
            } else if (savedViewState !== 'api-documentation') {
                showLandingPage();
            }
            
            // CRITICAL: Start URL/View sync monitor immediately to catch any mismatches
            console.log('🚀 Starting global URL/View sync monitor on page load');
            startUrlViewSync();
            
            // Load last clicked API from localStorage
            loadLastClickedApi();       
        };
        document.addEventListener('DOMContentLoaded', function () {
            console.log("📄 DOM Content Loaded");
            document.documentElement.style.scrollBehavior = 'smooth';

            // Ensure elements are ready - add a small delay if needed
            setTimeout(() => {
                const apiCountText = document.getElementById('apiCountText');
                if (apiCountText && !apiCountText.innerHTML.includes('Loading')) {
                    console.log("🔄 DOM ready, initializing API counter...");
                    updateApiCounter(0);
                }
            }, 100);

            // Add keyboard navigation
            document.addEventListener('keydown', function (e) {
                // Enter key on hexagons
                if (e.key === 'Enter' && isLandingPage) {
                    const focusedElement = document.activeElement;
                    if (focusedElement.classList.contains('hexagon-item')) {
                        focusedElement.click();
                    }
                }
            });

            // Disable browser find entirely in the app tab: intercept Ctrl/Cmd+F and F3
            // WARNING: This will prevent the browser's native Find dialog from opening
            // while the app tab has focus. This is intentionally aggressive per request.
            document.addEventListener('keydown', function (ev) {
                try {
                    const isFindCombo = ((ev.ctrlKey || ev.metaKey) && (ev.key === 'f' || ev.key === 'F')) || ev.key === 'F3';
                    if (!isFindCombo) return;

                    // Prevent the browser's find UI
                    ev.preventDefault();
                    ev.stopPropagation();

                    // Still focus the app's search so users can search within the app
                    let target = null;
                    const swaggerEl = document.getElementById('swagger-ui');
                    const swaggerVisible = swaggerEl && swaggerEl.classList.contains('show');

                    if (swaggerVisible) {
                        target = document.getElementById('endpointSearch') || (window.filterNotchInstance && window.filterNotchInstance.panel && window.filterNotchInstance.panel.querySelector('.panel-search-row input'));
                        if (!document.getElementById('endpointSearch') && window.filterNotchInstance) {
                            try { window.filterNotchInstance.open(); } catch (e) { /* ignore */ }
                        }
                    } else {
                        target = document.getElementById('apiSearch') || (window.filterNotchInstance && window.filterNotchInstance.panel && window.filterNotchInstance.panel.querySelector('.panel-search-row input'));
                        if (window.filterNotchInstance) {
                            try { window.filterNotchInstance.open(); } catch (e) { /* ignore */ }
                        }
                    }

                    if (target) {
                        try { target.focus(); if (typeof target.select === 'function') target.select(); } catch (e) { /* ignore */ }
                    }
                } catch (e) { /* defensive: never break other key handlers */ }
            }, { capture: true });

            // Make hexagons focusable and add keyboard support
            setTimeout(() => {
                document.querySelectorAll('.hexagon-item').forEach((hexagon, index) => {
                    hexagon.setAttribute('tabindex', '0');
                    hexagon.setAttribute('role', 'button');
                    hexagon.setAttribute('aria-label', `Navigate to ${allApis[index]?.name || 'API'} documentation`);

                    hexagon.addEventListener('keydown', function (e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.click();
                        }
                    });
                });
            }, 1000);

            // Header morph on scroll
            let lastScrollTop = 0;
            let scrollThreshold = 80;
            let ticking = false;

            function handleHeaderScroll() {
                const header = document.querySelector('header');
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                // Calculate scroll progress
                const windowHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrollProgress = (scrollTop / windowHeight) * 100;
                // Update CSS variable for progress bar
                header.style.setProperty('--scroll-progress', `${scrollProgress}%`);

                if (scrollTop > scrollThreshold) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }

                lastScrollTop = scrollTop;
                ticking = false;
            }
            window.addEventListener('scroll', function () {
                if (!ticking) {
                    window.requestAnimationFrame(handleHeaderScroll);
                    ticking = true;
                }
            }, { passive: true });
            // Add resize handler to regenerate grid
            let resizeTimeout;
            window.addEventListener('resize', function () {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (isLandingPage && allApis.length > 0) {
                        renderHexagonView();
                        // Re-add keyboard support after regeneration
                        setTimeout(() => {
                            document.querySelectorAll('.hexagon-item').forEach((hexagon, index) => {
                                hexagon.setAttribute('tabindex', '0');
                                hexagon.setAttribute('role', 'button');
                                hexagon.setAttribute('aria-label', `Navigate to ${allApis[index]?.name || 'API'} documentation`);
                                hexagon.addEventListener('keydown', function (e) {
                                    if (e.key === 'Enter' || e.key === ' ') {
                                        e.preventDefault();
                                        this.click();
                                    }
                                });
                            });
                        }, 100);
                    }
                }, 300);
            });
        });</script>

    <script>
        // Keep the endpoint filter fixed under the header and provide a collapse/expand toggle.
        (function () {
            const root = document.documentElement;
            const header = document.querySelector('header');
            const bar = document.getElementById('endpointFilterBar');
            const toggle = document.getElementById('endpointCollapseToggle');
            function updateVars() {
                if (!header) return;
                // Use getBoundingClientRect().bottom to compute the exact position
                // of the header bottom in viewport coordinates. This keeps the
                // endpoint bar glued to the header even during animations.
                const rect = header.getBoundingClientRect();
                const headerBottom = Math.max(0, rect.bottom);
                root.style.setProperty('--navbar-height', headerBottom + 'px');

                // Set the fixed bar top directly to avoid any timing gaps
                if (bar) {
                    try {
                        bar.style.top = headerBottom + 'px';
                        root.style.setProperty('--endpoint-bar-height', bar.offsetHeight + 'px');
                    } catch (e) {
                        // ignore DOM exceptions
                    }
                }
            }
            // Observe header attribute changes (class toggles when morphing) so the bar stays glued to its bottom.
            try {
                if (header && window.MutationObserver) {
                    const headerObserver = new MutationObserver(() => {
                        // header class or style changed (morphed/unmorphed) -> update CSS vars
                        updateVars();
                    });
                    headerObserver.observe(header, { attributes: true, attributeFilter: ['class', 'style'] });
                }

                // ResizeObserver watches for changes to header size during animations
                if (header && window.ResizeObserver) {
                    const ro = new ResizeObserver(() => updateVars());
                    ro.observe(header);
                }
            } catch (e) {
                // ignore if observers unavailable
            }
            // Also update on scroll using rAF to catch transitions that change header height
            let varTicking = false;
            window.addEventListener('scroll', function () {
                if (!varTicking) {
                    window.requestAnimationFrame(() => {
                        updateVars();
                        varTicking = false;
                    });
                    varTicking = true;
                }
            }, { passive: true });
            
            function setCollapsed(collapsed) {
                if (!bar) return;
                if (collapsed) {
                    bar.classList.add('collapsed');
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.innerHTML = '<i class="fas fa-chevron-down" aria-hidden="true"></i>';
                    }
                } else {
                    bar.classList.remove('collapsed');
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'true');
                        toggle.innerHTML = '<i class="fas fa-chevron-up" aria-hidden="true"></i>';
                    }
                }
                try { localStorage.setItem('endpointFilterCollapsed', collapsed ? '1' : '0'); } catch (e) { }
                // update dimensions after state change and adjust swagger UI padding
                setTimeout(() => {
                    updateVars();
                    try { setSwaggerUiPaddingForFilterBar(true); } catch (e) { }
                }, 120);
            }
            if (toggle) {
                toggle.addEventListener('click', () => {
                    setCollapsed(!bar.classList.contains('collapsed'));
                });
            }

            window.addEventListener('resize', updateVars);
            // initialize after DOM ready
            document.addEventListener('DOMContentLoaded', () => {
                updateVars();
                try {
                    const saved = localStorage.getItem('endpointFilterCollapsed');
                    if (saved === '1') setCollapsed(true);
                    else setCollapsed(false);
                } catch (e) {
                    // ignore
                }
                // run again after a short delay to account for header animations
                setTimeout(updateVars, 300);
            });
        })();
    </script>

    <!-- Scroll-to-top floating button -->
    <style>
        .scroll-top-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 44px;
            height: 44px;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0f766e, #115e59);
            color: white;
            border: none;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.18);
            cursor: pointer;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.22s ease, transform 0.22s ease;
            z-index: 2000;
            pointer-events: none;
        }

        .scroll-top-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .scroll-top-btn:focus {
            outline: none;
            box-shadow: 0 0 0 6px rgba(14, 165, 233, 0.12);
        }
    </style>

    <button id="scrollTopBtn" class="scroll-top-btn" aria-label="Back to top" title="Back to top">
        <i class="fas fa-chevron-up"></i>
    </button>

    <script>
        (function () {
            const btn = document.getElementById('scrollTopBtn');
            if (!btn) return;
            let ticking = false;

            function updateVisibility() {
                const showAfter = 240; // px scrolled before showing
                if (window.scrollY > showAfter) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
                ticking = false;
            }

            window.addEventListener('scroll', function () {
                if (!ticking) {
                    window.requestAnimationFrame(updateVisibility);
                    ticking = true;
                }
            }, { passive: true });

            // show immediately if already scrolled
            document.addEventListener('DOMContentLoaded', updateVisibility);
            btn.addEventListener('click', function (e) {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                // hide button while scrolling to top
                btn.classList.remove('visible');
            });

            // keyboard accessibility
            btn.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    btn.click();
                }
            });
        })();
    </script>
</body>
</html>
